**************************************ドキュメント
Go
インストール
Go
リファレンス
特集
記事
講演
資料
他
言語
ドキュメント
インストール
A
Tour
of
Go
Go
書き方
Effective
Go
質問
(
FAQ
)
The
Go
Wiki
パッケージ
ドキュメント
コマンド
ドキュメント
言語
仕様
Go
メモリ
モデル
The
Go
Blog
Go
ビデオ
ツアー
成熟
コード
Go
並行
処理
パターン
高度
Go
並行
処理
パターン
プログラミング
言語
Go
プログラマ
生産
性
向上
ため
オープンソースプロジェクト
Go
表現
豊か
シンプル
きれい
効率
的
並行
処理
メカニズム
革新
的
型
システム
柔軟
モジュール
化
プログラム
構造
実現
マルチ
コア
ネットワーク
機器
特別
考慮
こと
容易
プログラム
こと
可能
Go
機械
語
コンパイル
ガーベッジコレクション
利便
性
ランタイムリフレクション
パワー
動的
形
付け
インタプリタ
型
言語
静的
型付け
コンパイル
言語
Go
コンパイラ
ツール
ライブラリ
ダウンロード
インストール
手順
3
セクション
インタラクティブ
Go
イントロダクション
最初
セクション
基本
的
文法
データ
構造
メソッド
インタフェース
議論
最後
並行
化
基本
命令
紹介
セクション
練習
問題
学習
内容
復習
利用
オンライン
ツアー
ローカル
インストール
方法
ドキュメント
よう
go
コマンド
パッケージ
コマンド
フェッチ・ビルド・インストール
テスト
実行
の
説明
スクリーン
キャスト
英語
利用
きれい
慣用
的
コード
tips
ドキュメント
すべて
入門
Go
プログラマー
必読
記事
最初
ツアー
言語
仕様
内容
補助
位置づけ
もの
Go
一般
的
質問
回答
Go
コミュニティ
メンテナンス
Wiki
その他
Go
学習
素材
利用
Wiki
Learn
ページ
参照
Go
標準
ライブラリ
説明
書
Go
tool
説明
書
公式
Go
言語
仕様
goroutine
変数
読み出し
際
他
goroutine
変数
値
こと
保証
条件
ドキュメント
Go
プロジェクト
オフィシャルブログ
ニュース
Go
チーム
ゲスト
特集
記事
掲載
英語
Go
プログラム
ガイド
ツアー
Go
記事
場合
Wiki
Articles
ページ
ご覧
Go
さ
さ
生産
性
実現
3
要素
インタフェース
リフレクション
並行
処理
簡単
Web
クローラ
構築
これら
要素
説明
鍵
Go
設計
ゴール
コード
順応
性
簡素
設計
明確
自然
方法
ビルド
こと
講演
送信
TCP
コネクション
ペア
Go
並行
処理
メカニズム
インタフェース
標準
ライブラリ
Web
インタフェース
等
機能
拡張
簡単
チャット
ルーレット
サーバ
Andrew
Gerrand
説明
プログラム
機能
劇的
変化
一方
プログラム
機能
成熟
Go
柔軟
性
プログラム
設計
維持
寄与
様子
ご覧
並行
処理
ハイ
パフォーマンス
ネットワーク
サービス
設計
鍵
Go
並行
化
基本
命令
goroutines
チャネル
並行
処理
実行
実現
シンプル
効率
的
方法
提供
講演
難解
並行
性
問題
シンプル
Go
コード
解決
こと
ご覧
講演
Go
並行
処理
パターン
話題
ディープ
Go
並行
化
基本
命令
Go
講演
内容
Go
講演
資料
wiki
ページ
ご覧
他
言語
翻訳
ドキュメント
Wiki
NonEnglish
ページ
ご覧
ドキュメント
-
The
Go
Programming
Language**************************************本物
プログラマ
Haskell
あなた
お薦め
連載
新着
今
おすすめ
記事
ITpro
SPECIAL
PR
ピックアップ
コンテンツ
PR
ジャンル
新着
記事
現在
ITpro
ランキング
ITpro
Active
昨日
記事
お知らせ
PR
googletag
.
pubads
().
definePassback
('/
54271731
/
ITP
/
theme
_
textad
/
management
/
management
[
1
1
]).
display
();
PR
googletag
.
pubads
().
definePassback
('/
54271731
/
ITP
/
theme
_
textad
/
management
/
management
[
1
1
]).
display
();
PR
googletag
.
pubads
().
definePassback
('/
54271731
/
ITP
/
theme
_
textad
/
management
/
management
[
1
1
]).
display
();
PR
googletag
.
pubads
().
definePassback
('/
54271731
/
ITP
/
theme
_
textad
/
management
/
management
[
1
1
]).
display
();
PR
googletag
.
pubads
().
definePassback
('/
54271731
/
ITP
/
theme
_
textad
/
management
/
management
[
1
1
]).
display
();
58
回
C
配列
Haskell
利用
2013
/
8
/
7
57
回
機能
テスト
性能
テスト
Cabal
自動
化
2012
/
12
/
6
56
回
Cabal
パッケージ
作成
2012
/
11
/
7
55
回
repa
ステンシル
2012
/
10
/
10
グーグル
弱点
克服
企業
向け
クラ
ウド
追撃
全面
ディスプレイ
Galaxy
S
8
スリム
日本
タブー
話題
AI
軍事
利用
日本
オーストラリア
FinTech
企業
支援
協力
話題
STEM
教育
ラズパイ
科学
Pi
-
Top
OS
What
s
New
!
経営
アプリケーション
DB
ミドル
ウエア
クラ
ウド
設計
開発
サーバー
ストレージ
ネットワーク
通信
サービス
セキュリティ
2017
年
モデル
MacBook
上位
Pro
使用
感
DeNA
横浜
市
タクシー
配車
アプリ
実用
実験
アライドテレシス
48
ポート
搭載
ギガ
ビット
PoE
スイッチ
AT
-
GS
950
/
48
PS
夜空
300
機
ローン
ハウステンボス
日本
初
ライト
ショー
Apple
Music
楽曲
使用
料
引き下げ
Apple
レコード
会社
協議
中
特報
NTT
セキュリティ
人材
3
万
人
育成
2020
年
目標
値
3
倍
達成
中国
勢
1
位
2
位
独占
日本
勢
7
位
8
位
後退
スパコン
世界
ランキング
2017
年
モデル
MacBook
上位
Pro
使用
感
ソニー
電子
ペーパー
端末
の
博報堂
AI×
鏡
広告
形
AoT
説明
ロジクール
至高
マウス
アプリ
特報
デンソー
量子
コンピュータ
応用
研究
開始
自動
運転
活用
IT
要員
増加
傾向
IT
部門
魅力
的
4
分の
3
回答
怒り
Oracle
ユーザー
私
プレミアム
フライデー
反対
理由
Windows
10
Creators
Update
何
の
デジタル
ビジネス
創出
IT
部門
事業
部門
連携
成功
鍵
特設
サイト
関連
サイト
関連
誌
トップ
IT
経営
本物
プログラマ
Haskell
筆者
shelarcy
Haskell
関数
型
プログラミング
ジャンル
言語
Haskell
関数
型
プログラミング
題材
物事
こと
今
思い
よう
未知
世界
こと
プログラミング
言語
行為
3
段階
連載
三つ
目
段階
目標
Haskell
プログラミング
世界
一つひとつ
丁寧
紹介
更新
毎月
1
水曜日
1
月
2
水曜日
58
回
C
配列
Haskell
利用
57
回
機能
テスト
性能
テスト
Cabal
自動
化
56
回
Cabal
パッケージ
作成
55
回
repa
ステンシル
54
回
repa
行列
演算
定義
53
回
repa
行列
演算
並列
化
52
回
データ
構造
走査
ため
Traversable
クラス
51
回
Functor
Monad
間
Applicative
50
回
並列
プログラミング
抽象
化
制御
トレードオフ
49
回
GHC
測定
機能
プロファイラ
並列
プログラム
振る舞い
48
回
並列
プログラム
高速
化
ため
原則
47
回
領域
漏れ
プログラム
改良
46
回
ヒープ・プロファイラ
領域
漏れ
45
回
GHC
性能
測定
機能
ボトルネック
44
回
progression
複数
性能
測定
結果
比較
43
回
criterion
プログラム
性能
測定
42
回
ランダム
アクセス
処理
効率
化
Recycling
41
回
任意
再帰
構造
処理
融合
変換
Stream
Fusion
40
回
Stream
Fusion
融合
変換
処理
系
最適
化
機能
39
回
一般
向け
Haskell
Platform
インストール
ツール
cabal
コマンド
38
回
書き換え
規則
強力
サポート
段階
制御
37
回
書き換え
規則
不要
計算
中間
データ
除去
36
回
Int
型
キー
特
化
IntMap
型
35
回
キー
値
参照
Map
型
34
回
様々
データ
構造
fold
よう
Foldable
クラス
33
回
木
構造
Seq
型
効率
操作
32
回
効率
的
キュー
表現
Seq
型
31
回
禁断
機能
unsafePerformIO
深淵
30
回
状態
複数
モナド
合成
RWS
モナド
29
回
グローバル
変数
代わり
Reader
モナド
Writer
モナド
28
回
例外
エラー
処理
能力
エラー・モナド
27
回
外部
環境
エラー
Haskell
間
整合
性
26
回
例外
中断
終了
処理
側面
25
回
Haskell
流
例外
処理
24
回
マルチスレッド
環境
下
FFI
利用
23
回
外部
環境
メモリー
Haskell
間
整合
性
22
回
FFI
他
言語
関数
21
回
更新
操作
一般
化
ため
ST
モナド
20
回
更新
高速
化
ため
ST
モナド
19
回
配列
データ
アクセス
効率
18
回
QuickCheck
こと
こと
17
回
QuickCheck
データ
駆動
型
テスト
16
回
Haskell
テスト
自動
化
15
回
Haskell
デバッグ
コツ
14
回
Haskell
メッセージ
通信
利点
13
回
スレッド
安全
I
/
O
排他
制御
実現
12
回
Haskell
並列
プログラミング
3
並行
プログラミング
並列
処理
11
回
Haskell
並列
プログラミング
2
並列
化
手法
10
回
Haskell
並列
プログラミング
1
9
回
Haskell
の
8
回
遅延
評価
仕組み
7
回
入出力
遅延
評価
間
IO
モナド
6
回
局所
的
状態
利用
ため
State
モナド
5
回
List
Maybe
意義
4
回
取り出し
可能
値
List
モナド
3
回
map
モナド
理解
2
回
相性
ポリモーフィズム
理解
1
回
関数
型
プログラミング
世界
連載
目次
グーグル
日本
法人
2017
年
6
月
14
～
15
日
Google
クラ
ウド
サービス
テーマ
イベント
開催
来日
米
Google
Google
Cloud
シニア
バイス
プレジデント
ダイアン
グリーン
氏
日本
市場
向け
ビジネス
好調
推移
こと
説明
NTT
ドコモ
au
注目
スマート
フォン
製品
発売
サムスン
電子
Galaxy
S
8
Galaxy
S
8
ハイエンド
機種
ため
性能
さ
気
最大
見どころ
全面
ディスプレイ
デザイン
ランキング
一覧
パソコン
版
スマホ
版
VR
限界
突破
遠隔
監視
進化
顧客
ヤンマー
IoT
BI
クラ
ウド
導入
失敗
ため
AWS
Azure
導入
先端
技術
情報
提供
クラ
ウド
最適
企業
ネット
通信
大手
各社
MVNO
霞が関
動向
核心
通信
市場
次
ニューズ
レター
通信
放送
ビジネス
最前線
"
""
"
届け
専門
ニューズ
レター
マンガ
TCP
/
IP
要件
漏れ
旬
サーバー
作り方
10
選
Excel
VBA
完全
マスター
鉄則
ワザ
大全
便利
快適
フリー
ソフト
全集
Copyright
©
1995
-
2017
Nikkei
Business
Publications
Inc
.
All
rights
reserved
.
ページ
掲載
記事
写真
図表
無断
転載
著作
権
日経
BP
社
情報
提供
者
帰属
掲載
情報
記事
執筆
時点
もの
本物
プログラマ
Haskell
-
本物
プログラマ
Haskell
ITpro**************************************Haskell
これ
の
Haskell
誤解
Haskell
言語
書き方
Haskell
人生
他
言語
Haskell
1
.
Haskell
関数
型
言語
の
2
.
Haskell
手続き
型
3
.
Haskell
手続き
型
書き方
僕
Qiita
投稿
記事
方
メール
プログラミング
言語
Haskell
勉強
そう
気持ち
非常
H
本
出版
勉強
世辞
Haskell
環境
僕
Haskell
製品
開発
会社
保守
運用
自分
自身
Haskell
プログラム
Haskell
普及
Haskell
入門
記事
こと
これら
経験
機会
Haskell
Haskell
方
入り口
内容
目的
専門
用語
厳密
言葉
定義
記事
Haskell
他
言語
Haskell
多く
後者
末尾
他
言語
Haskell
参照
ググ
いくら
情報
手
みずから
一
歩
Haskell
方
Haskell
時間
投資
価値
ん
自信
ため
内容
僕
メール
関数
型
言語
手続き
型
比較
もの
もの
質問
多く
Haskell
初学
者
つま
誤解
誤解
がち
Haskell
真実
次
とおり
3
事実
考察
Haskell
関数
型
言語
特徴
前面
紹介
あなた
関数
型
言語
勉強
ため
Haskell
世の中
関数
型
キャッチー
言葉
利用
誤り
だらけ
本
出版
方
1
Haskell
魅力
的
の
それ
関数
型
言語
点
パーツ
Lisp
言語
関数
型
Lisp
Haskell
魅力
Lisp
あなた
話
お伝え
猫
ちゃん
大好き
人間
猫
ちゃん
食肉
目
ところ
魅力
の
食肉
目
ワン
ちゃん
別
魅力
たくさん
はず
僕
鯨
偶蹄
目
ヤギ
さん
好き
ヤギ
さん
お家
Haskell
関数
型
性質
の
確か
それ
の
苦労
方
こと
事実
関数
型
こと
Haskell
魅
特徴
中
1
の
後回し
の
Haskell
入門
内容
それ
Haskell
手続き
型
スタイル
記述
こと
オブジェクト
指向
@
fumieval
さん
多く
知見
発表
なん
工夫
Forth
みたい
スタック
指向
プログラミング
ん
関数
型
部分
の
後回し
の
の
あなた
普段
言語
関数
型
スタイル
挑戦
僕
関数
型
言語
側面
後回し
Haskell
学習
教材
作成
ん
だれ
僕
それ
ご飯
よう
ここ
手続き
型
スタイル
Haskell
プログラミング
世界
アプリケーション
開発
こと
サンプル
プログラム
これ
Haskell
全体
的
手続き
型
文法
理解
必要
雰囲気
変
すべて
関数
型
スタイル
記述
命令
順番
ほう
プログラム
急
仕様
変更
等
柔軟
対応
中
関数
型
の
map
filter
よう
関数
これら
関数
JavaScript
あなた
普段
言語
はず
Haskell
誤解
ところ
Haskell
こと
メリット
Haskell
こと
Haskell
以外
プログラミング
言語
書き方
改善
Haskell
こと
制限
言語
デメリット
よう
パターン
実装
言語
書き方
強要
言語
Haskell
人
テスト
プログラム
よう
2
ここ
説明
純粋
関数
純粋
関数
明確
区別
言語
特性
他
恩恵
可読性
プログラム
よう
こちら
純粋
関数
内
変数
値
代入
こと
ドキュメント
役割
型
表記
柔軟
抽象
化
機能
おかげ
それ
以外
実行
速度
メモリ
使用
量
意識
プログラム
よう
方向
リスト
さまざま
データ
構造
ライブラリ
ドキュメント
自分
柔軟
データ
型
作成
中
計算
量
場面
これら
本来
他
言語
あなた
普段
言語
内容
逆
あなた
普段
言語
Haskell
つま
こと
はず
Haskell
の
それ
普段
言語
苦労
こと
Haskell
代わり
の
Haskell
こと
プログラミング
以外
あなた
人生
豊か
Haskell
重要
特性
1
抽象
化
抽象
化
プログラム
可読性
保守
性
向上
事象
間
共通
部分
能力
抽象
化
力
ここ
抽象
化
力
プログラミング
以外
世界
Haskell
応用
の
プログラミング
考え方
経験
今
こと
物事
習得
仕方
こと
僕
会社
保守
運用
方法
際
Haskell
世の中
プログラマ
必要
職
こと
今
自分
こと
自分
力
努力
よう
体験
口先
何
ウンコ
みたい
意識
系
クズ
人間
力
身
ウンコ
人間
コンパイラ
何
度
お前
これ
何
型
ん
経験
日頃
コミュニケーション
相手
理解
よう
適切
自分
意図
内容
こと
よう
これ
異性
モテモテ
あなた
幸せ
Haskell
宗教
法人
Haskell
光
現実
存在
記事
Haskell
誤解
ところ
次
ステップ
以下
記事
Haskell
他
言語
場合
優位
いつ
Haskell
特徴
説明
記事
の
口先
何
ウンコ
みたい
意識
系
クズ
大差
お気
関数
型
お父さん
お母さん
↩
Haskell
限り
他
言語
テスト
こと
重要
↩
投稿
よう
問題
意見
返信
返信
必要
内容
こちら
問い合わせ
Haskell
-
Qiita**************************************ページ
404
:
Not
Found
ページ
一時
的
アクセス
状況
移動
削除
可能
性
URL
ファイル
名
タイプ
ミス
確認
意見
返信
返信
必要
内容
こちら
問い合わせ
ページ
(
404
:
Not
Found
)
-
Qiita**************************************栃木
県
日光
国立
公園
那須高原
那須
温泉
那須高原
宿
山水
閣
･
別邸
回
那須
温泉
山水
閣
別邸
回**************************************What
I
Wish
I
Knew
When
Learning
Haskell
Basics
Monads
Monad
Transformers
Language
Extensions
Type
Classes
Laziness
Prelude
Strings
Applicatives
Error
Handling
Advanced
Monads
Quantification
GADTs
Interpreters
Testing
Type
Families
Promotion
Generics
Mathematics
Data
Structures
FFI
Concurrency
Graphics
Parsing
Streaming
Cryptography
Compression
Data
Formats
Network
&
amp
;
Web
Programming
Databases
GHC
Profiling
Languages
Template
Haskell
Categories
Other
Languages
Code
Cabal
Stack
Flags
Hackage
GHCi
Editor
Integration
Bottoms
Exhaustiveness
Debugger
Stack
Traces
Trace
Type
Holes
Deferred
Type
Errors
ghcid
Haddock
Eightfold
Path
to
Monad
Satori
Monadic
Myths
Monadic
Methods
Laws
Do
Notation
Maybe
List
IO
What
'
s
the
point
?
Reader
Monad
Writer
Monad
State
Monad
Monad
Tutorials
mtl
/
transformers
Transformers
Basics
ReaderT
Newtype
Deriving
Efficiency
Monad
Morphisms
The
Benign
The
Dangerous
Type
Inference
Monomorphism
Restriction
Extended
Defaulting
Safe
Haskell
Partial
Type
Signatures
Recursive
Do
Applicative
Do
Pattern
Guards
ViewPatterns
TupleSections
MultiWayIf
EmptyCase
LambdaCase
NumDecimals
PackageImports
RecordWildCards
NamedFieldPuns
PatternSynonyms
DeriveTraversable
DeriveFoldable
DeriveFunctor
DeriveGeneric
DeriveAnyClass
StaticPointers
DuplicateRecordFields
OverloadedLabels
Cpp
Historical
Extensions
Minimal
Annotations
FlexibleInstances
FlexibleContexts
OverlappingInstances
IncoherentInstances
TypeSynonymInstances
Strictness
Seq
and
WHNF
Strictness
Annotations
Strict
Haskell
Deepseq
Irrefutable
Patterns
What
to
Avoid
?
What
Should
be
in
Base
Custom
Preludes
Protolude
Partial
Functions
Safe
Boolean
Blindness
Foldable
/
Traversable
Corecursion
split
monad
-
loops
Foundation
String
Import
Conventions
Text
Text
.
Builder
ByteString
utf
8
-
string
base
64
-
bytestring
Printf
Overloaded
Lists
String
Conversions
Alternative
Arrows
Bifunctors
Polyvariadic
Functions
Control
.
Exception
Exceptions
ExceptT
spoon
safe
-
exceptions
Function
Monad
RWS
Monad
Cont
MonadPlus
MonadFix
ST
Monad
Free
Monads
Indexed
Monads
lifted
-
base
Universal
Quantification
Free
theorems
Type
Systems
Rank
-
N
Types
Existential
Quantification
Impredicative
Types
Scoped
Type
Variables
GADTs
Kind
Signatures
Void
Phantom
Types
Typelevel
Operations
HOAS
PHOAS
Final
Interpreters
Finally
Tagless
Datatypes
F
-
Algebras
recursion
-
schemes
Data
types
Ã
la
carte
Hint
and
Mueval
QuickCheck
SmallCheck
QuickSpec
Criterion
Tasty
silently
MultiParam
Typeclasses
Type
Families
Injectivity
Roles
Monotraversable
NonEmpty
Overloaded
Lists
Manual
Proofs
Constraint
Kinds
TypeFamilyDependencies
Higher
Kinded
Types
Kind
Polymorphism
Data
Kinds
Size
-
Indexed
Vectors
Typelevel
Numbers
Typelevel
Strings
Custom
Errors
Type
Equality
Proxies
Promoted
Syntax
Singleton
Types
Closed
Type
Families
Kind
Indexed
Type
Families
Promoted
Symbols
HLists
Typelevel
Dictionaries
Advanced
Proofs
Liquid
Haskell
Typeable
Dynamic
Data
Syb
Generic
Generic
Deriving
generics
-
sop
Uniplate
Numeric
Tower
Integer
Complex
Scientific
Statistics
Constructive
Reals
SAT
Solvers
SMT
Solvers
Z
3
Map
Tree
Set
Vector
Mutable
Vectors
Unordered
-
Containers
Hashtables
Graphs
Graph
Theory
DList
Sequence
Pure
Functions
Storable
Arrays
Function
Pointers
Sparks
Threadscope
Strategies
STM
Monad
Par
async
Diagrams
Parsec
Custom
Lexer
Simple
Parsing
Generic
Parsing
Attoparsec
Optparse
Applicative
Happy
&
amp
;
Alex
Configurator
Lazy
IO
Pipes
Safe
Pipes
Conduits
cryptonite
entropy
memory
crypto
-
pubkey
crypto
-
api
x
509
ed
25519
lz
4
zlib
JSON
Yaml
CSV
HTTP
Blaze
Warp
Scotty
Servant
Hastache
Postgres
Redis
Acid
State
Block
Diagram
Core
Inliner
Dictionaries
Specialization
Static
Compilation
Unboxed
Types
IO
/
ST
ghc
-
heap
-
view
STG
Worker
/
Wrapper
Z
-
Encoding
Cmm
Optimization
Hacks
Interface
Files
EKG
RTS
Profiling
unbound
unbound
-
generics
llvm
-
general
pretty
wl
-
pprint
-
text
pretty
-
show
Haskeline
Repline
Perils
of
Metaprogramming
Quasiquotation
language
-
c
-
quote
Template
Haskell
Antiquotation
Templated
Type
Families
Templated
Type
Classes
Multiline
Strings
git
-
embed
Algebraic
Relations
Categories
Isomorphisms
Duality
Functors
Natural
Transformations
Adjunctions
Yoneda
Lemma
Kleisli
Category
Resources
Haskell
OCaml
Standard
ML
Agda
Coq
Idris
Rust
Purescript
Elm
Python
R
Julia
Erlang
Elixer
Java
Clojure
Swift
Scheme
Racket
C
#
F
#
C
++
Go
Scala
Javascript
Kotlin
PHP
Perl
Lua
Version
2
.
3
%
Stephen
Diehl
%
March
2016
Stephen
Diehl
(
@
smdiehl
)
This
is
the
fourth
draft
of
this
document
.
PDF
Version
This
code
and
text
are
dedicated
to
the
public
domain
.
You
can
copy
modify
distribute
and
perform
the
work
even
for
commercial
purposes
all
without
asking
permission
.
You
may
copy
and
paste
any
code
here
verbatim
into
your
codebase
wiki
blog
book
or
Haskell
musical
production
as
you
see
fit
.
The
Markdown
and
Haskell
source
is
available
on
Github
.
Pull
requests
are
always
accepted
for
changes
and
additional
content
.
This
is
a
living
document
.
2
.
4
2
.
3
2
.
2
Sections
that
have
had
been
added
or
seen
large
changes
:
Historically
Cabal
had
a
component
known
as
cabal
-
install
that
has
largely
been
replaced
by
Stack
.
The
following
use
of
Cabal
sandboxes
is
left
for
historical
reasons
and
can
often
be
replaced
by
modern
tools
.
Cabal
is
the
build
system
for
Haskell
.
For
example
to
install
the
parsec
package
to
your
system
from
Hackage
the
upstream
source
of
Haskell
packages
invoke
the
install
command
:
The
usual
build
invocation
for
Haskell
packages
is
the
following
:
To
update
the
package
index
from
Hackage
run
:
To
start
a
new
Haskell
project
run
:
A
.
cabal
file
will
be
created
with
the
configuration
options
for
our
new
project
.
The
latest
feature
of
cabal
is
the
addition
of
Sandboxes
(
in
cabal
&
gt
;
1
.
18
)
which
are
self
contained
environments
of
Haskell
packages
separate
from
the
global
package
index
stored
in
the
./.
cabal
-
sandbox
of
our
project
'
s
root
.
To
create
a
new
sandbox
for
our
cabal
project
run
:
Additionally
the
sandbox
can
be
torn
down
:
When
in
the
working
directory
of
a
project
with
a
sandbox
that
has
a
configuration
already
set
up
invoking
cabal
commands
alters
the
behaviour
of
cabal
itself
.
For
instance
the
cabal
install
command
will
alter
only
the
install
to
the
local
package
index
not
the
global
configuration
.
To
install
the
dependencies
from
the
.
cabal
file
into
the
newly
created
sandbox
run
:
Dependencies
can
also
be
built
in
parallel
by
passing
-
j
&
lt
;
n
&
gt
;
where
n
is
the
number
of
concurrent
builds
.
Let
'
s
look
at
an
example
.
cabal
file
.
There
are
two
main
entry
points
that
any
package
may
provide
:
a
library
and
an
executable
.
Multiple
executables
can
be
defined
but
only
one
library
.
In
addition
there
is
a
special
form
of
executable
entry
point
Test
-
Suite
which
defines
an
interface
for
invoking
unit
tests
from
cabal
.
For
a
library
the
exposed
-
modules
field
in
the
.
cabal
file
indicates
which
modules
within
the
package
structure
will
be
publicly
visible
when
the
package
is
installed
.
These
modules
are
the
user
-
facing
APIs
that
we
wish
to
expose
to
downstream
consumers
.
For
an
executable
the
main
-
is
field
indicates
the
module
that
exports
the
main
function
running
the
executable
logic
of
the
application
.
Every
module
in
the
package
must
be
listed
in
one
of
other
-
modules
exposed
-
modules
or
main
-
is
fields
.
To
run
an
"
executable
"
for
a
project
under
the
cabal
sandbox
:
To
load
the
"
library
"
into
a
GHCi
shell
under
cabal
sandbox
:
The
&
lt
;
name
&
gt
;
metavariable
is
either
one
of
the
executable
or
library
declarations
in
the
.
cabal
file
and
can
optionally
be
disambiguated
by
the
prefix
exe
:&
lt
;
name
&
gt
;
or
lib
:&
lt
;
name
&
gt
;
respectively
.
To
build
the
package
locally
into
the
./
dist
/
build
folder
execute
the
build
command
:
To
run
the
tests
our
package
must
itself
be
reconfigured
with
the
--
enable
-
tests
and
the
build
-
depends
options
.
The
Test
-
Suite
must
be
installed
manually
if
not
already
present
.
Moreover
arbitrary
shell
commands
can
be
invoked
with
the
GHC
environmental
variables
set
up
for
the
sandbox
.
Quite
common
is
to
invoke
a
new
shell
with
this
command
such
that
the
ghc
and
ghci
commands
use
the
sandbox
.
(
They
don
'
t
by
default
which
is
a
common
source
of
frustration
.
).
The
haddock
documentation
can
be
generated
for
the
local
project
by
executing
the
haddock
command
.
The
documentation
will
be
built
to
the
./
dist
folder
.
When
we
'
re
finally
ready
to
upload
to
Hackage
(
presuming
we
have
a
Hackage
account
set
up
then
we
can
build
the
tarball
and
upload
with
the
following
commands
:
Sometimes
you
'
d
also
like
to
add
a
library
from
a
local
project
into
a
sandbox
.
In
this
case
run
the
add
-
source
command
to
bring
the
library
into
the
sandbox
from
a
local
directory
:
The
current
state
of
a
sandbox
can
be
frozen
with
all
current
package
constraints
enumerated
:
This
will
create
a
file
cabal
.
config
with
the
constraint
set
.
Using
the
cabal
repl
and
cabal
run
commands
is
preferable
but
sometimes
we
'
d
like
to
manually
perform
their
equivalents
at
the
shell
.
Several
useful
aliases
rely
on
shell
directory
expansion
to
find
the
package
database
in
the
current
working
directory
and
launch
GHC
with
the
appropriate
flags
:
There
is
also
a
zsh
script
to
show
the
sandbox
status
of
the
current
working
directory
in
our
shell
:
The
cabal
configuration
is
stored
in
$
HOME
/.
cabal
/
config
and
contains
various
options
including
credential
information
for
Hackage
upload
.
One
addition
to
configuration
is
to
completely
disallow
the
installation
of
packages
outside
of
sandboxes
to
prevent
accidental
collisions
.
A
library
can
also
be
compiled
with
runtime
profiling
information
enabled
.
More
on
this
is
discussed
in
the
section
on
Concurrency
and
Profiling
.
Another
common
flag
to
enable
is
documentation
which
forces
the
local
build
of
Haddock
documentation
which
can
be
useful
for
offline
reference
.
On
a
Linux
filesystem
these
are
built
to
the
/
usr
/
share
/
doc
/
ghc
-
doc
/
html
/
libraries
/
directory
.
If
GHC
is
currently
installed
the
documentation
for
the
Prelude
and
Base
libraries
should
be
available
at
this
local
link
:
/
usr
/
share
/
doc
/
ghc
-
doc
/
html
/
libraries
/
index
.
html
See
:
Stack
is
a
new
approach
to
Haskell
package
structure
that
emerged
in
2015
.
Instead
of
using
a
rolling
build
like
cabal
-
install
stack
breaks
up
sets
of
packages
into
release
blocks
that
guarantee
internal
compatibility
between
sets
of
packages
.
The
package
solver
for
stack
uses
a
different
more
robust
strategy
for
resolving
dependencies
than
cabal
-
install
has
historically
used
.
Contrary
to
much
misinformation
Stack
does
not
replace
Cabal
as
the
build
system
and
uses
it
under
the
hood
.
Stack
simply
streamlines
integration
with
third
-
party
packages
and
the
resolution
of
their
dependencies
.
To
install
stack
on
Ubuntu
Linux
run
:
For
other
operating
systems
see
the
official
install
directions
.
Once
stack
is
installed
it
is
possible
to
setup
a
build
environment
on
top
of
your
existing
project
'
s
cabal
file
by
running
:
An
example
stack
.
yaml
file
for
GHC
7
.
10
.
3
would
look
like
:
Most
of
the
common
libraries
used
in
everyday
development
are
already
in
the
Stackage
repository
.
The
extra
-
deps
field
can
be
used
to
add
Hackage
dependencies
that
are
not
in
the
Stackage
repository
.
They
are
specified
by
the
package
and
the
version
key
.
For
instance
the
zenc
package
could
be
added
to
the
stack
build
:
The
stack
command
can
be
used
to
install
packages
and
executables
into
either
the
current
build
environment
or
the
global
environment
.
For
example
the
following
command
installs
the
executable
for
hlint
a
popular
linting
tool
for
Haskell
and
places
it
in
the
PATH
:
To
check
the
set
of
dependencies
run
:
Just
as
with
cabal
the
build
and
debug
process
can
be
orchestrated
using
stack
commands
:
To
visualize
the
dependency
graph
use
the
dot
command
piped
first
into
graphviz
then
piped
again
into
your
favorite
image
viewer
:
Enabling
GHC
compiler
flags
grants
the
user
more
control
in
detecting
common
code
errors
.
The
most
frequently
used
flags
are
:
Like
most
compilers
GHC
takes
the
-
Wall
flag
to
enable
all
warnings
.
However
a
few
of
the
enabled
warnings
are
highly
verbose
.
For
example
-
fwarn
-
unused
-
do
-
bind
and
-
fwarn
-
unused
-
matches
typically
would
not
correspond
to
errors
or
failures
.
Any
of
these
flags
can
be
added
to
the
ghc
-
options
section
of
a
project
'
s
.
cabal
file
.
For
example
:
The
flags
described
above
are
simply
the
most
useful
.
See
the
official
reference
for
the
complete
set
of
GHC
'
s
supported
flags
.
For
information
on
debugging
GHC
internals
see
the
commentary
on
GHC
internals
.
Hackage
is
the
upstream
source
of
Free
and
/
or
Open
Source
Haskell
packages
.
With
Haskell
'
s
continuing
evolution
Hackage
has
become
many
things
to
developers
but
there
seem
to
be
two
dominant
philosophies
of
uploaded
libraries
.
Reusable
Code
/
Building
Blocks
In
the
first
philosophy
libraries
exist
as
reliable
community
-
supported
building
blocks
for
constructing
higher
level
functionality
on
top
of
a
common
stable
edifice
.
In
development
communities
where
this
method
is
the
dominant
philosophy
the
author
(
s
)
of
libraries
have
written
them
as
a
means
of
packaging
up
their
understanding
of
a
problem
domain
so
that
others
can
build
on
their
understanding
and
expertise
.
A
Staging
Area
/
Request
for
Comments
In
contrast
to
the
previous
method
of
packaging
a
common
philosophy
in
the
Haskell
community
is
that
Hackage
is
a
place
to
upload
experimental
libraries
as
a
means
of
getting
community
feedback
and
making
the
code
publicly
available
.
Library
author
(
s
)
often
rationalize
putting
these
kind
of
libraries
up
undocumented
often
without
indication
of
what
the
library
actually
does
by
simply
stating
that
they
intend
to
tear
the
code
down
and
rewrite
it
later
.
This
approach
unfortunately
means
a
lot
of
Hackage
namespace
has
become
polluted
with
dead
-
end
bit
-
rotting
code
.
Sometimes
packages
are
also
uploaded
purely
for
internal
use
within
an
organisation
to
accompany
a
paper
or
just
to
integrate
with
the
cabal
build
system
.
These
packages
are
often
left
undocumented
as
well
.
For
developers
coming
to
Haskell
from
other
language
ecosystems
that
favor
the
former
philsophy
(
e
.
g
Python
Javascript
Ruby
seeing
thousands
of
libraries
without
the
slightest
hint
of
documentation
or
description
of
purpose
can
be
unnerving
.
It
is
an
open
question
whether
the
current
cultural
state
of
Hackage
is
sustainable
in
light
of
these
philsophical
differences
.
Needless
to
say
there
is
a
lot
of
very
low
-
quality
Haskell
code
and
documentation
out
there
today
so
being
conservative
in
library
assessment
is
a
necessary
skill
.
That
said
there
are
also
quite
a
few
phenomenal
libraries
on
Hackage
that
are
highly
curated
by
many
people
.
As
a
general
rule
if
the
Haddock
documentation
for
the
library
does
not
have
a
minimal
worked
example
it
is
usually
safe
to
assume
that
it
is
an
RFC
-
style
library
and
probably
should
be
avoided
in
production
-
grade
code
.
Similarly
if
the
library
predates
the
text
library
(
released
circa
2007
it
probably
should
be
avoided
in
production
code
.
The
way
we
write
Haskell
has
changed
drastically
since
the
early
days
.
GHCi
is
the
interactive
shell
for
the
GHC
compiler
.
GHCi
is
where
we
will
spend
most
of
our
time
in
every
day
development
.
The
introspection
commands
are
an
essential
part
of
debugging
and
interacting
with
Haskell
code
:
Querying
the
current
state
of
the
global
environment
in
the
shell
is
also
possible
.
For
example
to
view
module
-
level
bindings
and
types
in
GHCi
run
:
Examining
module
-
level
imports
execute
:
To
see
compiler
-
level
flags
and
pragmas
use
:
Language
extensions
and
compiler
pragmas
can
be
set
at
the
prompt
.
See
the
Flag
Reference
for
the
vast
collection
of
compiler
flag
options
.
Several
commands
for
the
interactive
shell
have
shortcuts
:
The
configuration
for
the
GHCi
shell
can
be
customized
globally
by
defining
a
ghci
.
conf
in
$
HOME
/.
ghc
/
or
in
the
current
working
directory
as
./.
ghci
.
conf
.
For
example
we
can
add
a
command
to
use
the
Hoogle
type
search
from
within
GHCi
.
First
install
hoogle
:
Then
we
can
enable
the
search
functionality
by
adding
a
command
to
our
ghci
.
conf
:
For
reasons
of
sexiness
it
is
desirable
to
set
your
GHC
prompt
to
a
Î
»
or
a
Î
»
Î
.
Only
if
you
'
re
into
that
lifestyle
though
.
For
large
projects
GHCi
with
the
default
flags
can
use
quite
a
bit
of
memory
and
take
a
long
time
to
compile
.
To
speed
compilation
by
keeping
artificats
for
compiled
modules
around
we
can
enable
object
code
compilation
instead
of
bytecode
.
Enabling
object
code
compliation
may
complicate
type
inference
since
type
information
provided
to
the
shell
can
sometimes
be
less
informative
than
source
-
loaded
code
.
This
under
specificity
can
result
in
breakage
with
some
langauge
extensions
.
In
that
case
you
can
temporarily
reenable
bytecode
compilation
on
a
per
module
basis
with
the
-
fbyte
-
code
flag
.
If
you
all
you
need
is
to
typecheck
your
code
in
the
interactive
shell
then
disabling
code
generation
entirely
makes
reloading
code
almost
instantaneous
:
Haskell
has
a
variety
of
editor
tools
that
can
be
used
to
provide
interactive
development
feedback
and
functionality
such
as
querying
types
of
subexpressions
linting
type
checking
and
code
completion
.
Several
prepackaged
setups
exist
to
expedite
the
process
of
setting
up
many
of
the
programmer
editors
for
Haskell
development
.
In
particular
using
ghc
-
mod
can
remarkably
improve
programmer
efficiency
and
productivity
because
the
project
attempts
to
implement
features
common
to
modern
IDEs
.
Vim
Emacs
Atom
The
bottom
is
a
singular
value
that
inhabits
every
type
.
When
this
value
is
evaluated
the
semantics
of
Haskell
no
longer
yield
a
meaningful
value
.
In
other
words
further
operations
on
the
value
cannot
be
defined
in
Haskell
.
A
bottom
value
is
usually
written
as
the
symbol
â
¥
(
i
.
e
.
the
compiler
flipping
you
off
).
Several
ways
exist
to
express
bottoms
in
Haskell
code
.
For
instance
undefined
is
an
easily
called
example
of
a
bottom
value
.
This
function
has
type
a
but
lacks
any
type
constraints
in
its
type
signature
.
Thus
undefined
is
able
to
stand
in
for
any
type
in
a
function
body
allowing
type
checking
to
succeed
even
if
the
function
is
incomplete
or
lacking
a
definition
entirely
.
The
undefined
function
is
extremely
practical
for
debugging
or
to
accommodate
writing
incomplete
programs
.
Another
example
of
a
bottom
value
comes
from
the
evaluation
of
the
error
function
which
takes
a
String
and
returns
something
that
can
be
of
any
type
.
This
property
is
quite
similar
to
undefined
which
also
can
also
stand
in
for
any
type
.
Calling
error
in
a
function
causes
the
compiler
to
throw
an
exception
halt
the
program
and
print
the
specified
error
message
.
In
the
divByY
function
below
passing
the
function
0
as
the
divisor
results
in
this
function
results
in
such
an
exception
.
A
third
type
way
to
express
a
bottom
is
with
an
infinitely
looping
term
:
Examples
of
actual
Haskell
code
that
use
this
looping
syntax
live
in
the
source
code
of
the
GHC
.
Prim
module
.
These
bottoms
exist
because
the
operations
cannot
be
defined
in
native
Haskell
.
Such
operations
are
baked
into
the
compiler
at
a
very
low
level
.
However
this
module
exists
so
that
Haddock
can
generate
documentation
for
these
primitive
operations
while
the
looping
syntax
serves
as
a
placeholder
for
the
actual
implementation
of
the
primops
.
Perhaps
the
most
common
introduction
to
bottoms
is
writing
a
partial
function
that
does
not
have
exhaustive
pattern
matching
defined
.
For
example
the
following
code
has
non
-
exhaustive
pattern
matching
because
the
case
expression
lacks
a
definition
of
what
to
do
with
a
B
:
The
code
snippet
above
is
translated
into
the
following
GHC
Core
output
.
The
compiler
inserts
an
exception
to
account
for
the
non
-
exhaustive
patterns
:
GHC
can
be
made
more
vocal
about
incomplete
patterns
using
the
-
fwarn
-
incomplete
-
patterns
and
-
fwarn
-
incomplete
-
uni
-
patterns
flags
.
A
similar
situation
can
arise
with
records
.
Although
constructing
a
record
with
missing
fields
is
rarely
useful
it
is
still
possible
.
When
the
developer
omits
a
field
'
s
definition
the
compiler
inserts
an
exception
in
the
GHC
Core
representation
:
Fortunately
GHC
will
warn
us
by
default
about
missing
record
fields
.
Bottoms
are
used
extensively
throughout
the
Prelude
although
this
fact
may
not
be
immediately
apparent
.
The
reasons
for
including
bottoms
are
either
practical
or
historical
.
The
canonical
example
is
the
head
function
which
has
type
[
a
]
-&
gt
;
a
.
This
function
could
not
be
well
-
typed
without
the
bottom
.
It
is
rare
to
see
these
partial
functions
thrown
around
carelessly
in
production
code
because
they
cause
the
program
to
halt
.
The
preferred
method
for
handling
exceptions
is
to
combine
the
use
of
safe
variants
provided
in
Data
.
Maybe
with
the
usual
fold
functions
maybe
and
either
.
Another
method
is
to
use
pattern
matching
as
shown
in
listToMaybe
a
safer
version
of
head
described
below
:
Invoking
a
bottom
defined
in
terms
of
error
typically
will
not
generate
any
position
information
.
However
assert
which
is
used
to
provide
assertions
can
be
short
-
circuited
to
generate
position
information
in
the
place
of
either
undefined
or
error
calls
.
See
:
Avoiding
Partial
Functions
Pattern
matching
in
Haskell
allows
for
the
possibility
of
non
-
exhaustive
patterns
.
For
example
passing
Nothing
to
unsafe
will
cause
the
program
to
crash
at
runtime
.
However
this
function
is
an
otherwise
valid
type
-
checked
program
.
Since
unsafe
takes
a
Maybe
a
value
as
its
argument
two
possible
values
are
valid
input
:
Nothing
and
Just
a
.
Since
the
case
of
a
Nothing
was
not
defined
in
unsafe
we
say
that
the
pattern
matching
within
that
function
is
non
-
exhaustive
.
In
other
words
the
function
does
not
implement
appropriate
handling
of
all
valid
inputs
.
Instead
of
yielding
a
value
such
a
function
will
halt
from
an
incomplete
match
.
Partial
functions
from
non
-
exhaustivity
are
a
controversial
subject
and
frequent
use
of
non
-
exhaustive
patterns
is
considered
a
dangerous
code
smell
.
However
the
complete
removal
of
non
-
exhaustive
patterns
from
the
language
would
itself
be
too
restrictive
and
forbid
too
many
valid
programs
.
Several
flags
exist
that
we
can
pass
to
the
compiler
to
warn
us
about
such
patterns
or
forbid
them
entirely
either
locally
or
globally
.
The
-
Wall
or
-
fwarn
-
incomplete
-
patterns
flag
can
also
be
added
on
a
per
-
module
basis
by
using
the
OPTIONS
_
GHC
pragma
.
A
more
subtle
case
of
non
-
exhaustivity
is
the
use
of
implicit
pattern
matching
with
a
single
uni
-
pattern
in
a
lambda
expression
.
In
a
manner
similar
to
the
unsafe
function
above
a
uni
-
pattern
cannot
handle
all
types
of
valid
input
.
For
instance
the
function
boom
will
fail
when
given
a
Nothing
even
though
the
type
of
the
lambda
expression
'
s
argument
is
a
Maybe
a
.
Non
-
exhaustivity
arising
from
uni
-
patterns
in
lambda
expressions
occurs
frequently
in
let
or
do
-
blocks
after
desugaring
because
such
code
is
translated
into
lambda
expressions
similar
to
boom
.
GHC
can
warn
about
these
cases
of
non
-
exhaustivity
with
the
-
fwarn
-
incomplete
-
uni
-
patterns
flag
.
Grossly
speaking
any
non
-
trivial
program
will
use
some
measure
of
partial
functions
.
It
is
simply
a
fact
.
Thus
there
exist
obligations
for
the
programmer
than
cannot
be
manifest
in
the
Haskell
type
system
.
Since
GHCi
version
6
.
8
.
1
a
built
-
in
debugger
has
been
available
although
its
use
is
somewhat
rare
.
Debugging
uncaught
exceptions
from
bottoms
or
asynchronous
exceptions
is
in
similar
style
to
debugging
segfaults
with
gdb
.
With
runtime
profiling
enabled
GHC
can
also
print
a
stack
trace
when
a
diverging
bottom
term
(
error
undefined
)
is
hit
.
This
action
though
requires
a
special
flag
and
profiling
to
be
enabled
both
of
which
are
disabled
by
default
.
So
for
example
:
And
indeed
the
runtime
tells
us
that
the
exception
occurred
in
the
function
g
and
enumerates
the
call
stack
.
It
is
best
to
run
this
code
without
optimizations
applied
-
O
0
so
as
to
preserve
the
original
call
stack
as
represented
in
the
source
.
With
optimizations
applied
GHC
will
rearrange
the
program
in
rather
drastic
ways
resulting
in
what
may
be
an
entirely
different
call
stack
.
See
:
Since
Haskell
is
a
pure
language
it
has
the
unique
property
that
most
code
is
introspectable
on
its
own
.
As
such
using
printf
to
display
the
state
of
the
program
at
critical
times
throughout
execution
is
often
unnecessary
because
we
can
simply
open
GHCi
and
test
the
function
.
Nevertheless
Haskell
does
come
with
an
unsafe
trace
function
which
can
be
used
to
perform
arbitrary
print
statements
outside
of
the
IO
monad
.
Trace
uses
unsafePerformIO
under
the
hood
and
should
not
be
used
in
stable
code
.
In
addition
to
the
trace
function
several
monadic
trace
variants
are
quite
common
.
Since
the
release
of
GHC
7
.
8
typed
holes
allow
for
debugging
incomplete
programs
.
By
placing
an
underscore
on
any
value
on
the
right
hand
-
side
of
a
declaration
GHC
will
throw
an
error
during
type
-
checking
.
Such
an
error
reflects
what
type
the
value
in
the
position
of
the
type
hole
could
be
in
order
for
the
program
to
type
-
check
successfully
.
GHC
has
rightly
suggested
that
the
expression
needed
to
finish
the
program
is
xs
::
[
a
]
.
Since
the
release
of
version
7
.
8
GHC
supports
the
option
of
treating
type
errors
as
runtime
errors
.
With
this
option
enabled
programs
will
run
but
they
will
fail
when
a
mistyped
expression
is
evaluated
.
This
feature
is
enabled
with
the
-
fdefer
-
type
-
errors
flag
in
three
ways
:
at
the
module
level
when
compiled
from
the
command
line
or
inside
of
a
GHCi
interactive
session
.
For
instance
the
program
below
will
compile
:
However
when
a
pathological
term
is
evaluated
at
runtime
we
'
ll
see
a
message
like
:
This
error
tells
us
that
while
x
has
a
declared
type
of
()
the
body
of
the
function
print
3
has
a
type
of
IO
()
.
However
if
the
term
is
never
evaluated
GHC
will
not
throw
an
exception
.
ghcid
is
a
lightweight
IDE
hook
that
allows
continuous
feedback
whenever
code
is
updated
.
It
can
be
run
from
the
command
line
in
the
root
of
the
cabal
project
directory
by
specifying
a
command
to
run
(
e
.
g
.
ghci
cabal
repl
or
stack
repl
).
When
a
Haskell
module
is
loaded
into
ghcid
the
code
is
evaluated
in
order
to
provide
the
user
with
any
errors
or
warnings
that
would
happen
at
compile
time
.
When
the
developer
edits
and
saves
code
loaded
into
ghcid
the
program
automatically
reloads
and
evaluates
the
code
for
errors
and
warnings
.
Haddock
is
the
automatic
documentation
generation
tool
for
Haskell
source
code
.
It
integrates
with
the
usual
cabal
toolchain
.
In
this
section
we
will
explore
how
to
document
code
so
that
Haddock
can
generate
documentation
successfully
.
Several
frequent
comment
patterns
are
used
to
document
code
for
Haddock
.
The
first
of
these
methods
uses
--
|
to
delineate
the
beginning
of
a
comment
:
Multiline
comments
are
also
possible
:
--
^
is
also
used
to
comment
Constructors
or
Record
fields
:
Elements
within
a
module
(
i
.
e
.
value
types
classes
)
can
be
hyperlinked
by
enclosing
the
identifier
in
single
quotes
:
Modules
themselves
can
be
referenced
by
enclosing
them
in
double
quotes
:
haddock
also
allows
the
user
to
include
blocks
of
code
within
the
generated
documentation
.
Two
methods
of
demarcating
the
code
blocks
exist
in
haddock
.
For
example
enclosing
a
code
snippet
in
@
symbols
marks
it
as
a
code
block
:
Similarly
it
'
s
possible
to
use
bird
tracks
(
&
gt
;
)
in
a
comment
line
to
set
off
a
code
block
.
This
usage
is
very
similar
to
Bird
style
Literate
Haskell
.
Snippets
of
interactive
shell
sessions
can
also
be
included
in
haddock
documentation
.
In
order
to
denote
the
beginning
of
code
intended
to
be
run
in
a
REPL
the
&
gt
;&
gt
;&
gt
;
symbol
is
used
:
Headers
for
specific
blocks
can
be
added
by
prefacing
the
comment
in
the
module
block
with
a
*
:
Sections
can
also
be
delineated
by
$
blocks
that
pertain
to
references
in
the
body
of
the
module
:
Links
can
be
added
with
the
following
syntax
:
Images
can
also
be
included
so
long
as
the
path
is
either
absolute
or
relative
to
the
directory
in
which
haddock
is
run
.
haddock
options
can
also
be
specified
with
pragmas
in
the
source
either
at
the
module
or
project
level
.
Much
ink
has
been
spilled
waxing
lyrical
about
the
supposed
mystique
of
monads
.
Instead
I
suggest
a
path
to
enlightenment
:
In
other
words
the
only
path
to
understanding
monads
is
to
read
the
fine
source
fire
up
GHC
and
write
some
code
.
Analogies
and
metaphors
will
not
lead
to
understanding
.
The
following
are
all
false
:
See
:
What
a
Monad
Is
Not
Monads
are
not
complicated
.
They
are
implemented
as
a
typeclass
with
two
methods
return
and
(&
gt
;&
gt
;=)
(
pronounced
"
bind
").
In
order
to
implement
a
Monad
instance
these
two
functions
must
be
defined
in
accordance
with
the
arity
described
in
the
typeclass
definition
:
The
first
type
signature
in
the
Monad
class
definition
is
for
return
.
Any
preconceptions
one
might
have
for
the
word
"
return
"
should
be
discarded
:
It
has
an
entirely
different
meaning
in
the
context
of
Haskell
and
acts
very
differently
than
in
languages
like
C
Python
or
Java
.
Instead
of
being
the
final
arbiter
of
what
value
a
function
produces
return
in
Haskell
injects
a
value
of
type
a
into
a
monadic
context
(
e
.
g
Maybe
Either
etc
which
is
denoted
as
m
a
.
The
other
function
essential
to
implementing
a
Monad
instance
is
(&
gt
;&
gt
;=)
.
This
infix
takes
two
arguments
.
On
its
left
side
is
a
value
with
type
m
a
while
on
the
right
side
is
a
function
with
type
(
a
-&
gt
;
m
b
)
.
The
bind
operation
results
in
a
final
value
of
type
m
b
.
A
third
auxiliary
function
(
(&
gt
;&
gt
;)
)
is
defined
in
terms
of
the
bind
operation
that
discards
its
argument
.
This
definition
says
that
(&
gt
;&
gt
;)
has
a
left
and
right
argument
which
are
monadic
with
types
m
a
and
m
b
respectively
while
the
infix
returns
a
value
of
type
m
b
.
The
actual
implementation
of
(&
gt
;&
gt
;)
says
that
when
m
is
passed
to
(&
gt
;&
gt
;)
with
k
on
the
right
the
value
k
will
always
be
returned
.
In
addition
to
specific
implementations
of
(&
gt
;&
gt
;=)
and
return
all
monad
instances
must
satisfy
three
laws
.
Law
1
The
first
law
says
that
when
return
a
is
passed
through
a
(&
gt
;&
gt
;=)
into
a
function
f
this
expression
is
exactly
equivalent
to
f
a
.
In
discussing
the
next
two
laws
we
'
ll
refer
to
a
value
m
.
This
notation
is
shorthand
for
value
wrapped
in
a
monadic
context
.
Such
a
value
has
type
m
a
and
could
be
represented
more
concretely
by
values
like
Nothing
Just
x
or
Right
x
.
It
is
important
to
note
that
some
of
these
concrete
instantiations
of
the
value
m
have
multiple
components
.
In
discussing
the
second
and
third
monad
laws
we
'
ll
see
some
examples
of
how
this
plays
out
.
Law
2
The
second
law
states
that
a
monadic
value
m
passed
through
(&
gt
;&
gt
;=)
into
return
is
exactly
equivalent
to
itself
.
In
other
words
using
bind
to
pass
a
monadic
value
to
return
does
not
change
the
initial
value
.
A
more
explicit
way
to
write
the
second
Monad
law
exists
.
In
this
following
example
code
the
first
expression
shows
how
the
second
law
applies
to
values
represented
by
non
-
nullary
type
constructors
.
The
second
snippet
shows
how
a
value
represented
by
a
nullary
type
constructor
works
within
the
context
of
the
second
law
.
Law
3
While
the
first
two
laws
are
relatively
clear
the
third
law
may
be
more
difficult
to
understand
.
This
law
states
that
when
a
monadic
value
m
is
passed
through
(&
gt
;&
gt
;=)
to
the
function
f
and
then
the
result
of
that
expression
is
passed
to
&
gt
;&
gt
;=
g
the
entire
expression
is
exactly
equivalent
to
passing
m
to
a
lambda
expression
that
takes
one
parameter
x
and
outputs
the
function
f
applied
to
x
.
By
the
definition
of
bind
f
x
must
return
a
value
wrapped
in
the
same
Monad
.
Because
of
this
property
the
resultant
value
of
that
expression
can
be
passed
through
(&
gt
;&
gt
;=)
to
the
function
g
which
also
returns
a
monadic
value
.
Again
it
is
possible
to
write
this
law
with
more
explicit
code
.
Like
in
the
explicit
examples
for
law
2
m
has
been
replaced
by
SomeMonad
val
in
order
to
be
very
clear
that
there
can
be
multiple
components
to
a
monadic
value
.
Although
little
has
changed
in
the
code
it
is
easier
to
see
what
value
--
namely
val
--
corresponds
to
the
x
in
the
lambda
expression
.
After
SomeMonad
val
is
passed
through
(&
gt
;&
gt
;=)
to
f
the
function
f
operates
on
val
and
returns
a
result
still
wrapped
in
the
SomeMonad
type
constructor
.
We
can
call
this
new
value
SomeMonad
newVal
.
Since
it
is
still
wrapped
in
the
monadic
context
SomeMonad
newVal
can
thus
be
passed
through
the
bind
operation
into
the
function
g
.
See
:
Monad
Laws
Monadic
syntax
in
Haskell
is
written
in
a
sugared
form
known
as
do
notation
.
The
advantages
of
this
special
syntax
are
that
it
is
easier
to
write
and
is
entirely
equivalent
to
just
applications
of
the
monad
operations
.
The
desugaring
is
defined
recursively
by
the
rules
:
Thus
through
the
application
of
the
desugaring
rules
the
following
expressions
are
equivalent
:
If
one
were
to
write
the
bind
operator
as
an
uncurried
function
(
this
is
not
how
Haskell
uses
it
)
the
same
desugaring
might
look
something
like
the
following
chain
of
nested
binds
with
lambdas
.
In
the
do
-
notation
the
monad
laws
from
above
are
equivalently
written
:
Law
1
Law
2
Law
3
See
:
Haskell
2010
:
Do
Expressions
The
Maybe
monad
is
the
simplest
first
example
of
a
monad
instance
.
The
Maybe
monad
models
computations
which
fail
to
yield
a
value
at
any
point
during
computation
.
The
Maybe
type
has
two
value
constructors
.
The
first
Just
is
a
unary
constructor
representing
a
successful
computation
while
the
second
Nothing
is
a
nullary
constructor
that
represents
failure
.
The
monad
instance
describes
the
implementation
of
(&
gt
;&
gt
;=)
for
Maybe
by
pattern
matching
on
the
possible
inputs
that
could
be
passed
to
the
bind
operation
(
i
.
e
Nothing
or
Just
x
).
The
instance
declaration
also
provides
an
implementation
of
return
which
in
this
case
is
simply
Just
.
The
following
code
shows
some
simple
operations
to
do
within
the
Maybe
monad
.
In
the
first
example
The
value
Just
3
is
passed
via
(&
gt
;&
gt
;=)
to
the
lambda
function
\
x
-&
gt
;
return
(
x
+
1
)
.
x
refers
to
the
Int
portion
of
Just
3
and
we
can
use
x
in
the
second
half
of
the
lambda
expression
where
return
(
x
+
1
)
evaluates
to
Just
4
indicating
a
successful
computation
.
In
the
second
example
the
value
Nothing
is
passed
via
(&
gt
;&
gt
;=)
to
the
same
lambda
function
as
in
the
previous
example
.
However
according
to
the
Maybe
Monad
instance
whenever
Nothing
is
bound
to
a
function
the
expression
'
s
result
will
be
Nothing
.
In
the
next
example
return
is
applied
to
4
and
returns
Just
4
.
The
next
code
examples
show
the
use
of
do
notation
within
the
Maybe
monad
to
do
addition
that
might
fail
.
Desugared
examples
are
provided
as
well
.
The
List
monad
is
the
second
simplest
example
of
a
monad
instance
.
As
always
this
monad
implements
both
(&
gt
;&
gt
;=)
and
return
.
The
definition
of
bind
says
that
when
the
list
m
is
bound
to
a
function
f
the
result
is
a
concatenation
of
map
f
over
the
list
m
.
The
return
method
simply
takes
a
single
value
x
and
injects
into
a
singleton
list
[
x
]
.
In
order
to
demonstrate
the
List
monad
'
s
methods
we
will
define
two
functions
:
m
and
f
.
m
is
a
simple
list
while
f
is
a
function
that
takes
a
single
Int
and
returns
a
two
element
list
[
1
0
]
.
The
evaluation
proceeds
as
follows
:
The
list
comprehension
syntax
in
Haskell
can
be
implemented
in
terms
of
the
list
monad
.
List
comprehensions
can
be
considered
syntactic
sugar
for
more
obviously
monadic
implementations
.
Examples
a
and
b
illustrate
these
use
cases
.
The
first
example
(
a
)
illustrates
how
to
write
a
list
comprehension
.
Although
the
syntax
looks
strange
at
first
there
are
elements
of
it
that
may
look
familiar
.
For
instance
the
use
of
&
lt
;-
is
just
like
bind
in
a
do
notation
:
It
binds
an
element
of
a
list
to
a
name
.
However
one
major
difference
is
apparent
:
a
seems
to
lack
a
call
to
return
.
Not
to
worry
though
the
[]
fills
this
role
.
This
syntax
can
be
easily
desugared
by
the
compiler
to
an
explicit
invocation
of
return
.
Furthermore
it
serves
to
remind
the
user
that
the
computation
takes
place
in
the
List
monad
.
The
second
example
(
b
)
shows
the
list
comprehension
above
rewritten
with
do
notation
:
The
final
examples
are
further
illustrations
of
the
List
monad
.
The
functions
below
each
return
a
list
of
3
-
tuples
which
contain
the
possible
combinations
of
the
three
lists
that
get
bound
the
names
a
b
and
c
.
N
.
B
.:
Only
values
in
the
list
bound
to
a
can
be
used
in
a
position
of
the
tuple
;
the
same
fact
holds
true
for
the
lists
bound
to
b
and
c
.
Perhaps
the
most
(
in
)
famous
example
in
Haskell
of
a
type
that
forms
a
monad
is
IO
.
A
value
of
type
IO
a
is
a
computation
which
when
performed
does
some
I
/
O
before
returning
a
value
of
type
a
.
These
computations
are
called
actions
.
IO
actions
executed
in
main
are
the
means
by
which
a
program
can
operate
on
or
access
information
in
the
external
world
.
IO
actions
allow
the
program
to
do
many
things
including
but
not
limited
to
:
Conceptualizing
I
/
O
as
a
monad
enables
the
developer
to
access
information
outside
the
program
but
operate
on
the
data
with
pure
functions
.
The
following
examples
will
show
how
we
can
use
IO
actions
and
IO
values
to
receive
input
from
stdin
and
print
to
stdout
.
Perhaps
the
most
immediately
useful
function
for
doing
I
/
O
in
Haskell
is
putStrLn
.
This
function
takes
a
String
and
returns
an
IO
()
.
Calling
it
from
main
will
result
in
the
String
being
printed
to
stdout
followed
by
a
newline
character
.
Here
is
some
code
that
prints
a
couple
of
lines
to
the
terminal
.
The
first
invocation
of
putStrLn
is
executed
causing
the
String
to
be
printed
to
stdout
.
The
result
is
bound
to
a
lambda
expression
that
discards
its
argument
and
then
the
next
putStrLn
is
executed
.
Another
useful
function
is
getLine
which
has
type
IO
String
.
This
function
gets
a
line
of
input
from
stdin
.
The
developer
can
then
bind
this
line
to
a
name
in
order
to
operate
on
the
value
within
the
program
.
The
code
below
demonstrates
a
simple
combination
of
these
two
functions
as
well
as
desugaring
IO
code
.
First
putStrLn
prints
a
String
to
stdout
to
ask
the
user
to
supply
their
name
with
the
result
being
bound
to
a
lambda
that
discards
it
argument
.
Then
getLine
is
executed
supplying
a
prompt
to
the
user
for
entering
their
name
.
Next
the
resultant
IO
String
is
bound
to
name
and
passed
to
putStrLn
.
Finally
the
program
prints
the
name
to
the
terminal
.
The
next
code
block
is
the
desugared
equivalent
of
the
previous
example
;
however
the
uses
of
(&
gt
;&
gt
;=)
are
made
explict
.
Our
final
example
executes
in
the
same
way
as
the
previous
two
examples
.
This
example
though
uses
the
special
(&
gt
;&
gt
;)
operator
to
take
the
place
of
binding
a
result
to
the
lamda
that
discards
its
argument
.
See
:
Haskell
2010
:
Basic
/
Input
Output
Although
it
is
difficult
if
not
impossible
to
touch
see
or
otherwise
physically
interact
with
a
monad
this
construct
has
some
very
interesting
implications
for
programmers
.
For
instance
consider
the
non
-
intuitive
fact
that
we
now
have
a
uniform
interface
for
talking
about
three
very
different
but
foundational
ideas
for
programming
:
Failure
Collections
and
Effects
.
Let
'
s
write
down
a
new
function
called
sequence
which
folds
a
function
mcons
over
a
list
of
monadic
computations
.
We
can
think
of
mcons
as
analogous
to
the
list
constructor
(
i
.
e
.
(
a
:
b
:
[])
)
except
it
pulls
the
two
list
elements
out
of
two
monadic
values
(
p
q
)
by
means
of
bind
.
The
bound
values
are
then
joined
with
the
list
constructor
:
before
finally
being
rewrapped
in
the
appropriate
monadic
context
with
return
.
What
does
this
function
mean
in
terms
of
each
of
the
monads
discussed
above
?
Maybe
Sequencing
a
list
of
values
within
the
Maybe
context
allows
us
to
collect
the
results
of
a
series
of
computations
which
can
possibly
fail
.
However
sequence
yields
the
aggregated
values
only
if
each
computation
succeeds
.
In
other
words
if
even
one
of
the
Maybe
values
in
the
initial
list
passed
to
sequence
is
a
Nothing
the
result
of
sequence
will
also
be
Nothing
.
List
The
bind
operation
for
the
list
monad
forms
the
pairwise
list
of
elements
from
the
two
operands
.
Thus
folding
the
binds
contained
in
mcons
over
a
list
of
lists
with
sequence
implements
the
general
Cartesian
product
for
an
arbitrary
number
of
lists
.
IO
Applying
sequence
within
the
IO
context
results
in
still
a
different
result
.
The
function
takes
a
list
of
IO
actions
performs
them
sequentially
and
then
returns
the
list
of
resulting
values
in
the
order
sequenced
.
So
there
we
have
it
three
fundamental
concepts
of
computation
that
are
normally
defined
independently
of
each
other
actually
all
share
this
similar
structure
.
This
unifying
pattern
can
be
abstracted
out
and
reused
to
build
higher
abstractions
that
work
for
all
current
and
future
implementations
.
If
you
want
a
motivating
reason
for
understanding
monads
this
is
it
!
These
insights
are
the
essence
of
what
I
wish
I
knew
about
monads
looking
back
.
See
:
Control
.
Monad
The
reader
monad
lets
us
access
shared
immutable
state
within
a
monadic
context
.
A
simple
implementation
of
the
Reader
monad
:
The
writer
monad
lets
us
emit
a
lazy
stream
of
values
from
within
a
monadic
context
.
A
simple
implementation
of
the
Writer
monad
:
This
implementation
is
lazy
so
some
care
must
be
taken
that
one
actually
wants
to
only
generate
a
stream
of
thunks
.
Most
often
the
lazy
writer
is
not
suitable
for
use
instead
implement
the
equivalent
structure
by
embedding
some
monomial
object
inside
a
StateT
monad
or
using
the
strict
version
.
The
state
monad
allows
functions
within
a
stateful
monadic
context
to
access
and
modify
shared
state
.
The
state
monad
is
often
mistakenly
described
as
being
impure
but
it
is
in
fact
entirely
pure
and
the
same
effect
could
be
achieved
by
explicitly
passing
state
.
A
simple
implementation
of
the
State
monad
takes
only
a
few
lines
:
So
many
monad
tutorials
have
been
written
that
it
begs
the
question
:
what
makes
monads
so
difficult
when
first
learning
Haskell
?
I
hypothesize
there
are
three
aspects
to
why
this
is
so
:
A
lot
of
the
Haskell
we
write
is
radically
rearranged
and
transformed
into
an
entirely
new
form
under
the
hood
.
Most
monad
tutorials
will
not
manually
expand
out
the
do
-
sugar
.
This
leaves
the
beginner
thinking
that
monads
are
a
way
of
dropping
into
a
pseudo
-
imperative
language
inside
of
code
and
further
fuels
that
misconception
that
specific
instances
like
IO
are
monads
in
their
full
generality
.
Being
able
to
manually
desugar
is
crucial
to
understanding
.
On
the
left
hand
side
of
the
operator
we
have
an
m
a
and
on
the
right
we
have
a
-&
gt
;
m
b
.
Although
some
languages
do
have
infix
operators
that
are
themselves
higher
order
functions
it
is
still
a
rather
rare
occurrence
.
So
with
a
function
desugared
it
can
be
confusing
that
(&
gt
;&
gt
;=)
operator
is
in
fact
building
up
a
much
larger
function
by
composing
functions
together
.
Written
in
prefix
form
it
becomes
a
little
bit
more
digestible
.
Perhaps
even
removing
the
operator
entirely
might
be
more
intuitive
coming
from
other
languages
.
Haskell
'
s
implementation
of
overloading
can
be
unintuitive
if
one
is
not
familiar
with
type
inference
.
It
is
abstracted
away
from
the
user
but
the
(&
gt
;&
gt
;=)
or
bind
function
is
really
a
function
of
3
arguments
with
the
extra
typeclass
dictionary
argument
(
$
dMonad
)
implicitly
threaded
around
.
Except
in
the
case
where
the
parameter
of
the
monad
class
is
unified
(
through
inference
)
with
a
concrete
class
instance
in
which
case
the
instance
dictionary
(
$
dMonadIO
)
is
instead
spliced
throughout
.
Now
all
of
these
transformations
are
trivial
once
we
understand
them
they
'
re
just
typically
not
discussed
.
In
my
opinion
the
fundamental
fallacy
of
monad
tutorials
is
not
that
intuition
for
monads
is
hard
to
convey
(
nor
are
metaphors
required
!
but
that
novices
often
come
to
monads
with
an
incomplete
understanding
of
points
(
1
(
2
and
(
3
)
and
then
trip
on
the
simple
fact
that
monads
are
the
first
example
of
a
Haskell
construct
that
is
the
confluence
of
all
three
.
See
:
Monad
Tutorial
Fallacy
So
the
descriptions
of
Monads
in
the
previous
chapter
are
a
bit
of
a
white
lie
.
Modern
Haskell
monad
libraries
typically
use
a
more
general
form
of
these
written
in
terms
of
monad
transformers
which
allow
us
to
compose
monads
together
to
form
composite
monads
.
The
monads
mentioned
previously
are
subsumed
by
the
special
case
of
the
transformer
form
composed
with
the
Identity
monad
.
In
terms
of
generality
the
mtl
library
is
the
most
common
general
interface
for
these
monads
which
itself
depends
on
the
transformers
library
which
generalizes
the
"
basic
"
monads
described
above
into
transformers
.
At
their
core
monad
transformers
allow
us
to
nest
monadic
computations
in
a
stack
with
an
interface
to
exchange
values
between
the
levels
called
lift
.
Just
as
the
base
monad
class
has
laws
monad
transformers
also
have
several
laws
:
Law
#
1
Law
#
2
Or
equivalently
:
Law
#
1
Law
#
2
It
'
s
useful
to
remember
that
transformers
compose
outside
-
in
but
are
unrolled
inside
out
.
See
:
Monad
Transformers
:
Step
-
By
-
Step
The
most
basic
use
requires
us
to
use
the
T
-
variants
for
each
of
the
monad
transformers
in
the
outer
layers
and
to
explicitly
lift
and
return
values
between
the
layers
.
Monads
have
kind
(*
-&
gt
;
*)
so
monad
transformers
which
take
monads
to
monads
have
((*
-&
gt
;
*)
-&
gt
;
*
-&
gt
;
*)
:
So
for
example
if
we
wanted
to
form
a
composite
computation
using
both
the
Reader
and
Maybe
monads
we
can
now
put
the
Maybe
inside
of
a
ReaderT
to
form
ReaderT
t
Maybe
a
.
The
fundamental
limitation
of
this
approach
is
that
we
find
ourselves
lift
.
lift
.
lift
ing
and
return
.
return
.
return
ing
a
lot
.
For
example
there
exist
three
possible
forms
of
the
Reader
monad
.
The
first
is
the
Haskell
98
version
that
no
longer
exists
but
is
useful
for
understanding
the
underlying
ideas
.
The
other
two
are
the
transformers
and
mtl
variants
.
Reader
ReaderT
MonadReader
So
hypothetically
the
three
variants
of
ask
would
be
:
In
practice
only
the
last
one
is
used
in
modern
Haskell
.
Newtypes
let
us
reference
a
data
type
with
a
single
constructor
as
a
new
distinct
type
with
no
runtime
overhead
from
boxing
unlike
an
algebraic
datatype
with
a
single
constructor
.
Newtype
wrappers
around
strings
and
numeric
types
can
often
drastically
reduce
accidental
errors
.
Consider
the
case
of
using
a
newtype
to
distinguish
between
two
different
text
blobs
with
different
semantics
.
Both
have
the
same
runtime
representation
as
a
text
object
but
are
distinguished
statically
so
that
plaintext
can
not
be
accidentally
interchanged
with
encrypted
text
.
The
other
common
use
case
is
using
newtypes
to
derive
logic
for
deriving
custom
monad
transformers
in
our
business
logic
.
Using
-
X
G
eneralizedNewtypeDeriving
we
can
recover
the
functionality
of
instances
of
the
underlying
types
composed
in
our
transformer
stack
.
Using
newtype
deriving
with
the
mtl
library
typeclasses
we
can
produce
flattened
transformer
types
that
don
'
t
require
explicit
lifting
in
the
transform
stack
.
For
example
here
is
a
little
stack
machine
involving
the
Reader
Writer
and
State
monads
.
Pattern
matching
on
a
newtype
constructor
compiles
into
nothing
.
For
example
the
extractB
function
does
not
scrutinize
the
MkB
constructor
like
the
extractA
does
because
MkB
does
not
exist
at
runtime
it
is
purely
a
compile
-
time
construct
.
The
second
monad
transformer
law
guarantees
that
sequencing
consecutive
lift
operations
is
semantically
equivalent
to
lifting
the
results
into
the
outer
monad
.
Although
they
are
guaranteed
to
yield
the
same
result
the
operation
of
lifting
the
results
between
the
monad
levels
is
not
without
cost
and
crops
up
frequently
when
working
with
the
monad
traversal
and
looping
functions
.
For
example
all
three
of
the
functions
on
the
left
below
are
less
efficient
than
the
right
hand
side
which
performs
the
bind
in
the
base
monad
instead
of
lifting
on
each
iteration
.
The
base
monad
transformer
package
provides
a
MonadTrans
class
for
lifting
to
another
monad
:
But
often
times
we
need
to
work
with
and
manipulate
our
monad
transformer
stack
to
either
produce
new
transformers
modify
existing
ones
or
extend
an
upstream
library
with
new
layers
.
The
mmorph
library
provides
the
capacity
to
compose
monad
morphism
transformation
directly
on
transformer
stacks
.
The
equivalent
of
type
transformer
type
-
level
map
is
the
hoist
function
.
Hoist
takes
a
monad
morphism
(
a
mapping
from
a
m
a
to
a
n
a
)
and
applies
in
on
the
inner
value
monad
of
a
transformer
stack
transforming
the
value
under
the
outer
layer
.
The
monad
morphism
generalize
takes
an
Identity
monad
into
any
another
monad
m
.
For
example
it
generalizes
State
s
a
(
which
is
StateT
s
Identity
a
)
to
StateT
s
m
a
.
So
we
can
generalize
an
existing
transformer
to
lift
an
IO
layer
onto
it
.
See
:
mmorph
It
'
s
important
to
distinguish
between
different
categories
of
language
extensions
general
and
specialized
.
The
inherent
problem
with
classifying
the
extensions
into
the
general
and
specialized
categories
is
that
it
'
s
a
subjective
classification
.
Haskellers
who
do
type
system
research
will
have
a
very
different
interpretation
of
Haskell
than
people
who
do
web
programming
.
As
such
this
is
a
conservative
assessment
as
an
arbitrary
baseline
let
'
s
consider
FlexibleInstances
and
OverloadedStrings
"
everyday
"
while
GADTs
and
TypeFamilies
are
"
specialized
".
Key
See
:
GHC
Extension
Reference
It
'
s
not
obvious
which
extensions
are
the
most
common
but
it
'
s
fairly
safe
to
say
that
these
extensions
are
benign
and
are
safely
used
extensively
:
GHC
'
s
typechecker
sometimes
just
casually
tells
us
to
enable
language
extensions
when
it
can
'
t
solve
certain
problems
.
These
include
:
These
almost
always
indicate
a
design
flaw
and
shouldn
'
t
be
turned
on
to
remedy
the
error
at
hand
as
much
as
GHC
might
suggest
otherwise
!
Inference
in
Haskell
is
usually
precise
although
there
are
several
boundary
cases
where
inference
is
difficult
or
impossible
to
infer
a
principal
type
of
an
expression
.
There
a
two
common
cases
:
The
inferred
type
signatures
are
correct
in
their
usage
but
don
'
t
represent
the
most
general
signatures
.
When
GHC
analyzes
the
module
it
analyzes
the
dependencies
of
expressions
on
each
other
groups
them
together
and
applies
substitutions
from
unification
across
mutually
defined
groups
.
As
such
the
inferred
types
may
not
be
the
most
general
types
possible
and
an
explicit
signature
may
be
desired
.
The
problem
with
this
expression
is
because
the
inferred
type
variable
a
in
size
spans
two
possible
types
(
a
and
(
a
a
)
the
recursion
is
polymorphic
.
These
two
types
won
'
t
pass
the
occurs
-
check
of
the
typechecker
and
it
yields
an
incorrect
inferred
type
.
Simply
adding
an
explicit
type
signature
corrects
this
.
Type
inference
using
polymorphic
recursion
is
undecidable
in
the
general
case
.
See
:
Static
Semantics
of
Function
and
Pattern
Bindings
The
most
common
edge
case
of
the
inference
is
known
as
the
dreaded
monomorphism
restriction
.
When
the
toplevel
declarations
of
a
module
are
generalized
the
monomorphism
restricts
that
toplevel
values
(
i
.
e
.
expressions
not
under
a
lambda
)
whose
type
contains
the
subclass
of
the
Num
type
from
the
Prelude
are
not
generalized
and
instead
are
instantiated
with
a
monotype
tried
sequentially
from
the
list
specified
by
the
default
which
is
normally
Integer
then
Double
.
As
of
GHC
7
.
8
the
monomorphism
restriction
is
switched
off
by
default
in
GHCi
.
Haskell
normally
applies
several
defaulting
rules
for
ambigious
literals
in
the
absence
of
an
explicit
type
signature
.
When
an
ambiguous
literal
is
typechecked
if
at
least
one
of
its
typeclass
constraints
is
numeric
and
all
of
its
classes
are
standard
library
classes
the
module
'
s
default
list
is
consulted
and
the
first
type
from
the
list
that
will
satisfy
the
context
of
the
type
variable
is
instantiated
.
So
for
instance
given
the
following
default
rules
.
The
following
set
of
heuristics
is
used
to
determine
what
to
instnatiate
the
ambiguous
type
variable
to
.
The
default
default
is
(
Integer
Double
)
This
is
normally
fine
but
sometimes
we
'
d
like
more
granular
control
over
defaulting
.
The
-
XExtendedDefaultRules
loosens
the
restriction
that
we
'
re
constrained
with
working
on
Numerical
typeclasses
and
the
constraint
that
we
can
only
work
with
standard
library
classes
.
If
we
'
d
like
to
have
our
string
literals
(
using
-
XOverlodaedStrings
)
automatically
default
to
the
more
efficient
Text
implementation
instead
of
String
we
can
twiddle
the
flag
and
GHC
will
perform
the
right
substitution
without
the
need
for
an
explicit
annotation
on
every
string
literal
.
For
code
typed
at
the
GHCi
prompt
the
-
XExtendedDefaultRules
flag
is
always
on
and
cannot
be
switched
off
.
See
:
Monomorphism
Restriction
As
everyone
eventually
finds
out
there
are
several
functions
within
the
implementation
of
GHC
(
not
the
Haskell
language
)
that
can
be
used
to
subvert
the
type
-
system
they
are
marked
with
the
prefix
unsafe
.
These
functions
exist
only
for
when
one
can
manually
prove
the
soundness
of
an
expression
but
can
'
t
express
this
property
in
the
type
-
system
or
externalities
to
Haskell
.
Using
these
functions
to
subvert
the
Haskell
typesystem
will
cause
all
measure
of
undefined
behavior
with
unimaginable
pain
and
suffering
and
are
strongly
discouraged
.
When
initially
starting
out
with
Haskell
there
are
no
legitimate
reason
to
use
these
functions
at
all
period
.
The
Safe
Haskell
language
extensions
allow
us
to
restrict
the
use
of
unsafe
language
features
using
-
XSafe
which
restricts
the
import
of
modules
which
are
themselves
marked
as
Safe
.
It
also
forbids
the
use
of
certain
language
extensions
(
-
XTemplateHaskell
)
which
can
be
used
to
produce
unsafe
code
.
The
primary
use
case
of
these
extensions
is
security
auditing
.
See
:
Safe
Haskell
The
same
hole
technique
can
be
applied
at
the
toplevel
for
signatures
:
Pattern
wildcards
can
also
be
given
explicit
names
so
that
GHC
will
use
when
reporting
the
inferred
type
in
the
resulting
message
.
The
same
wildcards
can
be
used
in
type
contexts
to
dump
out
inferred
type
class
constraints
:
When
the
flag
-
XPartialTypeSignatures
is
passed
to
GHC
and
the
inferred
type
is
unambiguous
GHC
will
let
us
leave
the
holes
in
place
and
the
compilation
will
proceed
.
Recursive
do
notation
allows
to
use
to
self
-
reference
expressions
on
both
sides
of
a
monadic
bind
.
For
instance
the
following
uses
lazy
evaluation
to
generate
a
infinite
list
.
This
is
sometimes
used
for
instantiating
cyclic
datatypes
inside
of
a
monadic
context
that
need
to
hold
a
reference
to
themselves
.
See
:
Recursive
Do
Notation
By
default
GHC
desugars
do
-
notation
to
use
implicit
invocations
of
bind
and
return
.
Desugars
into
:
With
ApplicativeDo
this
instead
desugars
into
use
of
applicative
combinators
and
a
laxer
Applicative
constraint
.
Pattern
guards
are
an
extension
to
the
pattern
matching
syntax
.
Given
a
&
lt
;-
pattern
qualifier
the
right
hand
side
is
evaluated
and
matched
against
the
pattern
on
the
left
.
If
the
match
fails
then
the
whole
guard
fails
and
the
next
equation
is
tried
.
If
it
succeeds
then
the
appropriate
binding
takes
place
and
the
next
qualifier
is
matched
in
the
augmented
environment
.
View
patterns
are
like
pattern
guards
that
can
be
nested
inside
of
other
patterns
.
They
are
a
convenient
way
of
pattern
-
matching
against
values
of
algebraic
data
types
.
GHC
normally
requires
at
least
one
pattern
branch
in
case
statement
this
restriction
can
be
relaxed
with
-
XEmptyCase
.
The
case
statement
then
immediately
yields
a
Non
-
exhaustive
patterns
in
case
if
evaluated
.
For
case
statements
LambdaCase
allows
the
elimination
of
redundant
free
variables
introduced
purely
for
the
case
of
pattern
matching
on
.
NumDecimals
allows
the
use
of
exponential
notation
for
integral
literals
that
are
not
necessarily
floats
.
Without
it
any
use
of
expontial
notation
induces
a
Fractional
class
constraint
.
Package
imports
allows
us
to
disambiguate
hierarchical
package
names
by
their
respective
package
key
.
This
is
useful
in
the
case
where
you
have
to
imported
packages
that
expose
the
same
module
.
In
practice
most
of
the
common
libraries
have
taken
care
to
avoid
conflicts
in
the
namespace
and
this
is
not
usually
a
problem
in
most
modern
Haskell
.
For
example
we
could
explicitly
ask
GHC
to
resolve
that
Control
.
Monad
.
Error
package
be
drawn
from
the
mtl
library
.
Record
wild
cards
allow
us
to
expand
out
the
names
of
a
record
as
variables
scoped
as
the
labels
of
the
record
implicitly
.
The
extension
can
be
used
to
extract
variables
names
into
a
scope
or
to
assign
to
variables
in
a
record
drawing
aligning
the
record
'
s
labels
with
the
variables
in
scope
for
the
assignment
.
The
syntax
introduced
is
the
{..}
pattern
selector
.
Provides
alternative
syntax
for
accessing
record
fields
in
a
pattern
match
.
Suppose
we
were
writing
a
typechecker
it
would
be
very
common
to
include
a
distinct
TArr
term
to
ease
the
telescoping
of
function
signatures
this
is
what
GHC
does
in
its
Core
language
.
Even
though
technically
it
could
be
written
in
terms
of
more
basic
application
of
the
(-&
gt
;)
constructor
.
With
pattern
synonyms
we
can
eliminate
the
extraneous
constructor
without
losing
the
convenience
of
pattern
matching
on
arrow
types
.
So
now
we
can
write
an
eliminator
and
constructor
for
arrow
type
very
naturally
.
Pattern
synonyms
can
be
exported
from
a
module
like
any
other
definition
by
prefixing
them
with
the
prefix
pattern
.
With
-
XDeriveAnyClass
we
can
derive
any
class
.
The
deriving
logic
s
generates
an
instance
declaration
for
the
type
with
no
explicitly
-
defined
methods
.
If
the
typeclass
implements
a
default
for
each
method
then
this
will
be
well
-
defined
and
give
rise
to
an
automatic
instances
.
GHC
8
.
0
introduced
the
DuplicateRecordFields
extensions
which
loosens
GHC
'
s
restriction
on
records
in
the
same
module
with
identical
accessors
.
The
precise
type
that
is
being
projected
into
is
now
deferred
to
the
callsite
.
Using
just
DuplicateRecordFields
projection
is
still
not
supported
so
the
following
will
not
work
.
OverloadedLabels
fixes
this
to
some
extent
.
GHC
8
.
0
also
introduced
the
OverloadedLabels
extension
which
allows
a
limited
form
of
polymorphism
over
labels
that
share
the
same
name
.
To
work
with
overloaded
labels
types
we
need
to
enable
several
language
extensions
to
work
with
promoted
strings
and
multiparam
typeclasses
that
underly
it
'
s
implementation
.
See
:
The
C
++
preprocessor
is
the
fallback
whenever
we
really
need
to
separate
out
logic
that
has
to
span
multiple
versions
of
GHC
and
language
changes
while
maintaining
backwards
compatibility
.
It
can
dispatch
on
the
version
of
GHC
being
used
to
compile
a
module
.
To
demarcate
code
based
on
the
operating
system
compiled
on
.
Or
on
the
version
of
the
base
library
used
.
It
can
also
be
abused
to
do
terrible
things
like
metaprogrammming
with
strings
but
please
don
'
t
do
this
.
Several
language
extensions
have
either
been
absorbed
into
the
core
language
or
become
deprecated
in
favor
of
others
.
Others
are
just
considered
misfeatures
.
In
the
presence
of
default
implementations
of
typeclasses
methods
there
may
be
several
ways
to
implement
a
typeclass
.
For
instance
Eq
is
entirely
defined
by
either
defining
when
two
values
are
equal
or
not
equal
by
implying
taking
the
negation
of
the
other
.
We
can
define
equality
in
terms
of
non
-
equality
and
vice
-
versa
.
Before
7
.
6
.
1
there
was
no
way
to
specify
what
was
the
"
minimal
"
definition
required
to
implement
a
typeclass
Minimal
pragmas
are
boolean
expressions
with
|
as
logical
OR
either
definition
must
be
defined
).
Comma
indicates
logical
AND
where
both
sides
both
definitions
must
be
defined
.
Compiling
the
-
Wmissing
-
methods
will
warn
when
a
instance
is
defined
that
does
not
meet
the
minimal
criterion
.
Typeclasses
are
normally
globally
coherent
there
is
only
ever
one
instance
that
can
be
resolved
for
a
type
unambiguously
for
a
type
at
any
call
site
in
the
program
.
There
are
however
extensions
to
loosen
this
restriction
and
perform
more
manual
direction
of
the
instance
search
.
Overlapping
instances
loosens
the
coherent
condition
(
there
can
be
multiple
instances
)
but
introduces
a
criterion
that
it
will
resolve
to
the
most
specific
one
.
Historically
enabling
this
on
module
-
level
was
not
the
best
idea
since
generally
we
define
multiple
classes
in
a
module
only
a
subset
of
which
may
be
incoherent
.
So
as
of
7
.
10
we
now
have
the
capacity
to
just
annotate
instances
with
the
OVERLAPPING
and
INCOHERENT
pragmas
.
Incoherent
instance
loosens
the
restriction
that
there
be
only
one
specific
instance
will
choose
one
arbitrarily
(
based
on
the
arbitrary
sorting
of
it
'
s
internal
representation
)
and
the
resulting
program
will
typecheck
.
This
is
generally
pretty
crazy
and
usually
a
sign
of
poor
design
.
There
is
also
an
incoherent
instance
.
Again
a
subject
on
which
much
ink
has
been
spilled
.
There
is
an
ongoing
discussion
in
the
land
of
Haskell
about
the
compromises
between
lazy
and
strict
evaluation
and
there
are
nuanced
arguments
for
having
either
paradigm
be
the
default
.
Haskell
takes
a
hybrid
approach
and
allows
strict
evaluation
when
needed
and
uses
laziness
by
default
.
Needless
to
say
we
can
always
find
examples
where
strict
evaluation
exhibits
worse
behavior
than
lazy
evaluation
and
vice
versa
.
The
primary
advantage
of
lazy
evaluation
in
the
large
is
that
algorithms
that
operate
over
both
unbounded
and
bounded
data
structures
can
inhabit
the
same
type
signatures
and
be
composed
without
additional
need
to
restructure
their
logic
or
force
intermediate
computations
.
Languages
that
attempt
to
bolt
laziness
on
to
a
strict
evaluation
model
often
bifurcate
classes
of
algorithms
into
ones
that
are
hand
-
adjusted
to
consume
unbounded
structures
and
those
which
operate
over
bounded
structures
.
In
strict
languages
mixing
and
matching
between
lazy
vs
strict
processing
often
necessitates
manifesting
large
intermediate
structures
in
memory
when
such
composition
would
"
just
work
"
in
a
lazy
language
.
By
virtue
of
Haskell
being
the
only
language
to
actually
explore
this
point
in
the
design
space
to
the
point
of
being
industrial
strength
;
knowledge
about
lazy
evaluation
is
not
widely
absorbed
into
the
collective
programmer
consciousness
and
can
often
be
non
-
intuitive
to
the
novice
.
This
doesn
'
t
reflect
on
the
model
itself
merely
on
the
need
for
more
instruction
material
and
research
on
optimizing
lazy
compilers
.
The
paradox
of
Haskell
is
that
it
explores
so
many
definably
unique
ideas
(
laziness
purity
typeclasses
)
that
it
becomes
difficult
to
separate
out
the
discussion
of
any
one
from
the
gestalt
of
the
whole
implementation
.
See
:
There
are
several
evaluation
models
for
the
lambda
calculus
:
These
ideas
give
rise
to
several
models
Haskell
itself
use
the
call
-
by
-
need
model
.
A
term
is
said
to
be
in
weak
head
normal
-
form
if
the
outermost
constructor
or
lambda
cannot
be
reduced
further
.
A
term
is
said
to
be
in
normal
form
if
it
is
fully
evaluated
and
all
sub
-
expressions
and
thunks
contained
within
are
evaluated
.
In
Haskell
normal
evaluation
only
occurs
at
the
outer
constructor
of
case
-
statements
in
Core
.
If
we
pattern
match
on
a
list
we
don
'
t
implicitly
force
all
values
in
the
list
.
An
element
in
a
data
structure
is
only
evaluated
up
to
the
most
outer
constructor
.
For
example
to
evaluate
the
length
of
a
list
we
need
only
scrutinize
the
outer
Cons
constructors
without
regard
for
their
inner
values
.
For
example
in
a
lazy
language
the
following
program
terminates
even
though
it
contains
diverging
terms
.
In
a
strict
language
like
OCaml
(
ignoring
its
suspensions
for
the
moment
the
same
program
diverges
.
In
Haskell
a
thunk
is
created
to
stand
for
an
unevaluated
computation
.
Evaluation
of
a
thunk
is
called
forcing
the
thunk
.
The
result
is
an
update
a
referentially
transparent
effect
which
replaces
the
memory
representation
of
the
thunk
with
the
computed
value
.
The
fundamental
idea
is
that
a
thunk
is
only
updated
once
(
although
it
may
be
forced
simultaneously
in
a
multi
-
threaded
environment
)
and
its
resulting
value
is
shared
when
referenced
subsequently
.
The
command
:
sprint
can
be
used
to
introspect
the
state
of
unevaluated
thunks
inside
an
expression
without
forcing
evaluation
.
For
instance
:
While
a
thunk
is
being
computed
its
memory
representation
is
replaced
with
a
special
form
known
as
blackhole
which
indicates
that
computation
is
ongoing
and
allows
for
a
short
circuit
for
when
a
computation
might
depend
on
itself
to
complete
.
The
implementation
of
this
is
some
of
the
more
subtle
details
of
the
GHC
runtime
.
The
seq
function
introduces
an
artificial
dependence
on
the
evaluation
of
order
of
two
terms
by
requiring
that
the
first
argument
be
evaluated
to
WHNF
before
the
evaluation
of
the
second
.
The
implementation
of
the
seq
function
is
an
implementation
detail
of
GHC
.
The
infamous
foldl
is
well
-
known
to
leak
space
when
used
carelessly
and
without
several
compiler
optimizations
applied
.
The
strict
foldl
'
variant
uses
seq
to
overcome
this
.
In
practice
a
combination
between
the
strictness
analyzer
and
the
inliner
on
-
O
2
will
ensure
that
the
strict
variant
of
foldl
is
used
whenever
the
function
is
inlinable
at
call
site
so
manually
using
foldl
'
is
most
often
not
required
.
Of
important
note
is
that
GHCi
runs
without
any
optimizations
applied
so
the
same
program
that
performs
poorly
in
GHCi
may
not
have
the
same
performance
characteristics
when
compiled
with
GHC
.
The
extension
BangPatterns
allows
an
alternative
syntax
to
force
arguments
to
functions
to
be
wrapped
in
seq
.
A
bang
operator
on
an
arguments
forces
its
evaluation
to
weak
head
normal
form
before
performing
the
pattern
match
.
This
can
be
used
to
keep
specific
arguments
evaluated
throughout
recursion
instead
of
creating
a
giant
chain
of
thunks
.
This
is
desugared
into
code
effectively
equivalent
to
the
following
:
Function
application
to
seq
'
d
arguments
is
common
enough
that
it
has
a
special
operator
.
As
of
GHC
8
.
0
strictness
annotations
can
be
applied
to
all
definitions
in
a
module
automatically
.
In
previous
versions
it
was
necessary
to
definitions
via
explicit
syntactic
annotations
at
all
sites
.
Enabling
StrictData
makes
constructor
fields
strict
by
default
on
any
module
it
is
enabled
on
.
Is
equivalent
to
:
Strict
implies
-
XStrictData
and
extends
strictness
annotations
to
all
arguments
of
functions
.
Is
equivalent
to
the
following
function
declaration
with
explicit
bang
patterns
:
On
a
module
-
level
this
effectively
makes
Haskell
a
call
-
by
-
value
language
with
some
caveats
.
All
arguments
to
functions
are
now
explicitly
evaluated
and
all
data
in
constructors
within
this
module
are
in
head
normal
form
by
construction
.
However
there
are
some
subtle
points
to
this
that
are
better
explained
in
the
language
guide
.
There
are
often
times
when
for
performance
reasons
we
need
to
deeply
evaluate
a
data
structure
to
normal
form
leaving
no
terms
unevaluated
.
The
deepseq
library
performs
this
task
.
The
typeclass
NFData
(
Normal
Form
Data
)
allows
us
to
seq
all
elements
of
a
structure
across
any
subtypes
which
themselves
implement
NFData
.
To
force
a
data
structure
itself
to
be
fully
evaluated
we
share
the
same
argument
in
both
positions
of
deepseq
.
A
lazy
pattern
doesn
'
t
require
a
match
on
the
outer
constructor
instead
it
lazily
calls
the
accessors
of
the
values
as
needed
.
In
the
presence
of
a
bottom
we
fail
at
the
usage
site
instead
of
the
outer
pattern
match
.
Haskell
being
a
25
year
old
language
has
witnessed
several
revolutions
in
the
way
we
structure
and
compose
functional
programs
.
Yet
as
a
result
several
portions
of
the
Prelude
still
reflect
old
schools
of
thought
that
simply
can
'
t
be
removed
without
breaking
significant
parts
of
the
ecosystem
.
Currently
it
really
only
exists
in
folklore
which
parts
to
use
and
which
not
to
use
although
this
is
a
topic
that
almost
all
introductory
books
don
'
t
mention
and
instead
make
extensive
use
of
the
Prelude
for
simplicity
'
s
sake
.
The
short
version
of
the
advice
on
the
Prelude
is
:
The
instances
of
Foldable
for
the
list
type
often
conflict
with
the
monomorphic
versions
in
the
Prelude
which
are
left
in
for
historical
reasons
.
So
often
times
it
is
desirable
to
explicitly
mask
these
functions
from
implicit
import
and
force
the
use
of
Foldable
and
Traversable
instead
.
Of
course
often
times
one
wishes
only
to
use
the
Prelude
explicitly
and
one
can
explicitly
import
it
qualified
and
use
the
pieces
as
desired
without
the
implicit
import
of
the
whole
namespace
.
To
get
work
done
you
probably
need
.
The
default
Prelude
can
be
disabled
in
it
'
s
entirety
by
twiddling
the
-
XNoImplicitPrelude
flag
.
We
are
then
free
to
build
an
equivalent
Prelude
that
is
more
to
our
liking
.
Using
module
reexporting
we
can
pluck
the
good
parts
of
the
prelude
and
libraries
like
safe
to
build
up
a
more
industrial
focused
set
of
default
functions
.
For
example
:
The
Prelude
itself
is
entirely
replicable
as
well
presuming
that
an
entire
project
is
compiled
without
the
implicit
Prelude
.
Several
packages
have
arisen
that
supply
much
of
the
same
functionality
in
a
way
that
appeals
to
more
modern
design
principles
.
Protolude
is
a
minimalist
Prelude
which
provides
many
sensible
defaults
for
writing
modern
Haskell
and
is
compatible
with
existing
code
.
Other
examples
for
alternative
Preludes
include
(
your
mileage
may
vary
with
these
):
A
partial
function
is
a
function
which
doesn
'
t
terminate
and
yield
a
value
for
all
given
inputs
.
Conversely
a
total
function
terminates
and
is
always
defined
for
all
inputs
.
As
mentioned
previously
certain
historical
parts
of
the
Prelude
are
full
of
partial
functions
.
The
difference
between
partial
and
total
functions
is
the
compiler
can
'
t
reason
about
the
runtime
safety
of
partial
functions
purely
from
the
information
specified
in
the
language
and
as
such
the
proof
of
safety
is
left
to
the
user
to
guarantee
.
They
are
safe
to
use
in
the
case
where
the
user
can
guarantee
that
invalid
inputs
cannot
occur
but
like
any
unchecked
property
its
safety
or
not
-
safety
is
going
to
depend
on
the
diligence
of
the
programmer
.
This
very
much
goes
against
the
overall
philosophy
of
Haskell
and
as
such
they
are
discouraged
when
not
necessary
.
The
Prelude
has
total
variants
of
the
historical
partial
functions
(
i
.
e
.
Text
.
Read
.
readMaybe
)
in
some
cases
but
often
these
are
found
in
the
various
utility
libraries
like
safe
.
The
total
versions
provided
fall
into
three
cases
:
The
problem
with
the
boolean
type
is
that
there
is
effectively
no
difference
between
True
and
False
at
the
type
level
.
A
proposition
taking
a
value
to
a
Bool
takes
any
information
given
and
destroys
it
.
To
reason
about
the
behavior
we
have
to
trace
the
provenance
of
the
proposition
we
'
re
getting
the
boolean
answer
from
and
this
introduces
a
whole
slew
of
possibilities
for
misinterpretation
.
In
the
worst
case
the
only
way
to
reason
about
safe
and
unsafe
use
of
a
function
is
by
trusting
that
a
predicate
'
s
lexical
name
reflects
its
provenance
!
For
instance
testing
some
proposition
over
a
Bool
value
representing
whether
the
branch
can
perform
the
computation
safely
in
the
presence
of
a
null
is
subject
to
accidental
interchange
.
Consider
that
in
a
language
like
C
or
Python
testing
whether
a
value
is
null
is
indistinguishable
to
the
language
from
testing
whether
the
value
is
not
null
.
Which
of
these
programs
encodes
safe
usage
and
which
segfaults
?
From
inspection
we
can
'
t
tell
without
knowing
how
p
is
defined
the
compiler
can
'
t
distinguish
the
two
either
and
thus
the
language
won
'
t
save
us
if
we
happen
to
mix
them
up
.
Instead
of
making
invalid
states
unrepresentable
we
'
ve
made
the
invalid
state
indistinguishable
from
the
valid
one
!
The
more
desirable
practice
is
to
match
on
terms
which
explicitly
witness
the
proposition
as
a
type
(
often
in
a
sum
type
)
and
won
'
t
typecheck
otherwise
.
To
be
fair
though
many
popular
languages
completely
lack
the
notion
of
sum
types
(
the
source
of
many
woes
in
my
opinion
)
and
only
have
product
types
so
this
type
of
reasoning
sometimes
has
no
direct
equivalence
for
those
not
familiar
with
ML
family
languages
.
In
Haskell
the
Prelude
provides
functions
like
isJust
and
fromJust
both
of
which
can
be
used
to
subvert
this
kind
of
reasoning
and
make
it
easy
to
introduce
bugs
and
should
often
be
avoided
.
If
coming
from
an
imperative
background
retraining
one
'
s
self
to
think
about
iteration
over
lists
in
terms
of
maps
folds
and
scans
can
be
challenging
.
For
a
concrete
consider
the
simple
arithmetic
sequence
over
the
binary
operator
(+)
:
Foldable
and
Traversable
are
the
general
interface
for
all
traversals
and
folds
of
any
data
structure
which
is
parameterized
over
its
element
type
(
List
Map
Set
Maybe
...).
These
two
classes
are
used
everywhere
in
modern
Haskell
and
are
extremely
important
.
A
foldable
instance
allows
us
to
apply
functions
to
data
types
of
monoidal
values
that
collapse
the
structure
using
some
logic
over
mappend
.
A
traversable
instance
allows
us
to
apply
functions
to
data
types
that
walk
the
structure
left
-
to
-
right
within
an
applicative
context
.
The
foldMap
function
is
extremely
general
and
non
-
intuitively
many
of
the
monomorphic
list
folds
can
themselves
be
written
in
terms
of
this
single
polymorphic
function
.
foldMap
takes
a
function
of
values
to
a
monoidal
quantity
a
functor
over
the
values
and
collapses
the
functor
into
the
monoid
.
For
instance
for
the
trivial
Sum
monoid
:
For
instance
if
we
wanted
to
map
a
list
of
some
abstract
element
types
into
a
hashtable
of
elements
based
on
pattern
matching
we
could
use
it
.
The
full
Foldable
class
(
with
all
default
implementations
)
contains
a
variety
of
derived
functions
which
themselves
can
be
written
in
terms
of
foldMap
and
Endo
.
For
example
:
Most
of
the
operations
over
lists
can
be
generalized
in
terms
of
combinations
of
Foldable
and
Traversable
to
derive
more
general
functions
that
work
over
all
data
structures
implementing
Foldable
.
Unfortunately
for
historical
reasons
the
names
exported
by
foldable
quite
often
conflict
with
ones
defined
in
the
Prelude
either
import
them
qualified
or
just
disable
the
Prelude
.
The
operations
in
the
Foldable
all
specialize
to
the
same
and
behave
the
same
as
the
ones
in
Prelude
for
List
types
.
The
instances
we
defined
above
can
also
be
automatically
derived
by
GHC
using
several
language
extensions
.
The
automatic
instances
are
identical
to
the
hand
-
written
versions
above
.
See
:
Typeclassopedia
A
recursive
function
consumes
data
and
eventually
terminates
a
corecursive
function
generates
data
and
coterminates
.
A
corecursive
function
is
said
to
be
productive
if
it
can
always
evaluate
more
of
the
resulting
value
in
bounded
time
.
The
split
package
provides
a
variety
of
missing
functions
for
splitting
list
and
string
types
.
The
monad
-
loops
package
provides
a
variety
of
missing
functions
for
control
logic
in
monadic
contexts
.
TODO
See
:
Foundation
The
default
String
type
is
broken
and
should
be
avoided
whenever
possible
.
Unfortunately
for
historical
reasons
large
portions
of
GHC
and
Base
depend
on
String
.
The
default
Haskell
string
type
is
implemented
as
a
naive
linked
list
of
characters
this
is
terrible
for
most
purposes
but
no
one
knows
how
to
fix
it
without
rewriting
large
portions
of
all
code
that
exists
and
nobody
can
commit
the
time
to
fix
it
.
So
it
remains
broken
likely
forever
.
For
more
performance
sensitive
cases
there
are
two
libraries
for
processing
textual
data
:
text
and
bytestring
.
For
each
of
these
there
are
two
variants
for
both
text
and
bytestring
.
Giving
rise
to
the
four
types
.
Conversions
between
strings
types
(
from
:
left
column
to
:
top
row
)
are
done
with
several
functions
across
the
bytestring
and
text
libraries
.
The
mapping
between
text
and
bytestring
is
inherently
lossy
so
there
is
some
degree
of
freedom
in
choosing
the
encoding
.
We
'
ll
just
consider
utf
-
8
for
simplicity
.
With
the
-
XOverloadedStrings
extension
string
literals
can
be
overloaded
without
the
need
for
explicit
packing
and
can
be
written
as
string
literals
in
the
Haskell
source
and
overloaded
via
a
typeclass
IsString
.
Sometimes
this
is
desirable
.
For
instance
:
We
can
also
derive
IsString
for
newtypes
using
G
eneralizedNewtypeDeriving
although
much
of
the
safety
of
the
newtype
is
then
lost
if
it
is
interchangeable
with
other
strings
.
A
Text
type
is
a
packed
blob
of
Unicode
characters
.
See
:
Text
The
Text
.
Builder
allows
the
efficient
monoidal
construction
of
lazy
Text
types
without
having
to
go
through
inefficient
forms
like
String
or
List
types
as
intermediates
.
ByteStrings
are
arrays
of
unboxed
characters
with
either
strict
or
lazy
evaluation
.
See
:
See
:
utf
8
-
string
Haskell
also
has
a
variadic
printf
function
in
the
style
of
C
.
It
is
ubiquitous
for
data
structure
libraries
to
expose
toList
and
fromList
functions
to
construct
various
structures
out
of
lists
.
As
of
GHC
7
.
8
we
now
have
the
ability
to
overload
the
list
syntax
in
the
surface
language
with
a
typeclass
IsList
.
Playing
"
type
-
tetris
"
to
convert
between
Strings
explicitly
can
be
frustrating
fortunately
there
are
several
packages
that
automate
the
conversion
using
typeclasses
to
automatically
convert
between
any
two
common
string
representations
automatically
.
We
can
then
write
generic
comparison
and
concatenation
operators
that
automatically
convert
types
of
operands
to
a
like
form
.
Like
monads
Applicatives
are
an
abstract
structure
for
a
wide
class
of
computations
that
sit
between
functors
and
monads
in
terms
of
generality
.
As
of
GHC
7
.
6
Applicative
is
defined
as
:
With
the
following
laws
:
As
an
example
consider
the
instance
for
Maybe
:
As
a
rule
of
thumb
whenever
we
would
use
m
&
gt
;&
gt
;=
return
.
f
what
we
probably
want
is
an
applicative
functor
and
not
a
monad
.
The
pattern
f
&
lt
;$&
gt
;
a
&
lt
;*&
gt
;
b
...
shows
up
so
frequently
that
there
are
a
family
of
functions
to
lift
applicatives
of
a
fixed
number
arguments
.
This
pattern
also
shows
up
frequently
with
monads
(
liftM
liftM
2
liftM
3
).
Applicative
also
has
functions
*&
gt
;
and
&
lt
;*
that
sequence
applicative
actions
while
discarding
the
value
of
one
of
the
arguments
.
The
operator
*&
gt
;
discard
the
left
while
&
lt
;*
discards
the
right
.
For
example
in
a
monadic
parser
combinator
library
the
*&
gt
;
would
parse
with
first
parser
argument
but
return
the
second
.
The
Applicative
functions
&
lt
;$&
gt
;
and
&
lt
;*&
gt
;
are
generalized
by
liftM
and
ap
for
monads
.
See
:
Applicative
Programming
with
Effects
Alternative
is
an
extension
of
the
Applicative
class
with
a
zero
element
and
an
associative
binary
operation
respecting
the
zero
.
These
instances
show
up
very
frequently
in
parsers
where
the
alternative
operator
can
model
alternative
parse
branches
.
A
category
is
an
algebraic
structure
that
includes
a
notion
of
an
identity
and
a
composition
operation
that
is
associative
and
preserves
identities
.
Arrows
are
an
extension
of
categories
with
the
notion
of
products
.
The
canonical
example
is
for
functions
.
In
this
form
functions
of
multiple
arguments
can
be
threaded
around
using
the
arrow
combinators
in
a
much
more
pointfree
form
.
For
instance
a
histogram
function
has
a
nice
one
-
liner
.
Arrow
notation
GHC
has
builtin
syntax
for
composing
arrows
using
proc
notation
.
The
following
are
equivalent
after
desugaring
:
In
practice
this
notation
is
not
often
used
and
may
become
deprecated
in
the
future
.
See
:
Arrow
Notation
Bifunctors
are
a
generalization
of
functors
to
include
types
parameterized
by
two
parameters
and
include
two
map
functions
for
each
parameter
.
The
bifunctor
laws
are
a
natural
generalization
of
the
usual
functor
.
Namely
they
respect
identities
and
composition
in
the
usual
way
:
The
canonical
example
is
for
2
-
tuples
.
One
surprising
application
of
typeclasses
is
the
ability
to
construct
functions
which
take
an
arbitrary
number
of
arguments
by
defining
instances
over
function
types
.
The
arguments
may
be
of
arbitrary
type
but
the
resulting
collected
arguments
must
either
converted
into
a
single
type
or
unpacked
into
a
sum
type
.
See
:
Polyvariadic
functions
The
low
-
level
(
and
most
dangerous
)
way
to
handle
errors
is
to
use
the
throw
and
catch
functions
which
allow
us
to
throw
extensible
exceptions
in
pure
code
but
catch
the
resulting
exception
within
IO
.
Of
specific
note
is
that
return
value
of
the
throw
inhabits
all
types
.
There
'
s
no
reason
to
use
this
for
custom
code
that
doesn
'
t
use
low
-
level
system
operations
.
Because
a
value
will
not
be
evaluated
unless
needed
if
one
desires
to
know
for
sure
that
an
exception
is
either
caught
or
not
it
can
be
deeply
forced
into
head
normal
form
before
invoking
catch
.
The
strictCatch
is
not
provided
by
standard
library
but
has
a
simple
implementation
in
terms
of
deepseq
.
The
problem
with
the
previous
approach
is
having
to
rely
on
GHC
'
s
asynchronous
exception
handling
inside
of
IO
to
handle
basic
operations
.
The
exceptions
provides
the
same
API
as
Control
.
Exception
but
loosens
the
dependency
on
IO
.
See
:
exceptions
As
of
mtl
2
.
2
or
higher
the
ErrorT
class
has
been
replaced
by
the
ExceptT
.
At
transformers
level
.
Using
mtl
:
See
:
Sometimes
you
'
ll
be
forced
to
deal
with
seemingly
pure
functions
that
can
throw
up
at
any
point
.
There
are
many
functions
in
the
standard
library
like
this
and
many
more
on
Hackage
.
You
'
d
like
to
be
handle
this
logic
purely
as
if
it
were
returning
a
proper
Maybe
a
but
to
catch
the
logic
you
'
d
need
to
install
a
IO
handler
inside
IO
to
catch
it
.
Spoon
allows
us
to
safely
(
and
"
purely
although
it
uses
a
referentially
transparent
invocation
of
unsafePerformIO
)
to
catch
these
exceptions
and
put
them
in
Maybe
where
they
belong
.
The
spoon
function
evaluates
its
argument
to
head
normal
form
while
teaspoon
evaluates
to
weak
head
normal
form
.
See
:
TODO
If
one
writes
Haskell
long
enough
one
might
eventually
encounter
the
curious
beast
that
is
the
((-&
gt
;)
r
)
monad
instance
.
It
generally
tends
to
be
non
-
intuitive
to
work
with
but
is
quite
simple
when
one
considers
it
as
an
unwrapped
Reader
monad
.
This
just
uses
a
prefix
form
of
the
arrow
type
operator
.
The
RWS
monad
combines
the
functionality
of
the
three
monads
discussed
above
the
R
eader
W
riter
and
S
tate
.
There
is
also
a
RWST
transformer
.
These
three
eval
functions
are
now
combined
into
the
following
functions
:
The
usual
caveat
about
Writer
laziness
also
applies
to
RWS
.
In
continuation
passing
style
composite
computations
are
built
up
from
sequences
of
nested
computations
which
are
terminated
by
a
final
continuation
which
yields
the
result
of
the
full
computation
by
passing
a
function
into
the
continuation
chain
.
Choice
and
failure
.
MonadPlus
forms
a
monoid
with
The
fixed
point
of
a
monadic
computation
.
mfix
f
executes
the
action
f
only
once
with
the
eventual
output
fed
back
as
the
input
.
The
regular
do
-
notation
can
also
be
extended
with
-
XRecursiveDo
to
accommodate
recursive
monadic
bindings
.
The
ST
monad
models
"
threads
"
of
stateful
computations
which
can
manipulate
mutable
references
but
are
restricted
to
only
return
pure
values
when
evaluated
and
are
statically
confined
to
the
ST
monad
of
a
s
thread
.
Using
the
ST
monad
we
can
create
a
class
of
efficient
purely
functional
data
structures
that
use
mutable
references
in
a
referentially
transparent
way
.
Free
monads
are
monads
which
instead
of
having
a
join
operation
that
combines
computations
instead
forms
composite
computations
from
application
of
a
functor
.
One
of
the
best
examples
is
the
Partiality
monad
which
models
computations
which
can
diverge
.
Haskell
allows
unbounded
recursion
but
for
example
we
can
create
a
free
monad
from
the
Maybe
functor
which
can
be
used
to
fix
the
call
-
depth
of
for
example
the
Ackermann
function
.
The
other
common
use
for
free
monads
is
to
build
embedded
domain
-
specific
languages
to
describe
computations
.
We
can
model
a
subset
of
the
IO
monad
by
building
up
a
pure
description
of
the
computation
inside
of
the
IOFree
monad
and
then
using
the
free
monad
to
encode
the
translation
to
an
effectful
IO
computation
.
An
implementation
such
as
the
one
found
in
free
might
look
like
the
following
:
See
:
Indexed
monads
are
a
generalisation
of
monads
that
adds
an
additional
type
parameter
to
the
class
that
carries
information
about
the
computation
or
structure
of
the
monadic
implementation
.
The
canonical
use
-
case
is
a
variant
of
the
vanilla
State
which
allows
type
-
changing
on
the
state
for
intermediate
steps
inside
of
the
monad
.
This
indeed
turns
out
to
be
very
useful
for
handling
a
class
of
problems
involving
resource
management
since
the
extra
index
parameter
gives
us
space
to
statically
enforce
the
sequence
of
monadic
actions
by
allowing
and
restricting
certain
state
transitions
on
the
index
parameter
at
compile
-
time
.
To
make
this
more
usable
we
'
ll
use
the
somewhat
esoteric
-
XRebindableSyntax
allowing
us
to
overload
the
do
-
notation
and
if
-
then
-
else
syntax
by
providing
alternative
definitions
local
to
the
module
.
See
:
Fun
with
Indexed
monads
The
default
prelude
predates
a
lot
of
the
work
on
monad
transformers
and
as
such
many
of
the
common
functions
for
handling
errors
and
interacting
with
IO
are
bound
strictly
to
the
IO
monad
and
not
to
functions
implementing
stacks
on
top
of
IO
or
ST
.
The
lifted
-
base
provides
generic
control
operations
such
as
catch
can
be
lifted
from
IO
or
any
other
base
monad
.
Monad
base
provides
an
abstraction
over
liftIO
and
other
functions
to
explicitly
lift
into
a
"
privileged
"
layer
of
the
transformer
stack
.
It
'
s
implemented
a
multiparamater
typeclass
with
the
"
base
"
monad
as
the
parameter
b
.
Monad
control
builds
on
top
of
monad
-
base
to
extended
lifting
operation
to
control
operations
like
catch
and
bracket
can
be
written
generically
in
terms
of
any
transformer
with
a
base
layer
supporting
these
operations
.
Generic
operations
can
then
be
expressed
in
terms
of
a
MonadBaseControl
and
written
in
terms
of
the
combinator
control
which
handles
the
bracket
and
automatic
handler
lifting
.
For
example
the
function
catch
provided
by
Control
.
Exception
is
normally
locked
into
IO
.
By
composing
it
in
terms
of
control
we
can
construct
a
generic
version
which
automatically
lifts
inside
of
any
combination
of
the
usual
transformer
stacks
that
has
MonadBaseControl
instance
.
This
is
an
advanced
section
and
is
not
typically
necessary
to
write
Haskell
.
Universal
quantification
the
primary
mechanism
of
encoding
polymorphism
in
Haskell
.
The
essence
of
universal
quantification
is
that
we
can
express
functions
which
operate
the
same
way
for
a
set
of
types
and
whose
function
behavior
is
entirely
determined
only
by
the
behavior
of
all
types
in
this
span
.
Normally
quantifiers
are
omitted
in
type
signatures
since
in
Haskell
'
s
vanilla
surface
language
it
is
unambiguous
to
assume
to
that
free
type
variables
are
universally
quantified
.
A
universally
quantified
type
-
variable
actually
implies
quite
a
few
rather
deep
properties
about
the
implementation
of
a
function
that
can
be
deduced
from
its
type
signature
.
For
instance
the
identity
function
in
Haskell
is
guaranteed
to
only
have
one
implementation
since
the
only
information
that
the
information
that
can
present
in
the
body
The
free
theorem
of
fmap
:
See
:
Theorems
for
Free
Hindley
-
Milner
type
system
The
Hindley
-
Milner
type
system
is
historically
important
as
one
of
the
first
typed
lambda
calculi
that
admitted
both
polymorphism
and
a
variety
of
inference
techniques
that
could
always
decide
principal
types
.
In
an
implementation
the
function
generalize
converts
all
type
variables
within
the
type
into
polymorphic
type
variables
yielding
a
type
scheme
.
The
function
instantiate
maps
a
scheme
to
a
type
but
with
any
polymorphic
variables
converted
into
unbound
type
variables
.
System
-
F
is
the
type
system
that
underlies
Haskell
.
System
-
F
subsumes
the
HM
type
system
in
the
sense
that
every
type
expressible
in
HM
can
be
expressed
within
System
-
F
.
System
-
F
is
sometimes
referred
to
in
texts
as
the
Girald
-
Reynolds
polymorphic
lambda
calculus
or
second
-
order
lambda
calculus
.
An
example
with
equivalents
of
GHC
Core
in
comments
:
Normally
when
Haskell
'
s
typechecker
infers
a
type
signature
it
places
all
quantifiers
of
type
variables
at
the
outermost
position
such
that
no
quantifiers
appear
within
the
body
of
the
type
expression
called
the
prenex
restriction
.
This
restricts
an
entire
class
of
type
signatures
that
would
otherwise
be
expressible
within
System
-
F
but
has
the
benefit
of
making
inference
much
easier
.
-
XRankNTypes
loosens
the
prenex
restriction
such
that
we
may
explicitly
place
quantifiers
within
the
body
of
the
type
.
The
bad
news
is
that
the
general
problem
of
inference
in
this
relaxed
system
is
undecidable
in
general
so
we
'
re
required
to
explicitly
annotate
functions
which
use
RankNTypes
or
they
are
otherwise
inferred
as
rank
1
and
may
not
typecheck
at
all
.
Of
important
note
is
that
the
type
variables
bound
by
an
explicit
quantifier
in
a
higher
ranked
type
may
not
escape
their
enclosing
scope
.
The
typechecker
will
explicitly
enforce
this
by
enforcing
that
variables
bound
inside
of
rank
-
n
types
(
called
skolem
constants
)
will
not
unify
with
free
meta
type
variables
inferred
by
the
inference
engine
.
In
this
example
in
order
for
the
expression
to
be
well
typed
f
would
necessarily
have
(
Int
-&
gt
;
Int
)
which
implies
that
a
~
Int
over
the
whole
type
but
since
a
is
bound
under
the
quantifier
it
must
not
be
unified
with
Int
and
so
the
typechecker
must
fail
with
a
skolem
capture
error
.
This
can
actually
be
used
for
our
advantage
to
enforce
several
types
of
invariants
about
scope
and
use
of
specific
type
variables
.
For
example
the
ST
monad
uses
a
second
rank
type
to
prevent
the
capture
of
references
between
ST
monads
with
separate
state
threads
where
the
s
type
variable
is
bound
within
a
rank
-
2
type
and
cannot
escape
statically
guaranteeing
that
the
implementation
details
of
the
ST
internals
can
'
t
leak
out
and
thus
ensuring
its
referential
transparency
.
An
existential
type
is
a
pair
of
a
type
and
a
term
with
a
special
set
of
packing
and
unpacking
semantics
.
The
type
of
the
value
encoded
in
the
existential
is
known
by
the
producer
but
not
by
the
consumer
of
the
existential
value
.
The
existential
over
SBox
gathers
a
collection
of
values
defined
purely
in
terms
of
their
Show
interface
and
an
opaque
pointer
no
other
information
is
available
about
the
values
and
they
can
'
t
be
accessed
or
unpacked
in
any
other
way
.
Passing
around
existential
types
allows
us
to
hide
information
from
consumers
of
data
types
and
restrict
the
behavior
that
functions
can
use
.
Passing
records
around
with
existential
variables
allows
a
type
to
be
"
bundled
"
with
a
fixed
set
of
functions
that
operate
over
its
hidden
internals
.
This
is
an
advanced
section
and
is
not
typically
necessary
to
write
Haskell
.
Although
extremely
brittle
GHC
also
has
limited
support
for
impredicative
polymorphism
which
allows
instantiating
type
variable
with
a
polymorphic
type
.
Implied
is
that
this
loosens
the
restriction
that
quantifiers
must
precede
arrow
types
and
now
they
may
be
placed
inside
of
type
-
constructors
.
Use
of
this
extension
is
very
rare
and
there
is
some
consideration
that
-
XImpredicativeTypes
is
fundamentally
broken
.
Although
GHC
is
very
liberal
about
telling
us
to
enable
it
when
one
accidentally
makes
a
typo
in
a
type
signature
!
Some
notable
trivia
the
($)
operator
is
wired
into
GHC
in
a
very
special
way
as
to
allow
impredicative
instantiation
of
runST
to
be
applied
via
($)
by
special
-
casing
the
($)
operator
only
when
used
for
the
ST
monad
.
If
this
sounds
like
an
ugly
hack
it
'
s
because
it
is
but
a
rather
convenient
hack
.
For
example
if
we
define
a
function
apply
which
should
behave
identically
to
($)
we
'
ll
get
an
error
about
polymorphic
instantiation
even
though
they
are
defined
identically
!
See
:
Normally
the
type
variables
used
within
the
toplevel
signature
for
a
function
are
only
scoped
to
the
type
-
signature
and
not
the
body
of
the
function
and
its
rigid
signatures
over
terms
and
let
/
where
clauses
.
Enabling
-
XScopedTypeVariables
loosens
this
restriction
allowing
the
type
variables
mentioned
in
the
toplevel
to
be
scoped
within
the
value
-
level
body
of
a
function
and
all
signatures
contained
therein
.
Generalized
Algebraic
Data
types
(
GADTs
)
are
an
extension
to
algebraic
datatypes
that
allow
us
to
qualify
the
constructors
to
datatypes
with
type
equality
constraints
allowing
a
class
of
types
that
are
not
expressible
using
vanilla
ADTs
.
-
XGADTs
implicitly
enables
an
alternative
syntax
for
datatype
declarations
(
-
XGADTSyntax
)
such
that
the
following
declarations
are
equivalent
:
For
an
example
use
consider
the
data
type
Term
we
have
a
term
in
which
we
Succ
which
takes
a
Term
parameterized
by
a
which
span
all
types
.
Problems
arise
between
the
clash
whether
(
a
~
Bool
)
or
(
a
~
Int
)
when
trying
to
write
the
evaluator
.
And
we
admit
the
construction
of
meaningless
terms
which
forces
more
error
handling
cases
.
Using
a
GADT
we
can
express
the
type
invariants
for
our
language
(
i
.
e
.
only
type
-
safe
expressions
are
representable
).
Pattern
matching
on
this
GADTs
then
carries
type
equality
constraints
without
the
need
for
explicit
tags
.
This
time
around
:
Explicit
equality
constraints
(
a
~
b
)
can
be
added
to
a
function
'
s
context
.
For
example
the
following
expand
out
to
the
same
types
.
This
is
effectively
the
implementation
detail
of
what
GHC
is
doing
behind
the
scenes
to
implement
GADTs
(
implicitly
passing
and
threading
equality
terms
around
).
If
we
wanted
we
could
do
the
same
setup
that
GHC
does
just
using
equality
constraints
and
existential
quantification
.
Indeed
the
internal
representation
of
GADTs
is
as
regular
algebraic
datatypes
that
carry
coercion
evidence
as
arguments
.
In
the
presence
of
GADTs
inference
becomes
intractable
in
many
cases
often
requiring
an
explicit
annotation
.
For
example
f
can
either
have
T
a
-&
gt
;
[
a
]
or
T
a
-&
gt
;
[
Int
]
and
neither
is
principal
.
Haskell
'
s
kind
system
(
i
.
e
.
the
"
type
of
the
types
")
is
a
system
consisting
the
single
kind
*
and
an
arrow
kind
-&
gt
;
.
There
are
in
fact
some
extensions
to
this
system
that
will
be
covered
later
(
see
:
PolyKinds
and
Unboxed
types
in
later
sections
)
but
most
kinds
in
everyday
code
are
simply
either
stars
or
arrows
.
With
the
KindSignatures
extension
enabled
we
can
now
annotate
top
level
type
signatures
with
their
explicit
kinds
bypassing
the
normal
kind
inference
procedures
.
On
top
of
default
GADT
declaration
we
can
also
constrain
the
parameters
of
the
GADT
to
specific
kinds
.
For
basic
usage
Haskell
'
s
kind
inference
can
deduce
this
reasonably
well
but
combined
with
some
other
type
system
extensions
that
extend
the
kind
system
this
becomes
essential
.
The
Void
type
is
the
type
with
no
inhabitants
.
It
unifies
only
with
itself
.
Using
a
newtype
wrapper
we
can
create
a
type
where
recursion
makes
it
impossible
to
construct
an
inhabitant
.
Or
using
-
XEmptyDataDecls
we
can
also
construct
the
uninhabited
type
equivalently
as
a
data
declaration
with
no
constructors
.
The
only
inhabitant
of
both
of
these
types
is
a
diverging
term
like
(
undefined
).
Phantom
types
are
parameters
that
appear
on
the
left
hand
side
of
a
type
declaration
but
which
are
not
constrained
by
the
values
of
the
types
inhabitants
.
They
are
effectively
slots
for
us
to
encode
additional
information
at
the
type
-
level
.
Notice
the
type
variable
tag
does
not
appear
in
the
right
hand
side
of
the
declaration
.
Using
this
allows
us
to
express
invariants
at
the
type
-
level
that
need
not
manifest
at
the
value
-
level
.
We
'
re
effectively
programming
by
adding
extra
information
at
the
type
-
level
.
Consider
the
case
of
using
newtypes
to
statically
distinguish
between
plaintext
and
cryptotext
.
Using
phantom
types
we
use
an
extra
parameter
.
Using
-
XEmptyDataDecls
can
be
a
powerful
combination
with
phantom
types
that
contain
no
value
inhabitants
and
are
"
anonymous
types
".
See
:
Fun
with
Phantom
Types
This
is
an
advanced
section
and
is
not
typically
necessary
to
write
Haskell
.
With
a
richer
language
for
datatypes
we
can
express
terms
that
witness
the
relationship
between
terms
in
the
constructors
for
example
we
can
now
express
a
term
which
expresses
propositional
equality
between
two
types
.
The
type
Eql
a
b
is
a
proof
that
types
a
and
b
are
equal
by
pattern
matching
on
the
single
Refl
constructor
we
introduce
the
equality
constraint
into
the
body
of
the
pattern
match
.
As
of
GHC
7
.
8
these
constructors
and
functions
are
included
in
the
Prelude
in
the
Data
.
Type
.
Equality
module
.
The
lambda
calculus
forms
the
theoretical
and
practical
foundation
for
many
languages
.
At
the
heart
of
every
calculus
is
three
components
:
There
are
many
different
ways
of
modeling
these
constructions
and
data
structure
representations
but
they
all
more
or
less
contain
these
three
elements
.
For
example
a
lambda
calculus
that
uses
String
names
on
lambda
binders
and
variables
might
be
written
like
the
following
:
A
lambda
expression
in
which
all
variables
that
appear
in
the
body
of
the
expression
are
referenced
in
an
outer
lambda
binder
is
said
to
be
closed
while
an
expression
with
unbound
free
variables
is
open
.
Higher
Order
Abstract
Syntax
(
HOAS
)
is
a
technique
for
implementing
the
lambda
calculus
in
a
language
where
the
binders
of
the
lambda
expression
map
directly
onto
lambda
binders
of
the
host
language
(
i
.
e
.
Haskell
)
to
give
us
substitution
machinery
in
our
custom
language
by
exploiting
Haskell
'
s
implementation
.
Pretty
printing
HOAS
terms
can
also
be
quite
complicated
since
the
body
of
the
function
is
under
a
Haskell
lambda
binder
.
A
slightly
different
form
of
HOAS
called
PHOAS
uses
lambda
datatype
parameterized
over
the
binder
type
.
In
this
form
evaluation
requires
unpacking
into
a
separate
Value
type
to
wrap
the
lambda
expression
.
See
:
Using
typeclasses
we
can
implement
a
final
interpreter
which
models
a
set
of
extensible
terms
using
functions
bound
to
typeclasses
rather
than
data
constructors
.
Instances
of
the
typeclass
form
interpreters
over
these
terms
.
For
example
we
can
write
a
small
language
that
includes
basic
arithmetic
and
then
retroactively
extend
our
expression
language
with
a
multiplication
operator
without
changing
the
base
.
At
the
same
time
our
interpreter
logic
remains
invariant
under
extension
with
new
expressions
.
Writing
an
evaluator
for
the
lambda
calculus
can
likewise
also
be
modeled
with
a
final
interpreter
and
a
Identity
functor
.
See
:
Typed
Tagless
Interpretations
and
Typed
Compilation
The
usual
hand
-
wavy
of
describing
algebraic
datatypes
is
to
indicate
the
how
natural
correspondence
between
sum
types
product
types
and
polynomial
expressions
arises
.
Intuitively
it
follows
the
notion
that
the
cardinality
of
set
of
inhabitants
of
a
type
can
always
be
given
as
a
function
of
the
number
of
its
holes
.
A
product
type
admits
a
number
of
inhabitants
as
a
function
of
the
product
(
i
.
e
.
cardinality
of
the
Cartesian
product
a
sum
type
as
the
sum
of
its
holes
and
a
function
type
as
the
exponential
of
the
span
of
the
domain
and
codomain
.
Recursive
types
are
correspond
to
infinite
series
of
these
terms
.
See
:
Species
and
Functors
and
Types
Oh
My
!
This
is
an
advanced
section
and
is
not
typically
necessary
to
write
Haskell
.
The
initial
algebra
approach
differs
from
the
final
interpreter
approach
in
that
we
now
represent
our
terms
as
algebraic
datatypes
and
the
interpreter
implements
recursion
and
evaluation
occurs
through
pattern
matching
.
In
Haskell
a
F
-
algebra
is
a
functor
f
a
together
with
a
function
f
a
-&
gt
;
a
.
A
coalgebra
reverses
the
function
.
For
a
functor
f
we
can
form
its
recursive
unrolling
using
the
recursive
Fix
newtype
wrapper
.
In
this
form
we
can
write
down
a
generalized
fold
/
unfold
function
that
are
datatype
generic
and
written
purely
in
terms
of
the
recursing
under
the
functor
.
We
call
these
functions
catamorphisms
and
anamorphisms
.
Notice
especially
that
the
types
of
these
two
functions
simply
reverse
the
direction
of
arrows
.
Interpreted
in
another
way
they
transform
an
algebra
/
coalgebra
which
defines
a
flat
structure
-
preserving
mapping
between
Fix
f
f
into
a
function
which
either
rolls
or
unrolls
the
fixpoint
.
What
is
particularly
nice
about
this
approach
is
that
the
recursion
is
abstracted
away
inside
the
functor
definition
and
we
are
free
to
just
implement
the
flat
transformation
logic
!
For
example
a
construction
of
the
natural
numbers
in
this
form
:
Or
for
example
an
interpreter
for
a
small
expression
language
that
depends
on
a
scoping
dictionary
.
What
'
s
especially
nice
about
this
approach
is
how
naturally
catamorphisms
compose
into
efficient
composite
transformations
.
This
is
an
advanced
section
and
is
not
typically
necessary
to
write
Haskell
.
The
code
from
the
F
-
algebra
examples
above
is
implemented
in
an
off
-
the
-
shelf
library
called
recursion
-
schemes
.
An
example
of
usage
:
See
:
TODO
This
is
an
advanced
section
and
is
not
typically
necessary
to
write
Haskell
.
GHC
itself
can
actually
interpret
arbitrary
Haskell
source
on
the
fly
by
hooking
into
the
GHC
'
s
bytecode
interpreter
(
the
same
used
for
GHCi
).
The
hint
package
allows
us
to
parse
typecheck
and
evaluate
arbitrary
strings
into
arbitrary
Haskell
programs
and
evaluate
them
.
This
is
generally
not
a
wise
thing
to
build
a
library
around
unless
of
course
the
purpose
of
the
program
is
itself
to
evaluate
arbitrary
Haskell
code
(
something
like
an
online
Haskell
shell
or
the
likes
).
Both
hint
and
mueval
do
effectively
the
same
task
designed
around
slightly
different
internals
of
the
GHC
Api
.
See
:
Contrary
to
a
lot
of
misinformation
unit
testing
in
Haskell
is
quite
common
and
robust
.
Although
generally
speaking
unit
tests
tend
to
be
of
less
importance
in
Haskell
since
the
type
system
makes
an
enormous
amount
of
invalid
programs
completely
inexpressible
by
construction
.
Unit
tests
tend
to
be
written
later
in
the
development
lifecycle
and
generally
tend
to
be
about
the
core
logic
of
the
program
and
not
the
intermediate
plumbing
.
A
prominent
school
of
thought
on
Haskell
library
design
tends
to
favor
constructing
programs
built
around
strong
equation
laws
which
guarantee
strong
invariants
about
program
behavior
under
composition
.
Many
of
the
testing
tools
are
built
around
this
style
of
design
.
Probably
the
most
famous
Haskell
library
QuickCheck
is
a
testing
framework
for
generating
large
random
tests
for
arbitrary
functions
automatically
based
on
the
types
of
their
arguments
.
The
test
data
generator
can
be
extended
with
custom
types
and
refined
with
predicates
that
restrict
the
domain
of
cases
to
test
.
See
:
QuickCheck
:
An
Automatic
Testing
Tool
for
Haskell
Like
QuickCheck
SmallCheck
is
a
property
testing
system
but
instead
of
producing
random
arbitrary
test
data
it
instead
enumerates
a
deterministic
series
of
test
data
to
a
fixed
depth
.
It
is
useful
to
generate
test
cases
over
all
possible
inputs
of
a
program
up
to
some
depth
.
Just
like
for
QuickCheck
we
can
implement
series
instances
for
our
custom
datatypes
.
For
example
there
is
no
default
instance
for
Vector
so
let
'
s
implement
one
:
SmallCheck
can
also
use
Generics
to
derive
Serial
instances
for
example
to
enumerate
all
trees
of
a
certain
depth
we
might
use
:
Using
the
QuickCheck
arbitrary
machinery
we
can
also
rather
remarkably
enumerate
a
large
number
of
combinations
of
functions
to
try
and
deduce
algebraic
laws
from
trying
out
inputs
for
small
cases
.
Of
course
the
fundamental
limitation
of
this
approach
is
that
a
function
may
not
exhibit
any
interesting
properties
for
small
cases
or
for
simple
function
compositions
.
So
in
general
case
this
approach
won
'
t
work
but
practically
it
still
quite
useful
.
Running
this
we
rather
see
it
is
able
to
deduce
most
of
the
laws
for
list
functions
.
Keep
in
mind
the
rather
remarkable
fact
that
this
is
all
deduced
automatically
from
the
types
alone
!
Criterion
is
a
statistically
aware
benchmarking
tool
.
Criterion
can
also
generate
a
HTML
page
containing
the
benchmark
results
plotted
Tasty
combines
all
of
the
testing
frameworks
into
a
common
API
for
forming
runnable
batches
of
tests
and
collecting
the
results
.
Often
in
the
process
of
testing
IO
heavy
code
we
'
ll
need
to
redirect
stdout
to
compare
it
some
known
quantity
.
The
silently
package
allows
us
to
capture
anything
done
to
stdout
across
any
library
inside
of
IO
block
and
return
the
result
to
the
test
runner
.
Resolution
of
vanilla
Haskell
98
typeclasses
proceeds
via
very
simple
context
reduction
that
minimizes
interdependency
between
predicates
resolves
superclasses
and
reduces
the
types
to
head
normal
form
.
For
example
:
If
a
single
parameter
typeclass
expresses
a
property
of
a
type
(
i
.
e
.
it
'
s
in
a
class
or
not
in
class
)
then
a
multiparameter
typeclass
expresses
relationships
between
types
.
For
example
if
we
wanted
to
express
the
relation
a
type
can
be
converted
to
another
type
we
might
use
a
class
like
:
Of
course
now
our
instances
for
Convertible
Int
are
not
unique
anymore
so
there
no
longer
exists
a
nice
procedure
for
determining
the
inferred
type
of
b
from
just
a
.
To
remedy
this
let
'
s
add
a
functional
dependency
a
-&
gt
;
b
which
tells
GHC
that
an
instance
a
uniquely
determines
the
instance
that
b
can
be
.
So
we
'
ll
see
that
our
two
instances
relating
Int
to
both
Integer
and
Char
conflict
.
Now
there
'
s
a
simpler
procedure
for
determining
instances
uniquely
and
multiparameter
typeclasses
become
more
usable
and
inferable
again
.
Effectively
a
functional
dependency
|
a
-&
gt
;
b
says
that
we
can
'
t
define
multiple
multiparamater
typeclass
instances
with
the
same
a
but
different
b
.
Now
let
'
s
make
things
not
so
simple
.
Turning
on
UndecidableInstances
loosens
the
constraint
on
context
reduction
that
can
only
allow
constraints
of
the
class
to
become
structural
smaller
than
its
head
.
As
a
result
implicit
computation
can
now
occur
within
in
the
type
class
instance
search
.
Combined
with
a
type
-
level
representation
of
Peano
numbers
we
find
that
we
can
encode
basic
arithmetic
at
the
type
-
level
.
If
the
typeclass
contexts
look
similar
to
Prolog
you
'
re
not
wrong
if
one
reads
the
contexts
qualifier
(=&
gt
;)
backwards
as
turnstiles
:-
then
it
'
s
precisely
the
same
equations
.
This
is
kind
of
abusing
typeclasses
and
if
used
carelessly
it
can
fail
to
terminate
or
overflow
at
compile
-
time
.
UndecidableInstances
shouldn
'
t
be
turned
on
without
careful
forethought
about
what
it
implies
.
Type
families
allows
us
to
write
functions
in
the
type
domain
which
take
types
as
arguments
which
can
yield
either
types
or
values
indexed
on
their
arguments
which
are
evaluated
at
compile
-
time
in
during
typechecking
.
Type
families
come
in
two
varieties
:
data
families
and
type
synonym
families
.
First
let
'
s
look
at
type
synonym
families
there
are
two
equivalent
syntactic
ways
of
constructing
them
.
Either
as
associated
type
families
declared
within
a
typeclass
or
as
standalone
declarations
at
the
toplevel
.
The
following
forms
are
semantically
equivalent
although
the
unassociated
form
is
strictly
more
general
:
Using
the
same
example
we
used
for
multiparameter
+
functional
dependencies
illustration
we
see
that
there
is
a
direct
translation
between
the
type
family
approach
and
functional
dependencies
.
These
two
approaches
have
the
same
expressive
power
.
An
associated
type
family
can
be
queried
using
the
:
kind
!
command
in
GHCi
.
Data
families
on
the
other
hand
allow
us
to
create
new
type
parameterized
data
constructors
.
Normally
we
can
only
define
typeclasses
functions
whose
behavior
results
in
a
uniform
result
which
is
purely
a
result
of
the
typeclasses
arguments
.
With
data
families
we
can
allow
specialized
behavior
indexed
on
the
type
.
For
example
if
we
wanted
to
create
more
complicated
vector
structures
(
bit
-
masked
vectors
vectors
of
tuples
...
)
that
exposed
a
uniform
API
but
internally
handled
the
differences
in
their
data
layout
we
can
use
data
families
to
accomplish
this
:
The
type
level
functions
defined
by
type
-
families
are
not
necessarily
injective
the
function
may
map
two
distinct
input
types
to
the
same
output
type
.
This
differs
from
the
behavior
of
type
constructors
(
which
are
also
type
-
level
functions
)
which
are
injective
.
For
example
for
the
constructor
Maybe
Maybe
t
1
=
Maybe
t
2
implies
that
t
1
=
t
2
.
This
is
an
advanced
section
and
is
not
typically
necessary
to
write
Haskell
.
Roles
are
a
further
level
of
specification
for
type
variables
parameters
of
datatypes
.
They
were
added
to
the
language
to
address
a
rather
nasty
and
long
-
standing
bug
around
the
correspondence
between
a
newtype
and
its
runtime
representation
.
The
fundamental
distinction
that
roles
introduce
is
there
are
two
notions
of
type
equality
.
Two
types
are
nominally
equal
when
they
have
the
same
name
.
This
is
the
usual
equality
in
Haskell
or
Core
.
Two
types
are
representationally
equal
when
they
have
the
same
representation
.
(
If
a
type
is
higher
-
kinded
all
nominally
equal
instantiations
lead
to
representationally
equal
types
.)
Roles
are
normally
inferred
automatically
but
with
the
RoleAnnotations
extension
they
can
be
manually
annotated
.
Except
in
rare
cases
this
should
not
be
necessary
although
it
is
helpful
to
know
what
is
going
on
under
the
hood
.
See
:
Using
type
families
mono
-
traversable
generalizes
the
notion
of
Functor
Foldable
and
Traversable
to
include
both
monomorphic
and
polymorphic
types
.
For
example
the
text
type
normally
does
not
admit
any
of
these
type
-
classes
since
but
now
we
can
write
down
the
instances
that
model
the
interface
of
Foldable
and
Traversable
.
See
:
From
Semigroups
to
Monads
Rather
than
having
degenerate
(
and
often
partial
)
cases
of
many
of
the
Prelude
functions
to
accommodate
the
null
case
of
lists
it
is
sometimes
preferable
to
statically
enforce
empty
lists
from
even
being
constructed
as
an
inhabitant
of
a
type
.
In
GHC
7
.
8
-
XOverloadedLists
can
be
used
to
avoid
the
extraneous
fromList
and
toList
conversions
.
This
is
an
advanced
section
and
is
not
typically
necessary
to
write
Haskell
.
One
of
most
deep
results
in
computer
science
the
Curryâ
Howard
correspondence
is
the
relation
that
logical
propositions
can
be
modeled
by
types
and
instantiating
those
types
constitute
proofs
of
these
propositions
.
Programs
are
proofs
and
proofs
are
programs
.
In
dependently
typed
languages
we
can
exploit
this
result
to
its
full
extent
in
Haskell
we
don
'
t
have
the
strength
that
dependent
types
provide
but
can
still
prove
trivial
results
.
For
example
now
we
can
model
a
type
level
function
for
addition
and
provide
a
small
proof
that
zero
is
an
additive
identity
.
Translated
into
Haskell
our
axioms
are
simply
type
definitions
and
recursing
over
the
inductive
datatype
constitutes
the
inductive
step
of
our
proof
.
Using
the
TypeOperators
extension
we
can
also
use
infix
notation
at
the
type
-
level
.
This
is
an
advanced
section
and
is
not
typically
necessary
to
write
Haskell
.
GHC
'
s
implementation
also
exposes
the
predicates
that
bound
quantifiers
in
Haskell
as
types
themselves
with
the
-
XConstraintKinds
extension
enabled
.
Using
this
extension
we
work
with
constraints
as
first
class
types
.
The
empty
constraint
set
is
indicated
by
()
::
Constraint
.
For
a
contrived
example
if
we
wanted
to
create
a
generic
Sized
class
that
carried
with
it
constraints
on
the
elements
of
the
container
in
question
we
could
achieve
this
quite
simply
using
type
families
.
One
use
-
case
of
this
is
to
capture
the
typeclass
dictionary
constrained
by
a
function
and
reify
it
as
a
value
.
Type
families
historically
have
not
been
injective
i
.
e
.
they
are
not
guaranteed
to
maps
distinct
elements
of
its
arguments
to
the
same
element
of
its
result
.
The
syntax
is
similar
to
the
multiparmater
typeclass
functional
dependencies
in
that
the
resulting
type
is
uniquely
determined
by
a
set
of
the
type
families
parameters
.
See
:
What
are
higher
kinded
types
?
The
kind
system
in
Haskell
is
unique
by
contrast
with
most
other
languages
in
that
it
allows
datatypes
to
be
constructed
which
take
types
and
type
constructor
to
other
types
.
Such
a
system
is
said
to
support
higher
kinded
types
.
All
kind
annotations
in
Haskell
necessarily
result
in
a
kind
*
although
any
terms
to
the
left
may
be
higher
-
kinded
(
*
-&
gt
;
*
).
The
common
example
is
the
Monad
which
has
kind
*
-&
gt
;
*
.
But
we
have
also
seen
this
higher
-
kindedness
in
free
monads
.
For
instance
Cofree
Maybe
a
for
some
monokinded
type
a
models
a
non
-
empty
list
with
Maybe
::
*
-&
gt
;
*
.
This
is
an
advanced
section
knowledge
of
kind
polymorphism
is
not
typically
necessary
to
write
Haskell
.
The
regular
value
level
function
which
takes
a
function
and
applies
it
to
an
argument
is
universally
generalized
over
in
the
usual
Hindley
-
Milner
way
.
But
when
we
do
the
same
thing
at
the
type
-
level
we
see
we
lose
information
about
the
polymorphism
of
the
constructor
applied
.
Turning
on
-
XPolyKinds
allows
polymorphic
variables
at
the
kind
level
as
well
.
Using
the
polykinded
Proxy
type
allows
us
to
write
down
type
class
functions
over
constructors
of
arbitrary
kind
arity
.
For
example
we
can
write
down
the
polymorphic
S
K
combinators
at
the
type
level
now
.
This
is
an
advanced
section
knowledge
of
kind
data
kinds
is
not
typically
necessary
to
write
Haskell
.
The
-
XDataKinds
extension
allows
us
to
use
refer
to
constructors
at
the
value
level
and
the
type
level
.
Consider
a
simple
sum
type
:
With
the
extension
enabled
we
see
that
our
type
constructors
are
now
automatically
promoted
so
that
L
or
R
can
be
viewed
as
both
a
data
constructor
of
the
type
S
or
as
the
type
L
with
kind
S
.
Promoted
data
constructors
can
referred
to
in
type
signatures
by
prefixing
them
with
a
single
quote
.
Also
of
importance
is
that
these
promoted
constructors
are
not
exported
with
a
module
by
default
but
type
synonym
instances
can
be
created
for
the
ticked
promoted
types
and
exported
directly
.
Combining
this
with
type
families
we
see
we
can
write
meaningful
meaningful
type
-
level
functions
by
lifting
types
to
the
kind
level
.
Using
this
new
structure
we
can
create
a
Vec
type
which
is
parameterized
by
its
length
as
well
as
its
element
type
now
that
we
have
a
kind
language
rich
enough
to
encode
the
successor
type
in
the
kind
signature
of
the
generalized
algebraic
datatype
.
So
now
if
we
try
to
zip
two
Vec
types
with
the
wrong
shape
then
we
get
an
error
at
compile
-
time
about
the
off
-
by
-
one
error
.
The
same
technique
we
can
use
to
create
a
container
which
is
statically
indexed
by
an
empty
or
non
-
empty
flag
such
that
if
we
try
to
take
the
head
of
an
empty
list
we
'
ll
get
a
compile
-
time
error
or
stated
equivalently
we
have
an
obligation
to
prove
to
the
compiler
that
the
argument
we
hand
to
the
head
function
is
non
-
empty
.
See
:
GHC
'
s
type
literals
can
also
be
used
in
place
of
explicit
Peano
arithmetic
.
GHC
7
.
6
is
very
conservative
about
performing
reduction
GHC
7
.
8
is
much
less
so
and
will
can
solve
many
typelevel
constraints
involving
natural
numbers
but
sometimes
still
needs
a
little
coaxing
.
See
:
Type
-
Level
Literals
As
of
GHC
8
.
0
we
have
the
capacity
to
provide
custom
type
error
using
type
families
.
The
messages
themselves
hook
into
GHC
and
expressed
using
the
small
datatype
found
in
GHC
.
TypeLits
If
one
of
these
expressions
is
found
in
the
signature
of
an
expression
GHC
reports
an
error
message
of
the
form
:
A
less
contrived
example
would
be
creating
a
type
-
safe
embedded
DSL
that
enforces
invariants
about
the
semantics
at
the
type
-
level
.
We
'
ve
been
able
to
do
this
sort
of
thing
using
GADTs
and
type
-
families
for
a
while
but
the
error
reporting
has
been
horrible
.
With
8
.
0
we
can
have
type
-
families
that
emit
useful
type
errors
that
reflect
what
actually
goes
wrong
and
integrate
this
inside
of
GHC
.
Continuing
with
the
theme
of
building
more
elaborate
proofs
in
Haskell
GHC
7
.
8
recently
shipped
with
the
Data
.
Type
.
Equality
module
which
provides
us
with
an
extended
set
of
type
-
level
operations
for
expressing
the
equality
of
types
as
values
constraints
and
promoted
booleans
.
With
this
we
have
a
much
stronger
language
for
writing
restrictions
that
can
be
checked
at
a
compile
-
time
and
a
mechanism
that
will
later
allow
us
to
write
more
advanced
proofs
.
Using
kind
polymorphism
with
phantom
types
allows
us
to
express
the
Proxy
type
which
is
inhabited
by
a
single
constructor
with
no
arguments
but
with
a
polykinded
phantom
type
variable
which
carries
an
arbitrary
type
.
In
cases
where
we
'
d
normally
pass
around
a
undefined
as
a
witness
of
a
typeclass
dictionary
we
can
instead
pass
a
Proxy
object
which
carries
the
phantom
type
without
the
need
for
the
bottom
.
Using
scoped
type
variables
we
can
then
operate
with
the
phantom
paramater
and
manipulate
wherever
is
needed
.
We
'
ve
seen
constructors
promoted
using
DataKinds
but
just
like
at
the
value
-
level
GHC
also
allows
us
some
syntactic
sugar
for
list
and
tuples
instead
of
explicit
cons
'
ing
and
pair
'
ing
.
This
is
enabled
with
the
-
XTypeOperators
extension
which
introduces
list
syntax
and
tuples
of
arbitrary
arity
at
the
type
-
level
.
Using
this
we
can
construct
all
variety
of
composite
type
-
level
objects
.
This
is
an
advanced
section
knowledge
of
singletons
is
not
typically
necessary
to
write
Haskell
.
A
singleton
type
is
a
type
with
a
single
value
inhabitant
.
Singleton
types
can
be
constructed
in
a
variety
of
ways
using
GADTs
or
with
data
families
.
Promoted
Naturals
Promoted
Booleans
Promoted
Maybe
Singleton
types
are
an
integral
part
of
the
small
cottage
industry
of
faking
dependent
types
in
Haskell
i
.
e
.
constructing
types
with
terms
predicated
upon
values
.
Singleton
types
are
a
way
of
"
cheating
"
by
modeling
the
map
between
types
and
values
as
a
structural
property
of
the
type
.
The
builtin
singleton
types
provided
in
GHC
.
TypeLits
have
the
useful
implementation
that
type
-
level
values
can
be
reflected
to
the
value
-
level
and
back
up
to
the
type
-
level
albeit
under
an
existential
.
In
the
type
families
we
'
ve
used
so
far
(
called
open
type
families
)
there
is
no
notion
of
ordering
of
the
equations
involved
in
the
type
-
level
function
.
The
type
family
can
be
extended
at
any
point
in
the
code
resolution
simply
proceeds
sequentially
through
the
available
definitions
.
Closed
type
-
families
allow
an
alternative
declaration
that
allows
for
a
base
case
for
the
resolution
allowing
us
to
actually
write
recursive
functions
over
types
.
For
example
consider
if
we
wanted
to
write
a
function
which
counts
the
arguments
in
the
type
of
a
function
and
reifies
at
the
value
-
level
.
The
variety
of
functions
we
can
now
write
down
are
rather
remarkable
allowing
us
to
write
meaningful
logic
at
the
type
level
.
The
results
of
type
family
functions
need
not
necessarily
be
kinded
as
(*)
either
.
For
example
using
Nat
or
Constraint
is
permitted
.
This
is
an
advanced
section
and
is
not
typically
necessary
to
write
Haskell
.
Just
as
typeclasses
are
normally
indexed
on
types
type
families
can
also
be
indexed
on
kinds
with
the
kinds
given
as
explicit
kind
signatures
on
type
variables
.
Since
record
is
fundamentally
no
different
from
the
tuple
we
can
also
do
the
same
kind
of
construction
over
record
field
names
.
Notably
this
approach
is
mostly
just
all
boilerplate
class
instantiation
which
could
be
abstracted
away
using
TemplateHaskell
or
a
Generic
deriving
.
This
is
an
advanced
section
and
is
not
typically
necessary
to
write
Haskell
.
A
heterogeneous
list
is
a
cons
list
whose
type
statically
encodes
the
ordered
types
of
its
values
.
Of
course
this
immediately
begs
the
question
of
how
to
print
such
a
list
out
to
a
string
in
the
presence
of
type
-
heterogeneity
.
In
this
case
we
can
use
type
-
families
combined
with
constraint
kinds
to
apply
the
Show
over
the
HLists
parameters
to
generate
the
aggregate
constraint
that
all
types
in
the
HList
are
Showable
and
then
derive
the
Show
instance
.
Much
of
this
discussion
of
promotion
begs
the
question
whether
we
can
create
data
structures
at
the
type
-
level
to
store
information
at
compile
-
time
.
For
example
a
type
-
level
association
list
can
be
used
to
model
a
map
between
type
-
level
symbols
and
any
other
promotable
types
.
Together
with
type
-
families
we
can
write
down
type
-
level
traversal
and
lookup
functions
.
If
we
ask
GHC
to
expand
out
the
type
signature
we
can
view
the
explicit
implementation
of
the
type
-
level
map
lookup
function
.
This
is
an
advanced
section
and
is
not
typically
necessary
to
write
Haskell
.
Now
that
we
have
the
length
-
indexed
vector
let
'
s
go
write
the
reverse
function
how
hard
could
it
be
?
So
we
go
and
write
down
something
like
this
:
Running
this
we
find
that
GHC
is
unhappy
about
two
lines
in
the
code
:
As
we
unfold
elements
out
of
the
vector
we
'
ll
end
up
doing
a
lot
of
type
-
level
arithmetic
over
indices
as
we
combine
the
subparts
of
the
vector
backwards
but
as
a
consequence
we
find
that
GHC
will
run
into
some
unification
errors
because
it
doesn
'
t
know
about
basic
arithmetic
properties
of
the
natural
numbers
.
Namely
that
forall
n
.
n
+
0
=
0
and
forall
n
m
.
n
+
(
1
+
m
)
=
1
+
(
n
+
m
)
.
Which
of
course
it
really
shouldn
'
t
be
given
that
we
'
ve
constructed
a
system
at
the
type
-
level
which
intuitively
models
arithmetic
but
GHC
is
just
a
dumb
compiler
it
can
'
t
automatically
deduce
the
isomorphism
between
natural
numbers
and
Peano
numbers
.
So
at
each
of
these
call
sites
we
now
have
a
proof
obligation
to
construct
proof
terms
.
Recall
from
our
discussion
of
propositional
equality
from
GADTs
that
we
actually
have
such
machinery
to
construct
this
now
.
One
might
consider
whether
we
could
avoid
using
the
singleton
trick
and
just
use
type
-
level
natural
numbers
and
technically
this
approach
should
be
feasible
although
it
seems
that
the
natural
number
solver
in
GHC
7
.
8
can
decide
some
properties
but
not
the
ones
needed
to
complete
the
natural
number
proofs
for
the
reverse
functions
.
Caveat
should
be
that
there
might
be
a
way
to
do
this
in
GHC
7
.
6
that
I
'
m
not
aware
of
.
In
GHC
7
.
10
there
are
some
planned
changes
to
solver
that
should
be
able
to
resolve
these
issues
.
In
particular
there
are
plans
to
allow
pluggable
type
system
extensions
that
could
outsource
these
kind
of
problems
to
third
party
SMT
solvers
which
can
solve
these
kind
of
numeric
relations
and
return
this
information
back
to
GHC
'
s
typechecker
.
As
an
aside
this
is
a
direct
transliteration
of
the
equivalent
proof
in
Agda
which
is
accomplished
via
the
same
method
but
without
the
song
and
dance
to
get
around
the
lack
of
dependent
types
.
This
is
an
advanced
section
knowledge
of
LiquidHaskell
is
not
typically
necessary
to
write
Haskell
.
LiquidHaskell
is
an
extension
to
GHC
'
s
typesystem
that
adds
the
capactity
for
refinement
types
using
the
annotation
syntax
.
The
type
signatures
of
functions
can
be
checked
by
the
external
for
richer
type
semantics
than
default
GHC
provides
including
non
-
exhaustive
patterns
and
complex
arithemtic
properties
that
require
external
SMT
solvers
to
verify
.
For
instance
LiquidHaskell
can
statically
verify
that
a
function
that
operates
over
a
Maybe
a
is
always
given
a
Just
or
that
an
arithmetic
functions
always
yields
an
Int
that
is
even
positive
number
.
To
Install
LiquidHaskell
in
Ubuntu
add
the
following
line
to
your
/
etc
/
sources
.
list
:
And
then
install
the
external
SMT
solver
.
Then
clone
the
repo
and
build
it
using
stack
.
Ensure
that
$
HOME
/.
local
/
bin
is
on
your
$
PATH
.
The
module
can
be
run
through
the
solver
using
the
liquid
command
line
tool
.
For
more
extensive
documentation
and
further
use
cases
see
the
official
documentation
:
Haskell
has
several
techniques
for
automatic
generation
of
type
classes
for
a
variety
of
tasks
that
consist
largely
of
boilerplate
code
generation
such
as
:
These
are
achieved
through
several
tools
and
techniques
outlined
in
the
next
few
sections
:
The
Typeable
class
be
used
to
create
runtime
type
information
for
arbitrary
types
.
Using
the
Typeable
instance
allows
us
to
write
down
a
type
safe
cast
function
which
can
safely
use
unsafeCast
and
provide
a
proof
that
the
resulting
type
matches
the
input
.
Of
historical
note
is
that
writing
our
own
Typeable
classes
is
currently
possible
of
GHC
7
.
6
but
allows
us
to
introduce
dangerous
behavior
that
can
cause
crashes
and
shouldn
'
t
be
done
except
by
GHC
itself
.
As
of
7
.
8
GHC
forbids
hand
-
written
Typeable
instances
.
As
of
7
.
10
-
XAutoDeriveDataTypeable
is
enabled
by
default
.
See
:
Typeable
and
Data
in
Haskell
Since
we
have
a
way
of
querying
runtime
type
information
we
can
use
this
machinery
to
implement
a
Dynamic
type
.
This
allows
us
to
box
up
any
monotype
into
a
uniform
type
that
can
be
passed
to
any
function
taking
a
Dynamic
type
which
can
then
unpack
the
underlying
value
in
a
type
-
safe
way
.
In
GHC
7
.
8
the
Typeable
class
is
poly
-
kinded
so
polymorphic
functions
can
be
applied
over
functions
and
higher
kinded
types
.
Use
of
Dynamic
is
somewhat
rare
except
in
odd
cases
that
have
to
deal
with
foreign
memory
and
FFI
interfaces
.
Using
it
for
business
logic
is
considered
a
code
smell
.
Consider
a
more
idiomatic
solution
.
Just
as
Typeable
lets
us
create
runtime
type
information
the
Data
class
allows
us
to
reflect
information
about
the
structure
of
datatypes
to
runtime
as
needed
.
The
types
for
gfoldl
and
gunfold
are
a
little
intimidating
(
and
depend
on
RankNTypes
the
best
way
to
understand
is
to
look
at
some
examples
.
First
the
most
trivial
case
a
simple
sum
type
Animal
would
produce
the
following
code
:
For
a
type
with
non
-
empty
containers
we
get
something
a
little
more
interesting
.
Consider
the
list
type
:
Looking
at
gfoldl
we
see
the
Data
has
an
implementation
of
a
function
for
us
to
walk
an
applicative
over
the
elements
of
the
constructor
by
applying
a
function
k
over
each
element
and
applying
z
at
the
spine
.
For
example
look
at
the
instance
for
a
2
-
tuple
as
well
:
This
is
pretty
neat
now
within
the
same
typeclass
we
have
a
generic
way
to
introspect
any
Data
instance
and
write
logic
that
depends
on
the
structure
and
types
of
its
subterms
.
We
can
now
write
a
function
which
allows
us
to
traverse
an
arbitrary
instance
of
Data
and
twiddle
values
based
on
pattern
matching
on
the
runtime
types
.
So
let
'
s
write
down
a
function
over
which
increments
a
Value
type
for
both
for
n
-
tuples
and
lists
.
We
can
also
write
generic
operations
for
example
to
count
the
number
of
parameters
in
a
data
type
.
Using
the
interface
provided
by
the
Data
we
can
retrieve
the
information
we
need
to
at
runtime
inspect
the
types
of
expressions
and
rewrite
them
collect
terms
and
find
subterms
matching
specific
predicates
.
For
example
consider
we
have
some
custom
collection
of
datatypes
for
which
we
want
to
write
generic
transformations
that
transform
numerical
subexpressions
according
to
set
of
rewrite
rules
.
We
can
use
syb
to
write
the
transformation
rules
quite
succinctly
.
The
most
modern
method
of
doing
generic
programming
uses
type
families
to
achieve
a
better
method
of
deriving
the
structural
properties
of
arbitrary
type
classes
.
Generic
implements
a
typeclass
with
an
associated
type
Rep
(
Representation
)
together
with
a
pair
of
functions
that
form
a
2
-
sided
inverse
(
isomorphism
)
for
converting
to
and
from
the
associated
type
and
the
derived
type
in
question
.
GHC
.
Generics
defines
a
set
of
named
types
for
modeling
the
various
structural
properties
of
types
in
available
in
Haskell
.
Using
the
deriving
mechanics
GHC
can
generate
this
Generic
instance
for
us
mechanically
if
we
were
to
write
it
by
hand
for
a
simple
type
it
might
look
like
this
:
Use
kind
!
in
GHCi
we
can
look
at
the
type
family
Rep
associated
with
a
Generic
instance
.
Now
the
clever
bit
instead
writing
our
generic
function
over
the
datatype
we
instead
write
it
over
the
Rep
and
then
reify
the
result
using
from
.
So
for
an
equivalent
version
of
Haskell
'
s
default
Eq
that
instead
uses
generic
deriving
we
could
write
:
To
accommodate
the
two
methods
of
writing
classes
(
generic
-
deriving
or
custom
implementations
)
we
can
use
the
DefaultSignatures
extension
to
allow
the
user
to
leave
typeclass
functions
blank
and
defer
to
Generic
or
to
define
their
own
.
Now
anyone
using
our
library
need
only
derive
Generic
and
create
an
empty
instance
of
our
typeclass
instance
without
writing
any
boilerplate
for
GEq
.
Here
is
a
complete
example
for
deriving
equality
generics
:
See
:
Using
Generics
many
common
libraries
provide
a
mechanisms
to
derive
common
typeclass
instances
.
Some
real
world
examples
:
The
hashable
library
allows
us
to
derive
hashing
functions
.
The
cereal
library
allows
us
to
automatically
derive
a
binary
representation
.
The
aeson
library
allows
us
to
derive
JSON
representations
for
JSON
instances
.
See
:
A
Generic
Deriving
Mechanism
for
Haskell
Using
the
same
interface
GHC
.
Generics
provides
a
separate
typeclass
for
higher
-
kinded
generics
.
So
for
instance
Maybe
has
Rep
1
of
the
form
:
Uniplate
is
a
generics
library
for
writing
traversals
and
transformation
for
arbitrary
data
structures
.
It
is
extremely
useful
for
writing
AST
transformations
and
rewriting
systems
.
The
descend
function
will
apply
a
function
to
each
immediate
descendant
of
an
expression
and
then
combines
them
up
into
the
parent
expression
.
The
transform
function
will
perform
a
single
pass
bottom
-
up
transformation
of
all
terms
in
the
expression
.
The
rewrite
function
will
perform
an
exhaustive
transformation
of
all
terms
in
the
expression
to
fixed
point
using
Maybe
to
signify
termination
.
Alternatively
Uniplate
instances
can
be
derived
automatically
from
instances
of
Data
without
the
need
to
explicitly
write
a
Uniplate
instance
.
This
approach
carries
a
slight
amount
of
overhead
over
an
explicit
hand
-
written
instance
.
Biplate
Biplates
generalize
plates
where
the
target
type
isn
'
t
necessarily
the
same
as
the
source
it
uses
multiparameter
typeclasses
to
indicate
the
type
sub
of
the
sub
-
target
.
The
Uniplate
functions
all
have
an
equivalent
generalized
biplate
form
.
Haskell
'
s
numeric
tower
is
unusual
and
the
source
of
some
confusion
for
novices
.
Haskell
is
one
of
the
few
languages
to
incorporate
statically
typed
overloaded
literals
without
a
mechanism
for
"
coercions
"
often
found
in
other
languages
.
To
add
to
the
confusion
numerical
literals
in
Haskell
are
desugared
into
a
function
from
a
numeric
typeclass
which
yields
a
polymorphic
value
that
can
be
instantiated
to
any
instance
of
the
Num
or
Fractional
typeclass
at
the
call
-
site
depending
on
the
inferred
type
.
To
use
a
blunt
metaphor
we
'
re
effectively
placing
an
object
in
a
hole
and
the
size
and
shape
of
the
hole
defines
the
object
you
place
there
.
This
is
very
different
than
in
other
languages
where
a
numeric
literal
like
2
.
718
is
hard
coded
in
the
compiler
to
be
a
specific
type
(
double
or
something
)
and
you
cast
the
value
at
runtime
to
be
something
smaller
or
larger
as
needed
.
The
numeric
typeclass
hierarchy
is
defined
as
such
:
Conversions
between
concrete
numeric
types
(
from
:
left
column
to
:
top
row
)
is
accomplished
with
several
generic
functions
.
The
Integer
type
in
GHC
is
implemented
by
the
GMP
(
libgmp
)
arbitrary
precision
arithmetic
library
.
Unlike
the
Int
type
the
size
of
Integer
values
is
bounded
only
by
the
available
memory
.
Most
notably
libgmp
is
one
of
the
few
libraries
that
compiled
Haskell
binaries
are
dynamically
linked
against
.
An
alternative
library
integer
-
simple
can
be
linked
in
place
of
libgmp
.
See
:
GHC
primops
and
exorcising
GMP
Haskell
supports
arithmetic
with
complex
numbers
via
a
Complex
datatype
from
the
Data
.
Complex
module
.
The
first
argument
is
the
real
part
while
the
second
is
the
imaginary
part
.
The
type
has
a
single
parameter
and
inherits
it
'
s
numerical
typeclass
components
(
Num
Fractional
Floating
)
from
the
type
of
this
paramater
.
The
Num
instance
for
Complex
is
only
defined
if
parameter
of
Complex
is
an
instance
of
RealFloat
.
Scientific
provides
arbitrary
-
precision
numbers
represented
using
scientific
notation
.
The
constructor
takes
an
arbitrarily
sized
Integer
argument
for
the
digits
and
an
Int
for
the
exponent
.
Alternatively
the
value
can
be
parsed
from
a
String
or
coerced
from
either
Double
/
Float
.
Instead
of
modeling
the
real
numbers
on
finite
precision
floating
point
numbers
we
alternatively
work
with
Num
which
internally
manipulate
the
power
series
expansions
for
the
expressions
when
performing
operations
like
arithmetic
or
transcendental
functions
without
losing
precision
when
performing
intermediate
computations
.
Then
we
simply
slice
off
a
fixed
number
of
terms
and
approximate
the
resulting
number
to
a
desired
precision
.
This
approach
is
not
without
its
limitations
and
caveats
(
notably
that
it
may
diverge
).
A
collection
of
constraint
problems
known
as
satisfiability
problems
show
up
in
a
number
of
different
disciplines
from
type
checking
to
package
management
.
Simply
put
a
satisfiability
problem
attempts
to
find
solutions
to
a
statement
of
conjoined
conjunctions
and
disjunctions
in
terms
of
a
series
of
variables
.
For
example
:
To
use
the
picosat
library
to
solve
this
it
can
be
written
as
zero
-
terminated
lists
of
integers
and
fed
to
the
solver
according
to
a
number
-
to
-
variable
relation
:
The
SAT
solver
itself
can
be
used
to
solve
satisfiability
problems
with
millions
of
variables
in
this
form
and
is
finely
tuned
.
See
:
A
generalization
of
the
SAT
problem
to
include
predicates
other
theories
gives
rise
to
the
very
sophisticated
domain
of
"
Satisfiability
Modulo
Theory
"
problems
.
The
existing
SMT
solvers
are
very
sophisticated
projects
(
usually
bankrolled
by
large
institutions
)
and
usually
have
to
called
out
to
via
foreign
function
interface
or
via
a
common
interface
called
SMT
-
lib
.
The
two
most
common
of
use
in
Haskell
are
cvc
4
from
Stanford
and
z
3
from
Microsoft
Research
.
The
SBV
library
can
abstract
over
different
SMT
solvers
to
allow
us
to
express
the
problem
in
an
embedded
domain
language
in
Haskell
and
then
offload
the
solving
work
to
the
third
party
library
.
As
an
example
here
'
s
how
you
can
solve
a
simple
cryptarithm
using
SBV
library
:
Let
'
s
look
at
all
possible
solutions
See
:
TODO
See
:
z
3
A
map
is
an
associative
array
mapping
any
instance
of
Ord
keys
to
values
of
any
type
.
Sets
are
an
unordered
data
structures
allow
Ord
values
of
any
type
and
guaranteeing
uniqueness
with
in
the
structure
.
They
are
not
identical
to
the
mathematical
notion
of
a
Set
even
though
they
share
the
same
namesake
.
Vectors
are
high
performance
single
dimensional
arrays
that
come
come
in
six
variants
two
for
each
of
the
following
types
of
a
mutable
and
an
immutable
variant
.
The
most
notable
feature
of
vectors
is
constant
time
memory
access
with
(
(!)
)
as
well
as
variety
of
efficient
map
fold
and
scan
operations
on
top
of
a
fusion
framework
that
generates
surprisingly
optimal
code
.
See
:
Numerical
Haskell
:
A
Vector
Tutorial
Within
the
IO
monad
we
can
perform
arbitrary
read
and
writes
on
the
mutable
vector
with
constant
time
reads
and
writes
.
When
needed
a
static
Vector
can
be
created
to
/
from
the
MVector
using
the
freeze
/
thaw
functions
.
The
vector
library
itself
normally
does
bounds
checks
on
index
operations
to
protect
against
memory
corruption
.
This
can
be
enabled
or
disabled
on
the
library
level
by
compiling
with
boundschecks
cabal
flag
.
Both
the
HashMap
and
HashSet
are
purely
functional
data
structures
that
are
drop
in
replacements
for
the
containers
equivalents
but
with
more
efficient
space
and
time
performance
.
Additionally
all
stored
elements
must
have
a
Hashable
instance
.
See
:
Announcing
Unordered
Containers
Hashtables
provides
hashtables
with
efficient
lookup
within
the
ST
or
IO
monad
.
The
Graph
module
in
the
containers
library
is
a
somewhat
antiquated
API
for
working
with
directed
graphs
.
A
little
bit
of
data
wrapping
makes
it
a
little
more
straightforward
to
use
.
The
library
is
not
necessarily
well
-
suited
for
large
graph
-
theoretic
operations
but
is
perfectly
fine
for
example
to
use
in
a
typechecker
which
need
to
resolve
strongly
connected
components
of
the
module
definition
graph
.
So
for
example
we
can
construct
a
simple
graph
:
Or
with
two
strongly
connected
subgraphs
:
See
:
GraphSCC
The
fgl
library
provides
a
more
efficient
graph
structure
and
a
wide
variety
of
common
graph
-
theoretic
operations
.
For
example
calculating
the
dominance
frontier
of
a
graph
shows
up
quite
frequently
in
control
flow
analysis
for
compiler
design
.
A
dlist
is
a
list
-
like
structure
that
is
optimized
for
O
(
1
)
append
operations
internally
it
uses
a
Church
encoding
of
the
list
structure
.
It
is
specifically
suited
for
operations
which
are
append
-
only
and
need
only
access
it
when
manifesting
the
entire
structure
.
It
is
particularly
well
-
suited
for
use
in
the
Writer
monad
.
The
sequence
data
structure
behaves
structurally
similar
to
list
but
is
optimized
for
append
/
prepend
operations
and
traversal
.
This
is
an
advanced
section
knowledge
of
FFI
is
not
typically
necessary
to
write
Haskell
.
Wrapping
pure
C
functions
with
primitive
types
is
trivial
.
There
exists
a
Storable
typeclass
that
can
be
used
to
provide
low
-
level
access
to
the
memory
underlying
Haskell
values
.
Ptr
objects
in
Haskell
behave
much
like
C
pointers
although
arithmetic
with
them
is
in
terms
of
bytes
only
not
the
size
of
the
type
associated
with
the
pointer
(
this
differs
from
C
).
The
Prelude
defines
Storable
interfaces
for
most
of
the
basic
types
as
well
as
types
in
the
Foreign
.
C
library
.
To
pass
arrays
from
Haskell
to
C
we
can
again
use
Storable
Vector
and
several
unsafe
operations
to
grab
a
foreign
pointer
to
the
underlying
data
that
can
be
handed
off
to
C
.
Once
we
'
re
in
C
land
nothing
will
protect
us
from
doing
evil
things
to
memory
!
The
names
of
foreign
functions
from
a
C
specific
header
file
can
be
qualified
.
Prepending
the
function
name
with
a
&
amp
;
allows
us
to
create
a
reference
to
the
function
pointer
itself
.
Using
the
above
FFI
functionality
it
'
s
trivial
to
pass
C
function
pointers
into
Haskell
but
what
about
the
inverse
passing
a
function
pointer
to
a
Haskell
function
into
C
using
foreign
import
ccall
"
wrapper
"
.
Will
yield
the
following
output
:
The
definitive
reference
on
concurrency
and
parallelism
in
Haskell
is
Simon
Marlow
'
s
text
.
This
will
section
will
just
gloss
over
these
topics
because
they
are
far
better
explained
in
this
book
.
See
:
Parallel
and
Concurrent
Programming
in
Haskell
Haskell
threads
are
extremely
cheap
to
spawn
using
only
1
.
5
KB
of
RAM
depending
on
the
platform
and
are
much
cheaper
than
a
pthread
in
C
.
Calling
forkIO
10
6
times
completes
just
short
of
a
1
s
.
Additionally
functional
purity
in
Haskell
also
guarantees
that
a
thread
can
almost
always
be
terminated
even
in
the
middle
of
a
computation
without
concern
.
See
:
The
Scheduler
The
most
basic
"
atom
"
of
parallelism
in
Haskell
is
a
spark
.
It
is
a
hint
to
the
GHC
runtime
that
a
computation
can
be
evaluated
to
weak
head
normal
form
in
parallel
.
rpar
a
spins
off
a
separate
spark
that
evolutes
a
to
weak
head
normal
form
and
places
the
computation
in
the
spark
pool
.
When
the
runtime
determines
that
there
is
an
available
CPU
to
evaluate
the
computation
it
will
evaluate
(
convert
)
the
spark
.
If
the
main
thread
of
the
program
is
the
evaluator
for
the
spark
the
spark
is
said
to
have
fizzled
.
Fizzling
is
generally
bad
and
indicates
that
the
logic
or
parallelism
strategy
is
not
well
suited
to
the
work
that
is
being
evaluated
.
The
spark
pool
is
also
limited
(
but
user
-
adjustable
)
to
a
default
of
8000
(
as
of
GHC
7
.
8
.
3
).
Sparks
that
are
created
beyond
that
limit
are
said
to
overflow
.
An
argument
to
rseq
forces
the
evaluation
of
a
spark
before
evaluation
continues
.
The
parallel
runtime
is
necessary
to
use
sparks
and
the
resulting
program
must
be
compiled
with
-
threaded
.
Additionally
the
program
itself
can
be
specified
to
take
runtime
options
with
-
rtsopts
such
as
the
number
of
cores
to
use
.
The
runtime
can
be
asked
to
dump
information
about
the
spark
evaluation
by
passing
the
-
s
flag
.
The
parallel
computations
themselves
are
sequenced
in
the
Eval
monad
whose
evaluation
with
runEval
is
itself
a
pure
computation
.
Passing
the
flag
-
l
generates
the
eventlog
which
can
be
rendered
with
the
threadscope
library
.
See
Simon
Marlows
'
s
Parallel
and
Concurrent
Programming
in
Haskell
for
a
detailed
guide
on
interpreting
and
profiling
using
Threadscope
.
See
:
Sparks
themselves
form
the
foundation
for
higher
level
parallelism
constructs
known
as
strategies
which
adapt
spark
creation
to
fit
the
computation
or
data
structure
being
evaluated
.
For
instance
if
we
wanted
to
evaluate
both
elements
of
a
tuple
in
parallel
we
can
create
a
strategy
which
uses
sparks
to
evaluate
both
sides
of
the
tuple
.
This
pattern
occurs
so
frequently
the
combinator
using
can
be
used
to
write
it
equivalently
in
operator
-
like
form
that
may
be
more
visually
appealing
to
some
.
For
a
less
contrived
example
consider
a
parallel
parmap
which
maps
a
pure
function
over
a
list
of
a
values
in
parallel
.
The
functions
above
are
quite
useful
but
will
break
down
if
evaluation
of
the
arguments
needs
to
be
parallelized
beyond
simply
weak
head
normal
form
.
For
instance
if
the
arguments
to
rpar
is
a
nested
constructor
we
'
d
like
to
parallelize
the
entire
section
of
work
in
evaluated
the
expression
to
normal
form
instead
of
just
the
outer
layer
.
As
such
we
'
d
like
to
generalize
our
strategies
so
the
the
evaluation
strategy
for
the
arguments
can
be
passed
as
an
argument
to
the
strategy
.
Control
.
Parallel
.
Strategies
contains
a
generalized
version
of
rpar
which
embeds
additional
evaluation
logic
inside
the
rpar
computation
in
Eval
monad
.
Using
the
deepseq
library
we
can
now
construct
a
Strategy
variant
of
rseq
that
evaluates
to
full
normal
form
.
We
now
can
create
a
"
higher
order
"
strategy
that
takes
two
strategies
and
itself
yields
a
a
computation
which
when
evaluated
uses
the
passed
strategies
in
its
scheduling
.
These
patterns
are
implemented
in
the
Strategies
library
along
with
several
other
general
forms
and
combinators
for
combining
strategies
to
fit
many
different
parallel
computations
.
See
:
Software
Transactional
Memory
is
a
technique
for
guaranteeing
atomicity
of
values
in
parallel
computations
such
that
all
contexts
view
the
same
data
when
read
and
writes
are
guaranteed
never
to
result
in
inconsistent
states
.
The
strength
of
Haskell
'
s
purity
guarantees
that
transactions
within
STM
are
pure
and
can
always
be
rolled
back
if
a
commit
fails
.
See
:
Beautiful
Concurrency
Using
the
Par
monad
we
express
our
computation
as
a
data
flow
graph
which
is
scheduled
in
order
of
the
connections
between
forked
computations
which
exchange
resulting
computations
with
IVar
.
Async
is
a
higher
level
set
of
functions
that
work
on
top
of
Control
.
Concurrent
and
STM
.
Diagrams
is
a
a
parser
combinator
library
for
generating
vector
images
to
SVG
and
a
variety
of
other
formats
.
See
:
Diagrams
Quick
Start
Tutorial
For
parsing
in
Haskell
it
is
quite
common
to
use
a
family
of
libraries
known
as
Parser
Combinators
which
let
us
write
code
to
generate
parsers
which
themselves
looks
very
similar
to
the
parser
grammar
itself
!
There
are
two
styles
of
writing
Parsec
one
can
choose
to
write
with
monads
or
with
applicatives
.
The
same
code
written
with
applicatives
uses
the
applicative
combinators
:
Now
for
instance
if
we
want
to
parse
simple
lambda
expressions
we
can
encode
the
parser
logic
as
compositions
of
these
combinators
which
yield
the
string
parser
when
evaluated
under
with
the
parse
.
In
our
previous
example
lexing
pass
was
not
necessary
because
each
lexeme
mapped
to
a
sequential
collection
of
characters
in
the
stream
type
.
If
we
wanted
to
extend
this
parser
with
a
non
-
trivial
set
of
tokens
then
Parsec
provides
us
with
a
set
of
functions
for
defining
lexers
and
integrating
these
with
the
parser
combinators
.
The
simplest
example
builds
on
top
of
the
builtin
Parsec
language
definitions
which
define
a
set
of
most
common
lexical
schemes
.
For
instance
we
'
ll
build
on
top
of
the
empty
language
grammar
on
top
of
the
haskellDef
grammer
that
uses
the
Text
token
instead
of
string
.
See
:
Text
.
Parsec
.
Language
Putting
our
lexer
and
parser
together
we
can
write
down
a
more
robust
parser
for
our
little
lambda
calculus
syntax
.
Trying
it
out
:
Previously
we
defined
generic
operations
for
pretty
printing
and
this
begs
the
question
of
whether
we
can
write
a
parser
on
top
of
Generics
.
The
answer
is
generally
yes
so
long
as
there
is
a
direct
mapping
between
the
specific
lexemes
and
sum
and
products
types
.
Consider
the
simplest
case
where
we
just
read
off
the
names
of
the
constructors
using
the
regular
Generics
machinery
and
then
build
a
Parsec
parser
terms
of
them
.
With
a
little
more
work
and
an
outer
wrapper
this
example
an
easily
be
extended
to
automate
parsing
of
a
simple
recursive
type
.
Attoparsec
is
a
parser
combinator
like
Parsec
but
more
suited
for
bulk
parsing
of
large
text
and
binary
files
instead
of
parsing
language
syntax
to
ASTs
.
When
written
properly
Attoparsec
parsers
can
be
efficient
.
One
notable
distinction
between
Parsec
and
Attoparsec
is
that
backtracking
operator
(
try
)
is
not
present
and
reflects
on
attoparsec
'
s
different
underlying
parser
model
.
For
a
simple
little
lambda
calculus
language
we
can
use
attoparsec
much
in
the
same
we
used
parsec
:
For
an
example
try
the
above
parser
with
the
following
simple
lambda
expression
.
Attoparsec
adapts
very
well
to
binary
and
network
protocol
style
parsing
as
well
this
is
extracted
from
a
small
implementation
of
a
distributed
consensus
network
protocol
:
See
:
Text
Parsing
Tutorial
Optparse
-
applicative
is
a
combinator
library
for
building
command
line
interfaces
that
take
in
various
user
flags
commmands
and
switches
and
map
them
into
Haskell
data
structures
that
can
handle
the
input
.
The
main
interface
is
through
the
applicative
functor
Parser
and
various
combinators
such
as
strArgument
and
flag
which
populate
the
option
parsing
table
with
some
monadic
action
which
returns
a
Haskell
value
.
The
resulting
sequence
of
values
can
be
combined
applicatively
into
a
larger
Config
data
structure
that
holds
all
the
given
options
.
The
--
help
header
is
also
automatically
generated
from
the
combinators
.
See
:
Optparse
Applicative
Tutorial
Happy
is
a
parser
generator
system
for
Haskell
similar
to
the
tool
`
yacc
'
for
C
.
It
works
as
a
preprocessor
with
it
'
s
own
syntax
that
generates
a
parse
table
from
two
specifications
a
lexer
file
and
parser
file
.
Happy
does
not
have
the
same
underlying
parser
implementation
as
parser
combinators
and
can
effectively
work
with
left
-
recursive
grammars
without
explicit
factorization
.
It
can
also
easily
be
modified
to
track
position
information
for
tokens
and
handle
offside
parsing
rules
for
indentation
-
sensitive
grammars
.
Happy
is
used
in
GHC
itself
for
Haskell
'
s
grammar
.
Running
the
standalone
commands
will
generate
the
Haskell
source
for
the
modules
.
The
generated
modules
are
not
human
readable
generally
and
unfortunatly
error
messages
are
given
in
the
Haskell
source
not
the
Happy
source
.
For
instance
we
could
define
a
little
toy
lexer
with
a
custom
set
of
tokens
.
The
associated
parser
is
list
of
a
production
rules
and
a
monad
to
running
the
parser
in
.
Production
rules
consist
of
a
set
of
options
on
the
left
and
generating
Haskell
expressions
on
the
right
with
indexed
metavariables
(
$
1
$
2
...)
mapping
to
the
ordered
terms
on
the
left
(
i
.
e
.
in
the
second
term
term
~
$
1
term
~
$
2
).
As
a
simple
input
consider
the
following
simple
program
.
The
problem
with
using
the
usual
monadic
approach
to
processing
data
accumulated
through
IO
is
that
the
Prelude
tools
require
us
to
manifest
large
amounts
of
data
in
memory
all
at
once
before
we
can
even
begin
computation
.
Reading
from
the
file
creates
a
thunk
for
the
string
that
forced
will
then
read
the
file
.
The
problem
is
then
that
this
method
ties
the
ordering
of
IO
effects
to
evaluation
order
which
is
difficult
to
reason
about
in
the
large
.
Consider
that
normally
the
monad
laws
(
in
the
absence
of
seq
)
guarantee
that
these
computations
should
be
identical
.
But
using
lazy
IO
we
can
construct
a
degenerate
case
.
So
what
we
need
is
a
system
to
guarantee
deterministic
resource
handling
with
constant
memory
usage
.
To
that
end
both
the
Conduits
and
Pipes
libraries
solved
this
problem
using
different
(
though
largely
equivalent
)
approaches
.
Pipes
is
a
stream
processing
library
with
a
strong
emphasis
on
the
static
semantics
of
composition
.
The
simplest
usage
is
to
connect
"
pipe
"
functions
with
a
(&
gt
;-&
gt
;)
composition
operator
where
each
component
can
await
and
yield
to
push
and
pull
values
along
the
stream
.
For
example
we
could
construct
a
"
FizzBuzz
"
pipe
.
To
continue
with
the
degenerate
case
we
constructed
with
Lazy
IO
consider
than
we
can
now
compose
and
sequence
deterministic
actions
over
files
without
having
to
worry
about
effect
order
.
This
is
simple
a
sampling
of
the
functionality
of
pipes
.
The
documentation
for
pipes
is
extensive
and
great
deal
of
care
has
been
taken
make
the
library
extremely
thorough
.
pipes
is
a
shining
example
of
an
accessible
yet
category
theoretic
driven
design
.
See
:
Pipes
Tutorial
As
a
motivating
example
ZeroMQ
is
a
network
messaging
library
that
abstracts
over
traditional
Unix
sockets
to
a
variety
of
network
topologies
.
Most
notably
it
isn
'
t
designed
to
guarantee
any
sort
of
transactional
guarantees
for
delivery
or
recovery
in
case
of
errors
so
it
'
s
necessary
to
design
a
layer
on
top
of
it
to
provide
the
desired
behavior
at
the
application
layer
.
In
Haskell
we
'
d
like
to
guarantee
that
if
we
'
re
polling
on
a
socket
we
get
messages
delivered
in
a
timely
fashion
or
consider
the
resource
in
an
error
state
and
recover
from
it
.
Using
pipes
-
safe
we
can
manage
the
life
cycle
of
lazy
IO
resources
and
can
safely
handle
failures
resource
termination
and
finalization
gracefully
.
In
other
languages
this
kind
of
logic
would
be
smeared
across
several
places
or
put
in
some
global
context
and
prone
to
introduce
errors
and
subtle
race
conditions
.
Using
pipes
we
instead
get
a
nice
tight
abstraction
designed
exactly
to
fit
this
kind
of
use
case
.
For
instance
now
we
can
bracket
the
ZeroMQ
socket
creation
and
finalization
within
the
SafeT
monad
transformer
which
guarantees
that
after
successful
message
delivery
we
execute
the
pipes
function
as
expected
or
on
failure
we
halt
the
execution
and
finalize
the
socket
.
Conduits
are
conceptually
similar
though
philosophically
different
approach
to
the
same
problem
of
constant
space
deterministic
resource
handling
for
IO
resources
.
The
first
initial
difference
is
that
await
function
now
returns
a
Maybe
which
allows
different
handling
of
termination
.
The
composition
operators
are
also
split
into
a
connecting
operator
(
$$
)
and
a
fusing
operator
(
=$
)
for
combining
Sources
and
Sink
and
a
Conduit
and
a
Sink
respectively
.
See
:
Conduit
Overview
Aeson
is
library
for
efficient
parsing
and
generating
JSON
.
It
is
the
canonical
JSON
library
for
handling
JSON
.
A
point
of
some
subtlety
to
beginners
is
that
the
return
types
for
Aeson
functions
are
polymorphic
in
their
return
types
meaning
that
the
resulting
type
of
decode
is
specified
only
in
the
context
of
your
programs
use
of
the
decode
function
.
So
if
you
use
decode
in
a
point
your
program
and
bind
it
to
a
value
x
and
then
use
x
as
if
it
were
and
integer
throughout
the
rest
of
your
program
Aeson
will
select
the
typeclass
instance
which
parses
the
given
input
string
into
a
Haskell
integer
.
Aeson
uses
several
high
performance
data
structures
(
Vector
Text
HashMap
)
by
default
instead
of
the
naive
versions
so
typically
using
Aeson
will
require
that
us
import
them
and
use
OverloadedStrings
when
indexing
into
objects
.
The
underlying
Aeson
structure
is
called
Value
and
encodes
a
recursive
tree
structure
that
models
the
semantics
of
untyped
JSON
objects
by
mapping
them
onto
a
large
sum
type
which
embodies
all
possible
JSON
values
.
For
instance
the
Value
expansion
of
the
following
JSON
blob
:
Is
represented
in
Aeson
as
the
Value
:
Let
'
s
consider
some
larger
examples
we
'
ll
work
with
this
contrived
example
JSON
:
In
dynamic
scripting
languages
it
'
s
common
to
parse
amorphous
blobs
of
JSON
without
any
a
priori
structure
and
then
handle
validation
problems
by
throwing
exceptions
while
traversing
it
.
We
can
do
the
same
using
Aeson
and
the
Maybe
monad
.
This
isn
'
t
ideal
since
we
'
ve
just
smeared
all
the
validation
logic
across
our
traversal
logic
instead
of
separating
concerns
and
handling
validation
in
separate
logic
.
We
'
d
like
to
describe
the
structure
before
-
hand
and
the
invalid
case
separately
.
Using
Generic
also
allows
Haskell
to
automatically
write
the
serializer
and
deserializer
between
our
datatype
and
the
JSON
string
based
on
the
names
of
record
field
names
.
Now
we
get
our
validated
JSON
wrapped
up
into
a
nicely
typed
Haskell
ADT
.
The
functions
fromJSON
and
toJSON
can
be
used
to
convert
between
this
sum
type
and
regular
Haskell
types
with
.
As
of
7
.
10
.
2
we
can
use
the
new
-
XDeriveAnyClass
to
automatically
derive
instances
of
FromJSON
and
TOJSON
without
the
need
for
standalone
instance
declarations
.
These
are
implemented
entirely
in
terms
of
the
default
methods
which
use
Generics
under
the
hood
.
While
it
'
s
useful
to
use
generics
to
derive
instances
sometimes
you
actually
want
more
fine
grained
control
over
serialization
and
de
serialization
.
So
we
fall
back
on
writing
ToJSON
and
FromJSON
instances
manually
.
Using
FromJSON
we
can
project
into
hashmap
using
the
(.:)
operator
to
extract
keys
.
If
the
key
fails
to
exist
the
parser
will
abort
with
a
key
failure
message
.
The
ToJSON
instances
can
never
fail
and
simply
require
us
to
pattern
match
on
our
custom
datatype
and
generate
an
appropriate
value
.
The
law
that
the
FromJSON
and
ToJSON
classes
should
maintain
is
that
encode
.
decode
and
decode
.
encode
should
map
to
the
same
object
.
Although
in
practice
there
many
times
when
we
break
this
rule
and
especially
if
the
serialize
or
de
serialize
is
one
way
.
See
:
Aeson
Documentation
Yaml
is
a
textual
serialization
format
similar
to
JSON
.
It
uses
an
indentation
sensitive
structure
to
encode
nested
maps
of
keys
and
values
.
The
Yaml
interface
for
Haskell
is
a
precise
copy
of
Data
.
Aeson
To
parse
this
file
we
use
the
following
datatypes
and
functions
:
Which
generates
:
Cassava
is
an
efficient
CSV
parser
library
.
We
'
ll
work
with
this
tiny
snippet
from
the
iris
dataset
:
Just
like
with
Aeson
if
we
really
want
to
work
with
unstructured
data
the
library
accommodates
this
.
We
see
we
get
the
nested
set
of
stringy
vectors
:
Just
like
with
Aeson
we
can
use
Generic
to
automatically
write
the
deserializer
between
our
CSV
data
and
our
custom
datatype
.
And
again
we
get
a
nice
typed
ADT
as
a
result
.
Haskell
has
a
variety
of
HTTP
request
and
processing
libraries
.
The
simplest
and
most
flexible
is
the
HTTP
library
.
Blaze
is
an
HTML
combinator
library
that
provides
that
capacity
to
build
composable
bits
of
HTML
programmatically
.
It
doesn
'
t
string
templating
libraries
like
Hastache
but
instead
provides
an
API
for
building
up
HTML
documents
from
logic
where
the
format
out
of
the
output
is
generated
procedurally
.
For
sequencing
HTML
elements
the
elements
can
either
be
sequenced
in
a
monad
or
with
monoid
operations
.
For
custom
datatypes
we
can
implement
the
ToMarkup
class
to
convert
between
Haskell
data
structures
and
HTML
representation
.
Warp
is
a
efficient
web
server
it
'
s
the
backend
request
engine
behind
several
of
popular
Haskell
web
frameworks
.
The
internals
have
been
finely
tuned
to
utilize
Haskell
'
s
concurrent
runtime
and
is
capable
of
handling
a
great
deal
of
concurrent
requests
.
See
:
Warp
Continuing
with
our
trek
through
web
libraries
Scotty
is
a
web
microframework
similar
in
principle
to
Flask
in
Python
or
Sinatra
in
Ruby
.
Of
importance
to
note
is
the
Blaze
library
used
here
overloads
do
-
notation
but
is
not
itself
a
proper
monad
so
the
various
laws
and
invariants
that
normally
apply
for
monads
may
break
down
or
fail
with
error
terms
.
See
:
Making
a
Website
with
Haskell
Hastache
is
string
templating
based
on
the
"
Mustache
"
style
of
encoding
metavariables
with
double
braces
{{
x
}}
.
Hastache
supports
automatically
converting
many
Haskell
types
into
strings
and
uses
the
efficient
Text
functions
for
formatting
.
The
variables
loaded
into
the
template
are
specified
in
either
a
function
mapping
variable
names
to
printable
MuType
values
.
For
instance
using
a
function
.
Or
using
Data
-
Typeable
record
and
mkGenericContext
the
Haskell
field
names
are
converted
into
variable
names
.
The
MuType
and
MuContext
types
can
be
parameterized
by
any
monad
or
transformer
that
implements
MonadIO
not
just
IO
.
Postgres
is
an
object
-
relational
database
management
system
with
a
rich
extension
of
the
SQL
standard
.
Consider
the
following
tables
specified
in
DDL
.
The
postgresql
-
simple
bindings
provide
a
thin
wrapper
to
various
libpq
commands
to
interact
a
Postgres
server
.
These
functions
all
take
a
Connection
object
to
the
database
instance
and
allow
various
bytestring
queries
to
be
sent
and
result
sets
mapped
into
Haskell
datatypes
.
There
are
four
primary
functions
for
these
interactions
:
The
result
of
the
query
function
is
a
list
of
elements
which
implement
the
FromRow
typeclass
.
This
can
be
many
things
including
a
single
elemment
(
Only
a
list
of
tuples
where
each
element
implements
FromField
or
a
custom
datatype
that
itself
implements
FromRow
.
Under
the
hood
the
database
bindings
inspects
the
Postgres
oid
objects
and
then
attempts
to
convert
them
into
the
Haskell
datatype
of
the
field
being
scrutinised
.
This
can
fail
at
runtime
if
the
types
in
the
database
don
'
t
align
with
the
expected
types
in
the
logic
executing
the
SQL
query
.
This
yields
the
result
set
:
This
yields
the
result
set
:
As
SQL
expressions
grow
in
complexity
they
often
span
multiple
lines
and
sometimes
its
useful
to
just
drop
down
to
a
quasiquoter
to
embed
the
whole
query
.
The
quoter
here
is
pure
and
just
generates
the
Query
object
behind
as
a
ByteString
.
This
yields
the
result
set
:
Redis
is
an
in
-
memory
key
-
value
store
with
support
for
a
variety
of
datastructures
.
The
Haskell
exposure
is
exposed
in
a
Redis
monad
which
sequences
a
set
of
redis
commands
taking
ByteString
arguments
and
then
executes
them
against
a
connection
object
.
Redis
is
quite
often
used
as
a
lightweight
pubsub
server
and
the
bindings
integrate
with
the
Haskell
concurrency
primitives
so
that
listeners
can
be
sparked
and
shared
across
threads
off
without
blocking
the
main
thread
.
Acid
-
state
allows
us
to
build
a
"
database
"
for
around
our
existing
Haskell
datatypes
that
guarantees
atomic
transactions
.
For
example
we
can
build
a
simple
key
-
value
store
wrapped
around
the
Map
type
.
This
is
a
very
advanced
section
knowledge
of
GHC
internals
is
rarely
necessary
.
The
flow
of
code
through
GHC
is
a
process
of
translation
between
several
intermediate
languages
and
optimizations
and
transformations
thereof
.
A
common
pattern
for
many
of
these
AST
types
is
they
are
parametrized
over
a
binder
type
and
at
various
stages
the
binders
will
be
transformed
for
example
the
Renamer
pass
effectively
translates
the
HsSyn
datatype
from
a
AST
parametrized
over
literal
strings
as
the
user
enters
into
a
HsSyn
parameterized
over
qualified
names
that
includes
modules
and
package
names
into
a
higher
level
Name
type
.
Information
for
each
pass
can
dumped
out
via
a
rather
large
collection
of
flags
.
The
GHC
internals
are
very
accessible
although
some
passes
are
somewhat
easier
to
understand
than
others
.
Most
of
the
time
-
ddump
-
simpl
and
-
ddump
-
stg
are
sufficient
to
get
an
understanding
of
how
the
code
will
compile
unless
of
course
you
'
re
dealing
with
very
specialized
optimizations
or
hacking
on
GHC
itself
.
Core
is
the
explicitly
typed
System
-
F
family
syntax
through
that
all
Haskell
constructs
can
be
expressed
in
.
To
inspect
the
core
from
GHCi
we
can
invoke
it
using
the
following
flags
and
the
following
shell
alias
.
We
have
explicitly
disable
the
printing
of
certain
metadata
and
longform
names
to
make
the
representation
easier
to
read
.
At
the
interactive
prompt
we
can
then
explore
the
core
representation
interactively
:
ghc
-
core
is
also
very
useful
for
looking
at
GHC
'
s
compilation
artifacts
.
Alternatively
the
major
stages
of
the
compiler
(
parse
tree
core
stg
cmm
asm
)
can
be
manually
outputted
and
inspected
by
passing
several
flags
to
the
compiler
:
Reading
Core
Core
from
GHC
is
roughly
human
readable
but
it
'
s
helpful
to
look
at
simple
human
written
examples
to
get
the
hang
of
what
'
s
going
on
.
Machine
generated
names
are
created
for
a
lot
of
transformation
of
Core
.
Generally
they
consist
of
a
prefix
and
unique
identifier
.
The
prefix
is
often
pass
specific
(
i
.
e
.
ds
for
desugar
generated
name
s
)
and
sometimes
specific
names
are
generated
for
specific
automatically
generated
code
.
A
list
of
the
common
prefixes
and
their
meaning
is
show
below
.
Of
important
note
is
that
the
Î
and
Î
»
for
type
-
level
and
value
-
level
lambda
abstraction
are
represented
by
the
same
symbol
(
\
)
in
core
which
is
a
simplifying
detail
of
the
GHC
'
s
implementation
but
a
source
of
some
confusion
when
starting
.
The
seq
function
has
an
intuitive
implementation
in
the
Core
language
.
One
particularly
notable
case
of
the
Core
desugaring
process
is
that
pattern
matching
on
overloaded
numbers
implicitly
translates
into
equality
test
(
i
.
e
.
Eq
).
Of
course
adding
a
concrete
type
signature
changes
the
desugar
just
matching
on
the
unboxed
values
.
See
:
Having
to
enter
a
secondary
closure
every
time
we
used
($)
would
introduce
an
enormous
overhead
.
Fortunately
GHC
has
a
pass
to
eliminate
small
functions
like
this
by
simply
replacing
the
function
call
with
the
body
of
its
definition
at
appropriate
call
-
sites
.
The
compiler
contains
a
variety
of
heuristics
for
determining
when
this
kind
of
substitution
is
appropriate
and
the
potential
costs
involved
.
In
addition
to
the
automatic
inliner
manual
pragmas
are
provided
for
more
granular
control
over
inlining
.
It
'
s
important
to
note
that
naive
inlining
quite
often
results
in
significantly
worse
performance
and
longer
compilation
times
.
For
example
the
contrived
case
where
we
apply
a
binary
function
to
two
arguments
.
The
function
body
is
small
and
instead
of
entering
another
closure
just
to
apply
the
given
function
we
could
in
fact
just
inline
the
function
application
at
the
call
site
.
Looking
at
the
core
we
can
see
that
in
test
1
the
function
has
indeed
been
expanded
at
the
call
site
and
simply
performs
the
addition
there
instead
of
another
indirection
.
Cases
marked
with
NOINLINE
generally
indicate
that
the
logic
in
the
function
is
using
something
like
unsafePerformIO
or
some
other
unholy
function
.
In
these
cases
naive
inlining
might
duplicate
effects
at
multiple
call
-
sites
throughout
the
program
which
would
be
undesirable
.
See
:
The
Haskell
language
defines
the
notion
of
Typeclasses
but
is
agnostic
to
how
they
are
implemented
in
a
Haskell
compiler
.
GHC
'
s
particular
implementation
uses
a
pass
called
the
dictionary
passing
translation
part
of
the
elaboration
phase
of
the
typechecker
which
translates
Core
functions
with
typeclass
constraints
into
implicit
parameters
of
which
record
-
like
structures
containing
the
function
implementations
are
passed
.
This
class
can
be
thought
as
the
implementation
equivalent
to
the
following
parameterized
record
of
functions
.
Num
and
Ord
have
simple
translation
but
for
monads
with
existential
type
variables
in
their
signatures
the
only
way
to
represent
the
equivalent
dictionary
is
using
RankNTypes
.
In
addition
a
typeclass
may
also
include
superclasses
which
would
be
included
in
the
typeclass
dictionary
and
parameterized
over
the
same
arguments
and
an
implicit
superclass
constructor
function
is
created
to
pull
out
functions
from
the
superclass
for
the
current
monad
.
Indeed
this
is
not
that
far
from
how
GHC
actually
implements
typeclasses
.
It
elaborates
into
projection
functions
and
data
constructors
nearly
identical
to
this
and
are
expanded
out
to
a
dictionary
argument
for
each
typeclass
constraint
of
every
polymorphic
function
.
Overloading
in
Haskell
is
normally
not
entirely
free
by
default
although
with
an
optimization
called
specialization
it
can
be
made
to
have
zero
cost
at
specific
points
in
the
code
where
performance
is
crucial
.
This
is
not
enabled
by
default
by
virtue
of
the
fact
that
GHC
is
not
a
whole
-
program
optimizing
compiler
and
most
optimizations
(
not
all
)
stop
at
module
boundaries
.
GHC
'
s
method
of
implementing
typeclasses
means
that
explicit
dictionaries
are
threaded
around
implicitly
throughout
the
call
sites
.
This
is
normally
the
most
natural
way
to
implement
this
functionality
since
it
preserves
separate
compilation
.
A
function
can
be
compiled
independently
of
where
it
is
declared
not
recompiled
at
every
point
in
the
program
where
it
'
s
called
.
The
dictionary
passing
allows
the
caller
to
thread
the
implementation
logic
for
the
types
to
the
call
-
site
where
it
can
then
be
used
throughout
the
body
of
the
function
.
Of
course
this
means
that
in
order
to
get
at
a
specific
typeclass
function
we
need
to
project
(
possibly
multiple
times
)
into
the
dictionary
structure
to
pluck
out
the
function
reference
.
The
runtime
makes
this
very
cheap
but
not
entirely
free
.
Many
C
++
compilers
or
whole
program
optimizing
compilers
do
the
opposite
however
they
explicitly
specialize
each
and
every
function
at
the
call
site
replacing
the
overloaded
function
with
its
type
-
specific
implementation
.
We
can
selectively
enable
this
kind
of
behavior
using
class
specialization
.
Non
-
specialized
In
the
specialized
version
the
typeclass
operations
placed
directly
at
the
call
site
and
are
simply
unboxed
arithmetic
.
This
will
map
to
a
tight
set
of
sequential
CPU
instructions
and
is
very
likely
the
same
code
generated
by
C
.
The
non
-
specialized
version
has
to
project
into
the
typeclass
dictionary
(
$
fFloatingFloat
)
6
times
and
likely
go
through
around
25
branches
to
perform
the
same
operation
.
For
a
tight
loop
over
numeric
types
specializing
at
the
call
site
can
result
in
orders
of
magnitude
performance
increase
.
Although
the
cost
in
compile
-
time
can
often
be
non
-
trivial
and
when
used
function
used
at
many
call
-
sites
this
can
slow
GHC
'
s
simplifier
pass
to
a
crawl
.
The
best
advice
is
profile
and
look
for
large
uses
of
dictionary
projection
in
tight
loops
and
then
specialize
and
inline
in
these
places
.
Using
the
SPECIALISE
INLINE
pragma
can
unintentionally
cause
GHC
to
diverge
if
applied
over
a
recursive
function
it
will
try
to
specialize
itself
infinitely
.
On
Linux
Haskell
programs
can
be
compiled
into
a
standalone
statically
linked
binary
that
includes
the
runtime
statically
linked
into
it
.
In
addition
the
file
size
of
the
resulting
binary
can
be
reduced
by
stripping
unneeded
symbols
.
upx
can
additionally
be
used
to
compress
the
size
of
the
executable
down
further
.
The
usual
numerics
types
in
Haskell
can
be
considered
to
be
a
regular
algebraic
datatype
with
special
constructor
arguments
for
their
underlying
unboxed
values
.
Normally
unboxed
types
and
explicit
unboxing
are
not
used
in
normal
code
they
are
wired
-
in
to
the
compiler
.
An
unboxed
type
with
kind
#
and
will
never
unify
a
type
variable
of
kind
*
.
Intuitively
a
type
with
kind
*
indicates
a
type
with
a
uniform
runtime
representation
that
can
be
used
polymorphically
.
The
function
for
integer
arithmetic
used
in
the
Num
typeclass
for
Int
is
just
pattern
matching
on
this
type
to
reveal
the
underlying
unboxed
value
performing
the
builtin
arithmetic
and
then
performing
the
packing
up
into
Int
again
.
Where
(+#)
is
a
low
level
function
built
into
GHC
that
maps
to
intrinsic
integer
addition
instruction
for
the
CPU
.
Runtime
values
in
Haskell
are
by
default
represented
uniformly
by
a
boxed
StgClosure
*
struct
which
itself
contains
several
payload
values
which
can
themselves
either
be
pointers
to
other
boxed
values
or
to
unboxed
literal
values
that
fit
within
the
system
word
size
and
are
stored
directly
within
the
closure
in
memory
.
The
layout
of
the
box
is
described
by
a
bitmap
in
the
header
for
the
closure
which
describes
which
values
in
the
payload
are
either
pointers
or
non
-
pointers
.
The
unpackClosure
#
primop
can
be
used
to
extract
this
information
at
runtime
by
reading
off
the
bitmap
on
the
closure
.
For
example
the
datatype
with
the
UNPACK
pragma
contains
1
non
-
pointer
and
0
pointers
.
While
the
default
packed
datatype
contains
1
pointer
and
0
non
-
pointers
.
The
closure
representation
for
data
constructors
are
also
"
tagged
"
at
the
runtime
with
the
tag
of
the
specific
constructor
.
This
is
however
not
a
runtime
type
tag
since
there
is
no
way
to
recover
the
type
from
the
tag
as
all
constructor
simply
use
the
sequence
(
0
1
2
...).
The
tag
is
used
to
discriminate
cases
in
pattern
matching
.
The
builtin
dataToTag
#
can
be
used
to
pluck
off
the
tag
for
an
arbitrary
datatype
.
This
is
used
in
some
cases
when
desugaring
pattern
matches
.
For
example
:
String
literals
included
in
the
source
code
are
also
translated
into
several
primop
operations
.
The
Addr
#
type
in
Haskell
stands
for
a
static
contagious
buffer
pre
-
allocated
on
the
Haskell
heap
that
can
hold
a
char
*
sequence
.
The
operation
unpackCString
#
can
scan
this
buffer
and
fold
it
up
into
a
list
of
Chars
from
inside
Haskell
.
This
is
done
in
the
early
frontend
desugarer
phase
where
literals
are
translated
into
Addr
#
inline
instead
of
giant
chain
of
Cons
'
d
characters
.
So
our
"
Hello
World
"
translates
into
the
following
Core
:
See
:
Both
the
IO
and
the
ST
monad
have
special
state
in
the
GHC
runtime
and
share
a
very
similar
implementation
.
Both
ST
a
and
IO
a
are
passing
around
an
unboxed
tuple
of
the
form
:
The
RealWorld
#
token
is
"
deeply
magical
"
and
doesn
'
t
actually
expand
into
any
code
when
compiled
but
simply
threaded
around
through
every
bind
of
the
IO
or
ST
monad
and
has
several
properties
of
being
unique
and
not
being
able
to
be
duplicated
to
ensure
sequential
IO
actions
are
actually
sequential
.
unsafePerformIO
can
thought
of
as
the
unique
operation
which
discards
the
world
token
and
plucks
the
a
out
and
is
as
the
name
implies
not
normally
safe
.
The
PrimMonad
abstracts
over
both
these
monads
with
an
associated
data
family
for
the
world
token
or
ST
thread
and
can
be
used
to
write
operations
that
generic
over
both
ST
and
IO
.
This
is
used
extensively
inside
of
the
vector
package
to
allow
vector
algorithms
to
be
written
generically
either
inside
of
IO
or
ST
.
See
:
Through
some
dark
runtime
magic
we
can
actually
inspect
the
StgClosure
structures
at
runtime
using
various
C
and
Cmm
hacks
to
probe
at
the
fields
of
the
structure
'
s
representation
to
the
runtime
.
The
library
ghc
-
heap
-
view
can
be
used
to
introspect
such
things
although
there
is
really
no
use
for
this
kind
of
thing
in
everyday
code
it
is
very
helpful
when
studying
the
GHC
internals
to
be
able
to
inspect
the
runtime
implementation
details
and
get
at
the
raw
bits
underlying
all
Haskell
types
.
A
constructor
(
in
this
for
cons
constructor
of
list
type
)
is
represented
by
a
CONSTR
closure
that
holds
two
pointers
to
the
head
and
the
tail
.
The
integer
in
the
head
argument
is
a
static
reference
to
the
pre
-
allocated
number
and
we
see
a
single
static
reference
in
the
SRT
(
static
reference
table
).
We
can
also
observe
the
evaluation
and
update
of
a
thunk
in
process
(
id
(
1
+
1
)
).
The
initial
thunk
is
simply
a
thunk
type
with
a
pointer
to
the
code
to
evaluate
it
to
a
value
.
When
forced
it
is
then
evaluated
and
replaced
with
an
Indirection
closure
which
points
at
the
computed
value
.
When
the
copying
garbage
collector
passes
over
the
indirection
it
then
simply
replaces
the
indirection
with
a
reference
to
the
actual
computed
value
computed
by
indirectee
so
that
future
access
does
need
to
chase
a
pointer
through
the
indirection
pointer
to
get
the
result
.
After
being
compiled
into
Core
a
program
is
translated
into
a
very
similar
intermediate
form
known
as
STG
(
Spineless
Tagless
G
-
Machine
)
an
abstract
machine
model
that
makes
all
laziness
explicit
.
The
spineless
indicates
that
function
applications
in
the
language
do
not
have
a
spine
of
applications
of
functions
are
collapsed
into
a
sequence
of
arguments
.
Currying
is
still
present
in
the
semantics
since
arity
information
is
stored
and
partially
applied
functions
will
evaluate
differently
than
saturated
functions
.
All
let
statements
in
STG
bind
a
name
to
a
lambda
form
.
A
lambda
form
with
no
arguments
is
a
thunk
while
a
lambda
-
form
with
arguments
indicates
that
a
closure
is
to
be
allocated
that
captures
the
variables
explicitly
mentioned
.
Thunks
themselves
are
either
reentrant
(
\
r
)
or
updatable
(
\
u
)
indicating
that
the
thunk
and
either
yields
a
value
to
the
stack
or
is
allocated
on
the
heap
after
the
update
frame
is
evaluated
All
subsequent
entry
'
s
of
the
thunk
will
yield
the
already
-
computed
value
without
needing
to
redo
the
same
work
.
A
lambda
form
also
indicates
the
static
reference
table
a
collection
of
references
to
static
heap
allocated
values
referred
to
by
the
body
of
the
function
.
For
example
turning
on
-
ddump
-
stg
we
can
see
the
expansion
of
the
following
compose
function
.
For
a
more
sophisticated
example
let
'
s
trace
the
compilation
of
the
factorial
function
.
Notice
that
the
factorial
function
allocates
two
thunks
(
look
for
\
u
)
inside
of
the
loop
which
are
updated
when
computed
.
It
also
includes
static
references
to
both
itself
(
for
recursion
)
and
the
dictionary
for
instance
of
Num
typeclass
over
the
type
Int
.
With
-
O
2
turned
on
GHC
will
perform
a
special
optimization
known
as
the
Worker
-
Wrapper
transformation
which
will
split
the
logic
of
the
factorial
function
across
two
definitions
the
worker
will
operate
over
stack
unboxed
allocated
machine
integers
which
compiles
into
a
tight
inner
loop
while
the
wrapper
calls
into
the
worker
and
collects
the
end
result
of
the
loop
and
packages
it
back
up
into
a
boxed
heap
value
.
This
can
often
be
an
order
of
of
magnitude
faster
than
the
naive
implementation
which
needs
to
pack
and
unpack
the
boxed
integers
on
every
iteration
.
See
:
The
Z
-
encoding
is
Haskell
'
s
convention
for
generating
names
that
are
safely
represented
in
the
compiler
target
language
.
Simply
put
the
z
-
encoding
renames
many
symbolic
characters
into
special
sequences
of
the
z
character
.
In
this
way
we
don
'
t
have
to
generate
unique
unidentifiable
names
for
character
rich
names
and
can
simply
have
a
straightforward
way
to
translate
them
into
something
unique
but
identifiable
.
So
for
some
example
names
from
GHC
generated
code
:
Cmm
is
GHC
'
s
complex
internal
intermediate
representation
that
maps
directly
onto
the
generated
code
for
the
compiler
target
.
Cmm
code
generated
from
Haskell
is
CPS
-
converted
all
functions
never
return
a
value
they
simply
call
the
next
frame
in
the
continuation
stack
.
All
evaluation
of
functions
proceed
by
indirectly
jumping
to
a
code
object
with
its
arguments
placed
on
the
stack
by
the
caller
.
This
is
drastically
different
than
C
'
s
evaluation
model
where
are
placed
on
the
stack
and
a
function
yields
a
value
to
the
stack
after
it
returns
.
There
are
several
common
suffixes
you
'
ll
see
used
in
all
closures
and
function
names
:
Cmm
Registers
There
are
10
registers
that
described
in
the
machine
model
.
Sp
is
the
pointer
to
top
of
the
stack
SpLim
is
the
pointer
to
last
element
in
the
stack
.
Hp
is
the
heap
pointer
used
for
allocation
and
garbage
collection
with
HpLim
the
current
heap
limit
.
The
R
1
register
always
holds
the
active
closure
and
subsequent
registers
are
arguments
passed
in
registers
.
Functions
with
more
than
10
values
spill
into
memory
.
Examples
To
understand
Cmm
it
is
useful
to
look
at
the
code
generated
by
the
equivalent
Haskell
and
slowly
understand
the
equivalence
and
mechanical
translation
maps
one
to
the
other
.
There
are
generally
two
parts
to
every
Cmm
definition
the
info
table
and
the
entry
code
.
The
info
table
maps
directly
StgInfoTable
struct
and
contains
various
fields
related
to
the
type
of
the
closure
its
payload
and
references
.
The
code
objects
are
basic
blocks
of
generated
code
that
correspond
to
the
logic
of
the
Haskell
function
/
constructor
.
For
the
simplest
example
consider
a
constant
static
constructor
.
Simply
a
function
which
yields
the
Unit
value
.
In
this
case
the
function
is
simply
a
constructor
with
no
payload
and
is
statically
allocated
.
Haskell
:
Cmm
:
Consider
a
static
constructor
with
an
argument
.
Haskell
:
Cmm
:
Consider
a
literal
constant
.
This
is
a
static
value
.
Haskell
:
Cmm
:
Consider
the
identity
function
.
Haskell
:
Cmm
:
Consider
the
constant
function
.
Haskell
:
Cmm
:
Consider
a
function
where
application
of
a
function
(
of
unknown
arity
)
occurs
.
Haskell
:
Cmm
:
Consider
a
function
which
branches
using
pattern
matching
:
Haskell
:
Cmm
:
Macros
Cmm
itself
uses
many
macros
to
stand
for
various
constructs
many
of
which
are
defined
in
an
external
C
header
file
.
A
short
reference
for
the
common
types
:
Many
of
the
predefined
closures
(
stg
_
ap
_
p
_
fast
etc
)
are
themselves
mechanically
generated
and
more
or
less
share
the
same
form
(
a
giant
switch
statement
on
closure
type
update
frame
stack
adjustment
).
Inside
of
GHC
is
a
file
named
GenApply
.
hs
that
generates
most
of
these
functions
.
See
the
Gist
link
in
the
reading
section
for
the
current
source
file
that
GHC
generates
.
For
example
the
output
for
stg
_
ap
_
p
_
fast
.
Handwritten
Cmm
can
be
included
in
a
module
manually
by
first
compiling
it
through
GHC
into
an
object
and
then
using
a
special
FFI
invocation
.
See
:
Cmm
Runtime
:
GHC
will
place
the
info
table
for
a
toplevel
closure
directly
next
to
the
entry
-
code
for
the
objects
in
memory
such
that
the
fields
from
the
info
table
can
be
accessed
by
pointer
arithmetic
on
the
function
pointer
to
the
code
itself
.
Not
performing
this
optimization
would
involve
chasing
through
one
more
pointer
to
get
to
the
info
table
.
Given
how
often
info
-
tables
are
accessed
using
the
tables
-
next
-
to
-
code
optimization
results
in
a
tractable
speedup
.
Depending
on
the
type
of
the
closure
involved
GHC
will
utilize
the
last
few
bits
in
a
pointer
to
the
closure
to
store
information
that
can
be
read
off
from
the
bits
of
pointer
itself
before
jumping
into
or
access
the
info
tables
.
For
thunks
this
can
be
information
like
whether
it
is
evaluated
to
WHNF
or
not
for
constructors
it
contains
the
constructor
tag
(
if
it
fits
)
to
avoid
an
info
table
lookup
.
Depending
on
the
architecture
the
tag
bits
are
either
the
last
2
or
3
bits
of
a
pointer
.
These
occur
in
Cmm
most
frequently
via
the
following
macro
definitions
:
So
for
instance
in
many
of
the
precompiled
functions
there
will
be
a
test
for
whether
the
active
closure
R
1
is
already
evaluated
.
During
compilation
GHC
will
produce
interface
files
for
each
module
that
are
the
binary
encoding
of
specific
symbols
(
functions
typeclasses
etc
)
exported
by
that
modules
as
well
as
any
package
dependencies
it
itself
depends
on
.
This
is
effectively
the
serialized
form
of
the
ModGuts
structure
used
internally
in
the
compiler
.
The
internal
structure
of
this
file
can
be
dumped
using
the
--
show
-
iface
flag
.
The
precise
structure
changes
between
versions
of
GHC
.
EKG
is
a
monitoring
tool
that
can
monitor
various
aspect
of
GHC
'
s
runtime
alongside
an
active
process
.
The
interface
for
the
output
is
viewable
within
a
browser
interface
.
The
monitoring
process
is
forked
off
(
in
a
system
thread
)
from
the
main
process
.
The
GHC
runtime
system
can
be
asked
to
dump
information
about
allocations
and
percentage
of
wall
time
spent
in
various
portions
of
the
runtime
system
.
Productivity
indicates
the
amount
of
time
spent
during
execution
compared
to
the
time
spent
garbage
collecting
.
Well
tuned
CPU
bound
programs
are
often
in
the
90
-
99
%
range
of
productivity
range
.
In
addition
individual
function
profiling
information
can
be
generated
by
compiling
the
program
with
-
prof
flag
.
The
resulting
information
is
outputted
to
a
.
prof
file
of
the
same
name
as
the
module
.
This
is
useful
for
tracking
down
hotspots
in
the
program
.
Several
libraries
exist
to
mechanize
the
process
of
writing
name
capture
and
substitution
since
it
is
largely
mechanical
.
Probably
the
most
robust
is
the
unbound
library
.
For
example
we
can
implement
the
infer
function
for
a
small
Hindley
-
Milner
system
over
a
simple
typed
lambda
calculus
without
having
to
write
the
name
capture
and
substitution
mechanics
ourselves
.
Recently
unbound
was
ported
to
use
GHC
.
Generics
instead
of
Template
Haskell
.
The
API
is
effectively
the
same
so
for
example
a
simple
lambda
calculus
could
be
written
as
:
See
:
LLVM
is
a
library
for
generating
machine
code
.
The
llvm
-
general
bindings
provide
a
way
to
model
compile
and
execute
LLVM
bytecode
from
within
the
Haskell
runtime
.
Generates
the
following
textual
LLVM
IR
which
can
them
be
executed
using
the
JIT
in
the
llvm
-
general
package
or
passed
to
the
various
llvm
commandline
utilities
.
See
:
Pretty
printer
combinators
compose
logic
to
print
strings
.
The
pretty
printed
form
of
the
k
combinator
:
The
Text
.
Show
.
Pretty
library
can
be
used
to
pretty
print
nested
data
structures
in
a
more
human
readable
form
for
any
type
that
implements
Show
.
For
example
a
dump
of
the
structure
for
the
AST
of
SK
combinator
with
ppShow
.
Adding
the
following
to
your
ghci
.
conf
can
be
useful
for
working
with
deeply
nested
structures
interactively
.
See
:
wl
-
pprint
-
text
is
a
Wadler
-
style
pretty
printing
library
that
uses
Text
builder
objects
for
efficient
generation
under
the
hood
.
It
exposes
effectively
the
same
interface
as
the
String
-
based
pretty
library
but
is
much
more
performant
.
See
:
TODO
Haskeline
is
cross
-
platform
readline
support
which
plays
nice
with
GHCi
as
well
.
Certain
sets
of
tasks
in
building
command
line
REPL
interfaces
are
so
common
that
is
becomes
useful
to
abstract
them
out
into
a
library
.
While
haskeline
provides
a
sensible
lower
-
level
API
for
interfacing
with
GNU
readline
it
is
somewhat
tedious
to
implement
tab
completion
logic
and
common
command
logic
over
and
over
.
To
that
end
Repline
assists
in
building
interactive
shells
that
that
resemble
GHCi
'
s
default
behavior
.
Trying
it
out
.
(
&
lt
;
TAB
&
gt
;
indicates
a
user
keypress
)
See
:
This
is
an
advanced
section
knowledge
of
TemplateHaskell
is
not
typically
necessary
to
write
Haskell
.
Template
Haskell
is
a
very
powerful
set
of
abstractions
some
might
say
too
powerful
.
It
effectively
allows
us
to
run
arbitrary
code
at
compile
-
time
to
generate
other
Haskell
code
.
You
can
some
absolutely
crazy
things
like
going
off
and
reading
from
the
filesystem
or
doing
network
calls
that
informs
how
your
code
compiles
leading
to
non
-
deterministic
builds
.
While
in
some
extreme
cases
TH
is
useful
some
discretion
is
required
when
using
this
in
production
setting
.
TemplateHaskell
can
cause
your
build
times
to
grow
without
bound
force
you
to
manually
sort
all
definitions
your
modules
and
generally
produce
unmaintainable
code
.
If
you
find
yourself
falling
back
on
metaprogramming
ask
yourself
what
in
my
abstractions
has
failed
me
such
that
my
only
option
is
to
write
code
that
writes
code
.
Consideration
should
be
used
before
enabling
TemplateHaskell
.
Consider
an
idiomatic
solution
first
.
Quasiquotation
allows
us
to
express
"
quoted
"
blocks
of
syntax
that
need
not
necessarily
be
be
the
syntax
of
the
host
language
but
unlike
just
writing
a
giant
string
it
is
instead
parsed
into
some
AST
datatype
in
the
host
language
.
Notably
values
from
the
host
languages
can
be
injected
into
the
custom
language
via
user
-
definable
logic
allowing
information
to
flow
between
the
two
languages
.
In
practice
quasiquotation
can
be
used
to
implement
custom
domain
specific
languages
or
integrate
with
other
general
languages
entirely
via
code
-
generation
.
We
'
ve
already
seen
how
to
write
a
Parsec
parser
now
let
'
s
write
a
quasiquoter
for
it
.
Testing
it
out
:
One
extremely
important
feature
is
the
ability
to
preserve
position
information
so
that
errors
in
the
embedded
language
can
be
traced
back
to
the
line
of
the
host
syntax
.
Of
course
since
we
can
provide
an
arbitrary
parser
for
the
quoted
expression
one
might
consider
embedding
the
AST
of
another
language
entirely
.
For
example
C
or
CUDA
C
.
Evaluating
this
we
get
back
an
AST
representation
of
the
quoted
C
program
which
we
can
manipulate
or
print
back
out
to
textual
C
code
using
ppr
function
.
In
this
example
we
just
spliced
in
the
anti
-
quoted
Haskell
string
in
the
printf
statement
but
we
can
pass
many
other
values
to
and
from
the
quoted
expressions
including
identifiers
numbers
and
other
quoted
expressions
which
implement
the
Lift
type
class
.
For
example
now
if
we
wanted
programmatically
generate
the
source
for
a
CUDA
kernel
to
run
on
a
GPU
we
can
switch
over
the
CUDA
C
dialect
to
emit
the
C
code
.
Running
this
we
generate
:
Run
the
resulting
output
through
nvcc
-
ptx
-
c
to
get
the
PTX
associated
with
the
outputted
code
.
Of
course
the
most
useful
case
of
quasiquotation
is
the
ability
to
procedurally
generate
Haskell
code
itself
from
inside
of
Haskell
.
The
template
-
haskell
framework
provides
four
entry
points
for
the
quotation
to
generate
various
types
of
Haskell
declarations
and
expressions
.
The
logic
evaluating
splicing
and
introspecting
compile
-
time
values
is
embedded
within
the
Q
monad
which
has
a
runQ
which
can
be
used
to
evaluate
its
context
.
These
functions
of
this
monad
is
deeply
embedded
in
the
implementation
of
GHC
.
Just
as
before
TemplateHaskell
provides
the
ability
to
lift
Haskell
values
into
the
their
AST
quantities
within
the
quoted
expression
using
the
Lift
type
class
.
In
many
cases
Template
Haskell
can
be
used
interactively
to
explore
the
AST
form
of
various
Haskell
syntax
.
Using
Language
.
Haskell
.
TH
we
can
piece
together
Haskell
AST
element
by
element
but
subject
to
our
own
custom
logic
to
generate
the
code
.
This
can
be
somewhat
painful
though
as
the
source
-
language
(
called
HsSyn
)
to
Haskell
is
enormous
consisting
of
around
100
nodes
in
its
AST
many
of
which
are
dependent
on
the
state
of
language
pragmas
.
As
a
debugging
tool
it
is
useful
to
be
able
to
dump
the
reified
information
out
for
a
given
symbol
interactively
to
do
so
there
is
a
simple
little
hack
.
Splices
are
indicated
by
$(
f
)
syntax
for
the
expression
level
and
at
the
toplevel
simply
by
invocation
of
the
template
Haskell
function
.
Running
GHC
with
-
ddump
-
splices
shows
our
code
being
spliced
in
at
the
specific
location
in
the
AST
at
compile
-
time
.
At
the
point
of
the
splice
all
variables
and
types
used
must
be
in
scope
so
it
must
appear
after
their
declarations
in
the
module
.
As
a
result
we
often
have
to
mentally
topologically
sort
our
code
when
using
TemplateHaskell
such
that
declarations
are
defined
in
order
.
See
:
Template
Haskell
AST
Extending
our
quasiquotation
from
above
now
that
we
have
TemplateHaskell
machinery
we
can
implement
the
same
class
of
logic
that
it
uses
to
pass
Haskell
values
in
and
pull
Haskell
values
out
via
pattern
matching
on
templated
expressions
.
This
is
an
advanced
section
knowledge
of
TemplateHaskell
is
not
typically
necessary
to
write
Haskell
.
Just
like
at
the
value
-
level
we
can
construct
type
-
level
constructions
by
piecing
together
their
AST
.
For
example
consider
that
type
-
level
arithmetic
is
still
somewhat
incomplete
in
GHC
7
.
6
but
there
often
cases
where
the
span
of
typelevel
numbers
is
not
full
set
of
integers
but
is
instead
some
bounded
set
of
numbers
.
We
can
instead
define
operations
with
a
type
-
family
instead
of
using
an
inductive
definition
(
which
often
requires
manual
proofs
)
and
simply
enumerates
the
entire
domain
of
arguments
to
the
type
-
family
and
maps
them
to
some
result
computed
at
compile
-
time
.
For
example
the
modulus
operator
would
be
non
-
trivial
to
implement
at
type
-
level
but
instead
we
can
use
the
enumFamily
function
to
splice
in
type
-
family
which
simply
enumerates
all
possible
pairs
of
numbers
up
to
a
desired
depth
.
In
practice
GHC
seems
fine
with
enormous
type
-
family
declarations
although
compile
-
time
may
increase
a
bit
as
a
result
.
The
singletons
library
also
provides
a
way
to
automate
this
process
by
letting
us
write
seemingly
value
-
level
declarations
inside
of
a
quasiquoter
and
then
promoting
the
logic
to
the
type
-
level
.
For
example
if
we
wanted
to
write
a
value
-
level
and
type
-
level
map
function
for
our
HList
this
would
normally
involve
quite
a
bit
of
boilerplate
now
it
can
stated
very
concisely
.
This
is
an
advanced
section
knowledge
of
TemplateHaskell
is
not
typically
necessary
to
write
Haskell
.
Probably
the
most
common
use
of
Template
Haskell
is
the
automatic
generation
of
type
-
class
instances
.
Consider
if
we
wanted
to
write
a
simple
Pretty
printing
class
for
a
flat
data
structure
that
derived
the
ppr
method
in
terms
of
the
names
of
the
constructors
in
the
AST
we
could
write
a
simple
instance
.
In
a
separate
file
invoke
the
pretty
instance
at
the
toplevel
and
with
--
ddump
-
splice
if
we
want
to
view
the
spliced
class
instance
.
Haskell
no
language
support
for
multiline
strings
literals
although
we
can
emulate
this
by
using
a
quasiquoter
.
The
resulting
String
literal
is
then
converted
using
toString
into
whatever
result
type
is
desired
.
In
a
separate
module
we
can
then
enable
Quasiquotes
and
embed
the
string
.
Often
times
it
is
neccessary
to
embed
the
specific
Git
version
hash
of
a
build
inside
the
exectuable
.
Using
git
-
embed
the
compiler
will
effectivelly
shell
out
to
the
command
line
to
retrieve
the
version
information
of
the
CWD
Git
repostory
and
use
Template
Haskell
to
define
embed
this
information
at
compile
-
time
.
This
is
often
useful
for
embedding
in
--
version
information
in
the
command
line
interface
to
your
program
or
service
.
See
:
git
-
embed
This
is
an
advanced
section
knowledge
of
category
theory
is
not
typically
necessary
to
write
Haskell
.
Alas
we
come
to
the
topic
of
category
theory
.
Some
might
say
all
discussion
of
Haskell
eventually
leads
here
at
one
point
or
another
.
Nevertheless
the
overall
importance
of
category
theory
in
the
context
of
Haskell
has
been
somewhat
overstated
and
unfortunately
mystified
to
some
extent
.
The
reality
is
that
amount
of
category
theory
which
is
directly
applicable
to
Haskell
roughly
amounts
to
a
subset
of
the
first
chapter
of
any
undergraduate
text
.
And
even
then
no
actual
knowledge
of
category
theory
is
required
to
use
Haskell
at
all
.
Grossly
speaking
category
theory
is
not
terribly
important
to
Haskell
programming
and
although
some
libraries
derive
some
inspiration
from
the
subject
;
most
do
not
.
What
is
more
important
is
a
general
understanding
of
equational
reasoning
and
a
familiarity
with
various
algebraic
relations
.
Certain
relations
show
up
so
frequently
we
typically
refer
to
their
properties
by
name
(
often
drawn
from
an
equivalent
abstract
algebra
concept
).
Consider
a
binary
operation
a
`
op
`
b
and
a
unary
operation
f
.
Associativity
Commutativity
Units
Inversion
Zeros
Linearity
Idempotency
Distributivity
Anticommutativity
And
of
course
combinations
of
these
properties
over
multiple
functions
gives
rise
to
higher
order
systems
of
relations
that
occur
over
and
over
again
throughout
functional
programming
and
once
we
recognize
them
we
can
abstract
over
them
.
For
instance
a
monoid
is
a
combination
of
a
unit
and
a
single
associative
operation
over
a
set
of
values
.
The
most
basic
structure
is
a
category
which
is
an
algebraic
structure
of
objects
(
Obj
)
and
morphisms
(
Hom
)
with
the
structure
that
morphisms
compose
associatively
and
the
existence
of
an
identity
morphism
for
each
object
.
With
kind
polymorphism
enabled
we
can
write
down
the
general
category
parameterized
by
a
type
variable
"
c
"
for
category
and
the
instance
Hask
the
category
of
Haskell
types
with
functions
between
types
as
morphisms
.
Categories
are
interesting
since
they
exhibit
various
composition
properties
and
ways
in
which
various
elements
in
the
category
can
be
composed
and
rewritten
while
preserving
several
invariants
about
the
program
.
Two
objects
of
a
category
are
said
to
be
isomorphic
if
we
can
construct
a
morphism
with
2
-
sided
inverse
that
takes
the
structure
of
an
object
to
another
form
and
back
to
itself
when
inverted
.
Such
that
:
For
example
the
types
Either
()
a
and
Maybe
a
are
isomorphic
.
One
of
the
central
ideas
is
the
notion
of
duality
that
reversing
some
internal
structure
yields
a
new
structure
with
a
"
mirror
"
set
of
theorems
.
The
dual
of
a
category
reverse
the
direction
of
the
morphisms
forming
the
category
C
Op
.
See
:
Functors
are
mappings
between
the
objects
and
morphisms
of
categories
that
preserve
identities
and
composition
.
Natural
transformations
are
mappings
between
functors
that
are
invariant
under
interchange
of
morphism
composition
order
.
Such
that
for
a
natural
transformation
h
we
have
:
The
simplest
example
is
between
(
f
=
List
)
and
(
g
=
Maybe
)
types
.
Regardless
of
how
we
chase
safeHead
we
end
up
with
the
same
result
.
Or
consider
the
Functor
(-&
gt
;)
.
A
lot
of
the
expressive
power
of
Haskell
types
comes
from
the
interesting
fact
that
with
a
few
caveats
polymorphic
Haskell
functions
are
natural
transformations
.
See
:
You
Could
Have
Defined
Natural
Transformations
TODO
The
Yoneda
lemma
is
an
elementary
but
deep
result
in
Category
theory
.
The
Yoneda
lemma
states
that
for
any
functor
F
the
types
F
a
and
â
b
.
(
a
-&
gt
;
b
)
-&
gt
;
F
b
are
isomorphic
.
So
that
we
have
:
The
most
broad
hand
-
wavy
statement
of
the
theorem
is
that
an
object
in
a
category
can
be
represented
by
the
set
of
morphisms
into
it
and
that
the
information
about
these
morphisms
alone
sufficiently
determines
all
properties
of
the
object
itself
.
In
terms
of
Haskell
types
given
a
fixed
type
a
and
a
functor
f
if
we
have
some
a
higher
order
polymorphic
function
g
that
when
given
a
function
of
type
a
-&
gt
;
b
yields
f
b
then
the
behavior
g
is
entirely
determined
by
a
-&
gt
;
b
and
the
behavior
of
g
can
written
purely
in
terms
of
f
a
.
DeMorgan
'
s
Law
See
:
Kleisli
composition
(
i
.
e
.
Kleisli
Fish
)
is
defined
to
be
:
The
monad
laws
stated
in
terms
of
the
Kleisli
category
of
a
monad
m
are
stated
much
more
symmetrically
as
one
associativity
law
and
two
identity
laws
.
Stated
simply
that
the
monad
laws
above
are
just
the
category
laws
in
the
Kleisli
category
.
For
example
Just
is
just
an
identity
morphism
in
the
Kleisli
category
of
the
Maybe
monad
.
Let
us
attempt
to
objectively
compare
Haskell
to
other
programming
languages
with
regards
to
which
language
principles
they
share
and
in
what
respects
they
differ
.
These
comparisons
are
not
advisements
to
use
or
avoid
any
of
these
languages
but
rather
statements
of
the
similarities
and
differences
between
them
at
the
language
level
.
No
notion
of
"
weak
"
or
"
strong
"
typing
will
be
discussed
because
the
terms
have
no
universal
meaning
.
No
notion
of
"
object
-
oriented
"
or
"
functional
"
paradigms
will
be
discussed
because
the
terms
have
no
universal
meaning
.
Haskell
'
s
genesis
happened
in
1987
at
the
Functional
Programming
Languages
and
Computer
Architecture
conference
in
Portland
OR
.
Participants
had
achieved
a
consensus
that
there
was
a
profusion
of
non
-
strict
pure
languages
and
concluded
that
this
excess
was
hampering
the
development
and
wider
use
of
such
languages
.
Subsequently
a
committee
was
formed
to
design
a
new
pure
lazy
general
purpose
programming
language
.
Out
of
this
collaboration
emerged
Haskell
named
for
logician
Haskell
B
.
Curry
upon
whose
research
the
logical
underpinnings
of
the
Haskell
language
rest
.
Since
1987
the
Haskell
language
standard
has
continued
to
evolve
.
Haskell
1
.
0
was
released
in
April
of
1990
with
particularly
significant
updates
to
the
standard
released
in
1998
and
2010
.
Haskell
'
s
main
implementation
is
ghc
.
GHC
is
licenced
under
a
permissive
non
-
copyleft
3
-
clause
BSD
-
style
licence
.
Haskell
is
a
general
purpose
language
.
Haskell
is
garbage
collected
.
Haskell
is
compiled
through
a
custom
native
code
generator
.
Haskell
is
statically
typed
.
Haskell
allows
polymorphism
by
means
of
parametric
polymorphism
and
ad
-
hoc
polymorphism
through
typeclasses
.
Haskell
is
pure
and
statically
tracks
effects
.
Haskell
employs
lazy
evaluation
by
default
using
call
-
by
-
need
.
Haskell
'
s
package
manager
is
cabal
-
install
or
stack
.
OCaml
originally
known
as
Objective
Caml
is
the
main
implementation
of
the
Caml
programming
language
.
The
type
system
of
OCaml
is
significantly
less
advanced
than
modern
GHC
Haskell
and
does
not
supported
higher
-
kinded
types
or
type
-
level
programming
to
the
extent
that
has
become
prevalent
in
portions
of
recent
Haskell
.
The
OCaml
compiler
is
also
significantly
less
advanced
than
modern
GHC
runtime
and
largely
does
not
perform
any
compiler
optimizations
or
program
transformations
.
The
language
itself
does
have
several
advantages
over
Haskell
in
that
is
has
a
module
system
.
Although
it
is
possible
to
write
pure
OCaml
there
is
no
language
-
integrated
support
and
the
current
engineering
practice
around
the
language
encourages
ubiquitous
impurity
in
third
-
party
libraries
.
Main
difference
:
Both
have
fairly
modern
type
systems
but
OCaml
does
not
enforce
purity
and
uses
call
-
by
-
value
.
OCaml
'
s
main
implementation
is
ocamlc
.
The
OCaml
compiler
is
distributed
under
the
Q
Public
licence
a
permissive
non
-
copyleft
FLOSS
licence
.
Some
portions
of
the
OCaml
libaries
are
licensed
under
the
GPLv
2
.
See
the
OCaml
GitHub
page
for
more
information
about
licensing
specifics
.
OCaml
is
a
general
purpose
language
.
OCaml
is
a
statically
typed
language
.
OCaml
is
garbage
collected
.
OCaml
allows
polymorphism
by
means
of
parametric
polymorphism
and
ad
-
hoc
polymorphism
through
modular
implicits
.
OCaml
has
a
module
system
and
functors
.
OCaml
is
not
an
optimizing
compiler
.
OCaml
is
impure
by
default
and
does
not
statically
track
effects
.
OCaml
'
s
evaluation
is
call
-
by
-
value
.
OCaml
has
a
package
manager
called
OPAM
.
Standard
ML
was
a
general
-
purpose
modular
functional
programming
language
with
compile
-
time
type
checking
and
type
inference
.
Standard
ML
was
traditionally
a
general
purpose
language
although
it
'
s
lack
of
a
modern
compiler
largely
only
makes
it
useful
for
work
on
pure
type
theory
and
proof
assistants
and
not
in
industrial
settings
.
Standard
ML
has
been
largely
abandoned
in
recent
years
and
is
a
good
example
of
a
promising
language
that
withered
on
the
vine
from
a
lack
of
engineering
effort
devoted
toward
the
backend
compiler
.
Main
difference
:
Standard
ML
is
no
longer
actively
developed
Haskell
is
.
Standard
ML
'
s
main
implementation
is
smlnj
.
Other
implementations
existed
in
mlton
and
polyml
.
Standard
ML
has
no
package
manager
.
Standard
ML
allows
polymorphism
by
means
of
parametric
polymorphism
.
Standard
ML
has
a
module
system
and
functors
.
Standard
ML
is
a
statically
typed
language
.
Standard
ML
is
impure
by
default
and
does
not
statically
track
effects
.
Standard
ML
implementations
are
typically
garbage
collected
.
Standard
ML
'
s
evaluation
is
call
-
by
-
value
.
Standard
ML
employs
strict
evaluation
.
Agda
is
a
dependently
typed
functional
programming
language
used
in
type
theory
research
.
Unlike
Coq
has
no
support
for
tactics
and
proofs
are
written
in
a
functional
programming
style
.
Main
difference
:
Agda
is
not
a
general
purpose
language
Haskell
is
.
Agda
is
not
used
to
write
executable
programs
for
practical
uses
outside
of
research
.
Agda
'
s
main
implementation
is
agda
.
Agda
is
not
a
general
purpose
language
it
is
largely
used
as
a
proof
environment
and
tool
for
constructive
mathematics
.
Agda
has
no
package
manager
.
Agda
is
a
statically
typed
language
.
Coq
is
an
interactive
theorem
prover
based
on
the
calculus
of
inductive
constructions
.
It
compiles
into
a
Core
language
called
Gallina
whose
defining
feature
is
that
it
is
weakly
normalizing
(
i
.
e
.
all
programs
terminate
).
Although
Coq
allows
limited
extraction
of
some
programs
to
other
languages
it
is
not
by
itself
a
programming
language
in
the
traditional
sense
most
Coq
programs
are
not
run
or
compiled
.
Main
difference
:
Coq
is
not
a
general
purpose
language
Haskell
is
.
Coq
'
s
main
implementation
is
coq
.
Coq
is
not
a
general
purpose
language
it
is
largely
used
as
a
proof
environment
.
Coq
is
a
statically
typed
language
.
Idris
is
a
general
-
purpose
purely
functional
programming
language
with
dependent
types
.
Main
difference
:
Idris
has
dependent
types
and
call
-
by
-
value
semantics
Haskell
does
not
have
dependent
types
and
uses
call
-
by
-
need
.
Idris
'
s
main
implementation
is
idris
.
Idris
is
a
general
purpose
language
.
Idris
allows
polymorphism
by
means
of
parametric
polymorphism
and
ad
-
hoc
polymorphism
.
Idris
'
s
evaluation
is
call
-
by
-
value
.
Idris
is
a
statically
typed
language
.
Idris
is
garbage
collected
by
default
although
there
is
some
novel
work
on
uniqueness
types
which
can
statically
guarantee
aliasing
properties
of
references
.
Idris
is
pure
and
statically
tracks
effects
.
Rust
is
a
general
-
purpose
multi
-
paradigm
compiled
programming
language
developed
by
Mozilla
Research
.
It
incorporates
many
of
the
foundational
ideas
of
Haskell
'
s
type
system
but
uses
a
more
traditional
imperative
evaluation
model
.
Rust
includes
type
inference
ad
-
hoc
polymorphism
sum
types
and
option
chaining
as
safe
exception
handling
.
Notably
Rust
lacks
higher
-
kinded
types
which
does
not
allow
many
modern
functional
abstractions
to
be
encoded
in
the
language
.
Rust
does
not
enforce
purity
or
track
effects
but
has
a
system
for
statically
analyzing
lifetimes
of
references
informing
the
efficient
compilation
of
many
language
constructs
to
occur
without
heap
allocation
.
Main
difference
:
Rust
is
a
modern
imperative
typed
language
Haskell
is
a
modern
functional
typed
language
with
recent
type
system
.
Rust
does
not
have
the
capacity
to
distinguish
between
pure
and
impure
functions
at
the
language
level
.
Rust
'
s
main
implementation
is
rustc
.
Rust
is
a
statically
typed
language
.
Rust
is
a
general
purpose
language
.
Rust
'
s
package
manager
is
Cargo
.
Rust
allows
polymorphism
by
means
of
parametric
polymorphism
and
ad
-
hoc
polymorphism
.
Rust
is
not
garbage
collected
by
default
instead
uses
static
semantics
to
analyze
lifetimes
.
Optionally
supports
garbage
collection
.
Rust
is
impure
by
default
and
does
not
statically
track
effects
.
It
does
however
have
static
tracking
of
memory
allocations
and
lifetimes
.
Purescript
is
a
Haskell
-
like
language
that
compiles
into
Javascript
for
evaluation
within
a
web
browser
.
Semantically
it
is
very
close
to
Haskell
except
that
is
uses
a
call
-
by
-
value
model
instead
of
Haksell
'
s
call
-
by
-
need
.
The
type
system
is
a
superset
of
Haskell
2010
and
includes
ad
-
hoc
polymorphism
parametric
polymorphism
rank
-
n
polymorphism
row
-
polymorphism
higher
-
kinded
types
and
full
algebraic
data
types
.
Main
difference
:
Purescript
targets
Javascript
in
the
browser
while
GHC
Haskell
is
designed
to
work
on
top
of
the
GHC
managed
runtime
.
Purescript
'
s
main
implementation
is
purescript
.
Purescript
is
a
statically
typed
language
.
Purescript
'
s
evaluation
is
call
-
by
-
value
.
Purescript
is
pure
and
statically
tracks
effects
using
an
extensible
record
system
embedded
in
the
Eff
monad
.
Elm
is
a
ML
-
like
language
that
compiles
into
Javascript
for
evaluation
within
a
web
browser
.
Main
difference
:
Elm
targets
Javascript
in
the
browser
while
GHC
Haskell
is
designed
to
work
on
top
of
the
GHC
managed
runtime
.
Elm
lacks
any
semblance
of
a
modern
ML
type
system
features
and
has
no
coherent
story
for
overloading
modules
or
higher
polymorphism
.
Elm
'
s
main
implementation
is
elm
.
Elm
is
a
statically
typed
language
.
Elm
targets
Javascript
and
is
"
transpiled
"
to
Javascript
source
code
to
be
run
exclusively
in
a
browser
or
Javascript
interpreter
.
Elm
allows
polymorphism
by
means
of
parametric
polymorphism
.
Elm
is
pure
and
statically
tracks
effects
.
Python
is
a
widely
used
general
-
purpose
high
-
level
programming
language
.
It
is
based
on
object
-
style
of
programming
constructions
and
allows
first
class
functions
and
higher
order
functions
.
Python
is
unityped
and
is
notable
for
it
'
s
simplistic
runtime
and
global
mutex
preventing
concurrency
.
Main
difference
:
Python
is
unityped
and
imperative
Haskell
is
statically
typed
.
Python
'
s
main
implementation
is
cpython
.
Python
is
a
unityped
language
.
Python
is
impure
by
default
and
does
not
statically
track
effects
.
Python
internally
refers
to
runtime
value
tags
as
types
which
differs
from
the
Haskell
notion
of
types
.
Python
allows
polymorphism
by
means
of
unityping
all
functions
can
take
any
type
.
R
is
a
programming
language
and
software
environment
for
statistical
computing
and
graphics
.
The
R
language
is
widely
used
among
statisticians
and
data
miners
for
developing
statistical
software
and
data
analysis
Main
difference
:
R
is
unityped
and
domain
specific
language
Haskell
is
statically
typed
and
general
purpose
.
R
'
s
main
implementation
is
r
.
R
is
a
unityped
language
.
R
allows
polymorphism
by
means
of
unityping
.
R
internally
refers
to
runtime
value
tags
as
types
which
differs
from
the
Haskell
notion
of
types
.
R
is
interpreted
.
Julia
is
a
high
-
level
dynamic
programming
language
designed
to
address
the
requirements
of
high
-
performance
numerical
and
scientific
computing
.
Main
difference
:
Julia
is
unityped
and
imperative
Haskell
is
statically
typed
.
Julia
'
s
main
implementation
is
juliia
.
Julia
is
a
unityped
language
.
Julia
allows
polymorphism
by
means
of
unityping
.
Julia
internally
refers
to
runtime
value
tags
as
types
which
differs
from
the
Haskell
notion
of
types
.
Julia
is
compiled
through
the
LLVM
framework
.
Erlang
is
a
general
-
purpose
programming
language
and
runtime
environment
.
Erlang
has
built
-
in
support
for
concurrency
distribution
and
fault
tolerance
.
Main
difference
:
Erlang
is
unityped
and
imperative
Haskell
is
statically
typed
and
functional
.
Erlang
'
s
main
implementation
is
erl
.
Erlang
is
a
unityped
language
.
Erlang
is
interpreted
.
Erlang
allows
polymorphism
by
means
of
unityping
.
Erlang
'
s
evaluation
is
call
-
by
-
value
.
Erlang
internally
refers
to
runtime
value
tags
as
types
which
differs
from
the
Haskell
notion
of
types
.
Erlang
is
impure
by
default
and
does
not
statically
track
effects
.
Java
is
a
general
purpose
programming
language
.
It
is
an
object
-
oriented
concurrent
language
which
is
statically
typed
.
It
is
one
of
the
most
frequently
used
languages
in
the
industry
as
well
as
a
common
language
used
in
academia
to
teach
the
fundamentals
of
object
oriented
programming
.
Main
difference
:
Java
is
an
object
-
oriented
language
compared
to
Haskell
which
is
functional
.
Java
is
statically
compiled
to
Java
Bytecode
which
can
be
ran
on
a
Java
Virtual
Machine
.
Java
'
s
most
recent
version
is
Java
8
Java
is
cross
-
platform
.
It
can
be
ran
on
Linux
Windows
and
Mac
.
Clojure
is
a
modern
LISP
dialect
that
emphasizes
immutability
.
It
does
not
enforce
safety
and
idiomatic
clojure
often
includes
mutable
references
and
destructive
updates
.
There
are
some
efforts
toward
an
optional
typing
system
provided
by
the
core
.
typed
.
Main
difference
:
Clojure
is
a
unityped
typed
Lisp
dialect
while
Haskell
is
in
the
ML
family
.
Clojure
'
s
main
implementation
is
clojure
.
Clojure
is
a
unityped
language
.
Clojure
allows
polymorphism
by
means
of
unityping
.
Clojure
is
garbage
collected
.
Clojure
internally
refers
to
runtime
value
tags
as
types
which
differs
from
the
Haskell
notion
of
types
.
Clojure
is
compiled
to
Java
Virtual
Machine
bytecode
.
Swift
is
a
multi
-
paradigm
language
created
for
iOS
and
OS
X
development
by
Apple
.
Swift
incorporates
recent
developments
in
language
design
and
uncommonly
includes
return
type
polymorphism
type
inference
ad
-
hoc
polymorphism
sum
types
and
option
chaining
as
safe
exception
handling
.
Swift
does
not
enforce
purity
or
track
effects
and
allows
mutable
and
destructive
updates
.
Main
difference
:
Swift
is
reasonably
modern
imperative
typed
language
Haskell
is
a
modern
functional
typed
language
.
Swift
'
s
main
implementation
is
swiftc
.
Swift
allows
polymorphism
by
means
of
parametric
polymorphism
and
ad
-
hoc
polymorphism
through
through
inheritance
interfaces
and
reflection
.
Swift
is
garbage
collected
.
Swift
is
a
statically
typed
language
.
Swift
is
compiled
through
the
LLVM
framework
.
Swift
does
not
have
an
effect
system
.
C
#
is
a
typed
class
-
based
single
-
inheritance
object
-
oriented
programming
language
originally
developed
at
Microsoft
as
the
flagship
language
for
the
.
NET
framework
.
Early
versions
closely
resemble
Java
but
the
language
has
since
picked
up
a
few
influences
from
declarative
and
functional
programming
paradigms
.
.
NET
is
Windows
-
only
but
a
cross
-
platform
replacement
Mono
exists
that
makes
it
possible
to
run
.
NET
code
on
OS
X
and
Linux
.
Main
difference
:
C
#
is
an
impure
object
-
oriented
language
Haskell
is
a
pure
functional
language
.
C
#'
s
main
implementation
is
C
#.
NET
.
C
#
is
a
general
purpose
programming
language
.
C
#
is
garbage
collected
(
but
allows
opting
out
of
GC
through
the
use
of
unsafe
blocks
)
C
#
is
a
statically
typed
language
with
limited
type
inference
and
some
support
for
dynamic
typing
.
C
#
allows
polymorphism
by
means
of
parametric
polymorphism
through
generics
ad
-
hoc
polymorphism
through
inheritance
interfaces
and
reflection
.
C
#
is
impure
and
does
not
track
effects
.
C
#
is
typically
compiled
to
.
NET
IL
which
is
then
interpreted
by
the
.
NET
runtime
.
C
++
is
a
typed
multi
-
paradigm
(
imperative
structured
/
procedural
class
-
based
multiple
-
inheritance
object
-
oriented
template
metaprogramming
)
programming
language
developed
by
Bjarne
Stroustrup
in
the
early
1980
s
.
The
philosophy
strongly
favors
zero
-
cost
abstractions
and
values
performance
higher
than
convenience
.
This
has
made
the
language
extremely
large
and
complex
and
the
culture
and
ecosystem
diverse
and
fractured
.
Today
C
++
is
mainly
found
in
legacy
projects
but
remains
popular
in
areas
where
realtime
performance
and
deterministic
memory
allocation
are
critical
such
as
embedded
audio
/
video
games
HFT
etc
.
Main
difference
:
C
++
is
impure
and
uses
RAII
Haskell
is
pure
and
garbage
-
collected
.
C
++
has
no
canonical
implementation
;
notable
compilers
include
gcc
clang
and
MSVC
++
.
C
++
is
a
general
purpose
programming
language
with
a
bias
towards
systems
programming
.
C
++
is
not
garbage
collected
.
Manual
memory
management
(
as
in
C
)
is
supported
but
the
recommended
paradigm
is
RAII
.
C
++
is
a
statically
typed
language
with
limited
type
inference
and
many
backdoors
to
bypass
the
type
checker
.
C
++
allows
polymorphism
by
means
of
parametric
polymorphism
through
template
metaprogramming
and
ad
-
hoc
polymorphism
through
inheritance
.
C
++
is
compiled
the
typical
compilation
target
is
native
machine
code
.
C
++
does
not
track
effects
.
It
has
limited
support
for
tracking
mutability
at
the
type
level
.
Go
is
a
programming
language
developed
at
Google
.
Although
Go
is
statically
typed
it
has
failed
to
integrate
most
modern
advances
in
programming
language
design
done
after
the
1970
s
and
instead
chooses
a
seemingly
regressive
design
.
Most
notably
it
lacks
any
notion
of
generics
while
polymorphism
is
achieved
either
by
manual
code
duplication
or
unsafe
coercions
.
Main
difference
:
Go
is
a
language
designed
around
the
idea
that
language
design
has
not
advanced
since
1970
while
Haskell
incorporates
many
ideas
from
modern
research
.
Go
'
s
main
implementation
is
go
.
Go
is
a
statically
typed
language
.
Go
has
no
safe
polymorphism
.
Go
is
statically
compiled
with
a
custom
toolchain
.
Go
is
garbage
collected
.
Go
does
not
have
an
effect
system
.
Scala
is
a
general
purpose
multi
-
paradigm
language
.
Like
Java
Scala
is
object
-
oriented
and
uses
a
curly
-
brace
syntax
reminiscent
of
the
C
programming
language
.
Unlike
Java
Scala
has
many
features
of
functional
programming
languages
like
Scheme
Standard
ML
and
Haskell
including
currying
type
inference
immutability
lazy
evaluation
and
pattern
matching
.
Main
difference
:
Scala
mixes
functional
programming
with
imperative
programming
and
does
not
take
a
language
-
integrated
stance
on
purity
or
effect
tracking
which
breaks
equational
reasoning
.
External
libraries
and
frameworks
exist
that
embrace
functional
programming
more
effectively
but
it
is
not
enforced
and
imperative
code
and
thin
wrappers
around
Java
libs
quite
often
leaks
industrial
codebases
.
Scala
'
s
main
implementation
is
scala
.
Scala
is
a
statically
typed
language
.
Scala
allows
polymorphism
by
means
of
parametric
polymorphism
and
ad
-
hoc
polymorphism
through
implicits
.
Scala
is
garbage
collected
.
Scala
language
does
not
have
an
effect
system
.
Scala
is
statically
compiled
to
Java
Virtual
Machien
bytecode
.
JavaScript
is
a
high
-
level
dynamic
untyped
and
interpreted
programming
language
that
was
ubiquitous
in
web
development
during
the
90
s
and
00
s
.
Javascript
is
most
kindly
described
as
a
language
that
"
just
happened
"
and
an
enduring
testament
to
human
capacity
to
route
around
problems
.
Main
difference
:
Like
many
web
technologies
Javascript
"
just
happened
"
and
it
'
s
design
was
dominated
by
economic
factors
.
Haskell
was
designed
with
some
insight
into
the
end
result
.
Javascripts
implementations
include
NodeJS
V
8
and
spidermoneky
.
Javascript
is
a
unityped
language
.
Javascript
is
interpreted
tracing
JIT
specialization
is
common
.
Javascript
allows
polymorphism
by
means
of
unityping
.
Javascript
internally
refers
to
runtime
value
tags
as
types
which
differs
from
the
Haskell
notion
of
types
.
The
majority
of
Javascript
implementations
are
garbage
collected
.
What
I
Wish
I
Knew
When
Learning
Haskell
2
.
3
(
Stephen
Diehl
)**************************************コト
バンク
アクセス
ページ
ご覧
ページ
リンク
アドレス
(
URL
)
タイプ
ミス
アドレス
URL
確認
Yahoo
!
辞書
コト
バンク
Yahoo
!
辞書
技術
提携
コト
バンク
朝日新聞社
登録
商標
コト
バンク
サイト
著作
権
(
株
)
朝日新聞社
(
株
)
VOYAGE
GROUP
帰属
サイト
提供
用語
解説
著作
権
(
株
)
朝日新聞社
(
株
)
朝日新聞
出版
等
権利
者
帰属
©
The
Asahi
Shimbun
Company
/
VOYAGE
GROUP
Inc
.
All
rights
reserved
.
No
reproduction
or
republication
without
written
permission
.
コト
バンク
-
ページ**************************************Brackets
A
modern
open
source
text
editor
that
understands
web
design
.
Why
Use
Brackets
?
Made
with
♥
and
JavaScript
New
Features
Popular
Extensions
Recent
Blog
Posts
Inline
Editors
Live
Preview
Preprocessor
Support
Emmet
Beautify
File
Icons
Indent
Guides
Git
Autoprefixer
W
3
C
Validation
Other
Downloads
With
focused
visual
tools
and
preprocessor
support
Brackets
is
a
modern
text
editor
that
makes
it
easy
to
design
in
the
browser
.
It
'
s
crafted
from
the
ground
up
for
web
designers
and
front
-
end
developers
.
Brackets
is
a
lightweight
yet
powerful
modern
text
editor
.
We
blend
visual
tools
into
the
editor
so
you
get
the
right
amount
of
help
when
you
want
it
without
getting
in
the
way
of
your
creative
process
.
You
'
ll
enjoy
writing
code
in
Brackets
.
Brackets
is
an
open
-
source
project
supported
by
an
active
and
passionate
community
.
It
'
s
made
by
other
web
developers
like
you
!
Learn
How
to
Contribute
Instead
of
jumping
between
file
tabs
Brackets
lets
you
open
a
window
into
the
code
you
care
about
most
.
Want
to
work
on
the
CSS
that
applies
to
a
specific
ID
?
Put
your
mouse
cursor
on
that
ID
push
Command
/
Ctrl
+
E
and
Brackets
will
show
you
all
the
CSS
selectors
with
that
ID
in
an
inline
window
so
you
can
work
on
your
code
side
-
by
-
side
without
any
popups
.
Get
a
real
-
time
connection
to
your
browser
.
Make
changes
to
CSS
and
HTML
and
you
'
ll
instantly
see
those
changes
on
screen
.
Also
see
where
your
CSS
selector
is
being
applied
in
the
browser
by
simply
putting
your
cursor
on
it
.
It
'
s
the
power
of
a
code
editor
with
the
convenience
of
in
-
browser
dev
tools
.
Work
with
preprocessors
in
a
whole
new
way
.
We
know
how
important
preprocessors
are
to
your
workflow
.
That
s
why
we
want
to
make
Brackets
the
best
code
editor
for
preprocessors
out
there
.
With
Brackets
you
can
use
Quick
Edit
and
Live
Highlight
with
your
LESS
and
SCSS
files
which
will
make
working
with
them
easier
than
ever
.
High
-
speed
HTML
and
CSS
workflow
.
Format
JavaScript
HTML
and
CSS
files
.
File
icons
in
Brackets
file
tree
.
Show
indent
guides
in
the
code
editor
.
Git
integration
for
Brackets
.
Parse
CSS
and
add
vendor
prefixes
automatically
.
Simple
W
3
C
Validator
.
Check
Out
New
Extensions
Go
to
Blog
Brackets
was
founded
by
Adobe
as
a
community
guided
open
source
project
to
push
web
development
editors
to
the
next
level
.
Brackets
is
released
under
the
MIT
License
.
Brackets
-
A
modern
open
source
code
editor
that
understands
web
design
.**************************************u
L
~
[
x
C
x
[
v
À
è
È
­
ö
®
g
o
É
ß
¢
T
C
g**************************************Cè
è
ª
ã
ª
ã
ã
å
¤
ã
ã
®
ä
ºº
ã
Cè
è
ª
ã
å
­¦
ç
¿
ã
ã
ã
®
ã
§
ã
ã
ã
ã
ï
¼
ç
®
æ
¬¡
ï
¼
å
å
¿
è
ï
¼
ï
¼
æ
¼
ç
®
å
­
ã
ª
ã
©
ã
«
ã
¤
ã
ã
¦
ï
¼
ï
¼
å
¶
å
¾¡
æ
ã
«
ã
¤
ã
ã
¦
ï
¼
ï
¼
å
¥
å
º
å
ã
«
ã
¤
ã
ã
¦
ï
¼
ï
¼
é
¢
æ
°
ã
ã
ã
­
ã
°
ã
©
ã
ã
®
æ
§
é
ã
«
ã
¤
ã
ã
¦
ï
¼
ï
¼
é
å
ã
ã
ã
¤
ã
³
ã
¿
ã
«
ã
¤
ã
ã
¦
ï
¼
ï
¼
æ
§
é
ä
½
ã
«
ã
¤
ã
ã
¦
ï
¼
Cè
è
ª
ã
®
å
­¦
ç
¿
ã
µ
ã
¤
ã
ã
§
ã
ã
Cè
è
ª
å
¥
é
ã
ä
»
æ
§
è
§£
è
ª¬
ã
ã
µ
ã
³
ã
ã
«
ã
³
ã
¼
ã
ã
®
è
ª¬
æ
ç
­
ã
ã
ã
ã
¾
ã
ã
Cã
å
­¦
ç
¿
ã
ã
¦
è
ª
ç
±
è
ª
å
ã
«
ã
ã
­
ã
°
ã
©
ã
ã
³
ã
°
ã
§
ã
ã
ã
ã
ã
«
ã
ª
ã
ã
¾
ã
ã
ã
ï
¼
ï
¼
ã
¤
ç
ç
±
ã
ã
ã
ã
æ
ã
ã
¾
ã
ã
ï
¼
ã
¤
ã
¯
ã
é
«
ç
è
è
ª
ã
§
ã
ã
ã
ª
ã
ã
ã
ä
½
æ
°´
æ
º
ã
®
é
¢
ã
æ
ã
¤
ã
ã
ã
ã
§
ã
ã
è
§£
ã
ã
ã
ã
ã
ã
ã
ã
ä
ºº
ã
ä
½¿
ã
è
è
ã
«
è
¿
ã
è
¡¨
ç
¾
ã
§
ã
ã
­
ã
°
ã
©
ã
ã
è
è
¿°
ã
ã
ã
ã
­
ã
°
ã
©
ã
ã
³
ã
°
è
è
ª
ã
§
ã
ã
ã
ã
ã
ã
¼
ã
ã
¦
ã
§
ã
¢
ã
«
å
¯
ç
ã
ã
å
¦
ç
ã
å
®¹
æ
ã
«
è
è
¿°
ã
§
ã
ã
ã
ã
ã
ã
ã
ã
ã
§
ã
ã
ã
ã
®
ã
ã
ã
Cè
è
ª
ã
å
­¦
ç
¿
ã
ã
¦
ã
ã
ã
°
ã
OSã
ã
ã
©
ã
¤
ã
ã
ª
ã
©
ã
ã
ã
ã
ã
¼
ã
ã
¦
ã
§
ã
¢
å
ã
®
ã
ã
­
ã
°
ã
©
ã
ã
ã
¤
ã
ã
ã
ã
ã
å
¯
è
½
ã
§
ã
ã
ã
¾
ã
ã
ã
ã
¼
ã
ã
¦
ã
§
ã
¢
ã
ã
ã
®
ç
¥
è
­
ã
æ
ã
ã
¦
ã
ã
ã
ã
ã
¯
ã
ä
¸
è
¬
ã
®
ã
ã
­
ã
°
ã
©
ã
ã
ã
¤
ã
ã
ä
¸
ã
§
ã
é
å
¸¸
ã
«
å
½¹
ã
«
ç
«
ã
¤
ã
®
ã
§
ã
ã
ï
¼
ã
¤
ã
ã
¯
ã
å
¾
ã
«
é
ç
º
ã
ã
ã
ã
ã
­
ã
°
ã
©
ã
ã
³
ã
°
è
è
ª
ã
«
å
¤§
ã
ã
ª
å
½±
é
¿
ã
ä
¸
ã
ã
ã
ã
ã
ã
§
ã
ã
Cè
è
ª
ã
«
å
½±
é
¿
ã
å
ã
ã
ã
ã
­
ã
°
ã
©
ã
ã
³
ã
°
è
è
ª
ã
¯
é
å
¸¸
ã
«
å
¤
ã
ã
C
++
ã
Javaã
Objective
-
Cã
ª
ã
©
ã
ã
ã
ã
ã
ã
¾
ã
ã
awkã
cshã
JavaScriptã
PHPã
ª
ã
©
å
¤
ã
ã
®
ã
¹
ã
¯
ã
ª
ã
ã
è
è
ª
ã
Cè
è
ª
ã
®
å
½±
é
¿
ã
å
ã
ã
¦
ã
ã
¾
ã
ã
Cè
è
ª
ã
å
­¦
ç
¿
ã
ã
¦
ã
ã
ã
°
ã
ã
ã
ã
ã
®
ã
ã
­
ã
°
ã
©
ã
ã
³
ã
°
è
è
ª
ã
®
å
­¦
ç
¿
ã
å
®¹
æ
ã
«
ã
ª
ã
ã
¾
ã
ã
ï
¼
ã
¤
ã
ã
¯
ã
Cã
ã
­
ã
°
ã
©
ã
ã
®
ä
ºº
å
ã
å
¤
ã
ã
ã
ã
ã
§
ã
ã
Cã
ã
­
ã
°
ã
©
ã
ã
®
ä
ºº
å
ã
å
¤
ã
ã
®
ã
§
ã
æ
å
±
ã
®
å
¥
æ
ã
ç
°¡
å
ã
§
ã
ã
ã
ã
µ
ã
³
ã
ã
«
ã
½
ã
¼
ã
¹
ã
è
±
å
¯
ã
ª
ã
®
ã
§
ã
å
­¦
ç
¿
ã
ã
ã
ã
ã
®
ã
§
ã
ã
æ
¥­
å
ç
ã
®
é
ç
º
ã
§
ã
ã
å
º
ã
ä
½¿
ã
ã
ã
¦
ã
ã
ã
®
ã
§
å
°±
è
·
ã
è
»¢
è
·
ã
«
ã
æ
å
©
ã
§
ã
ã
ã
ã
®
ã
ã
ã
«
Cè
è
ª
ã
¯
ã
ã
¦
ã
é
­
å
ç
ã
ª
ã
ã
­
ã
°
ã
©
ã
ã
³
ã
°
è
è
ª
ã
§
ã
ã
ã
¾
ã
ã
Cè
è
ª
ã
å
­¦
ç
¿
ã
ã
¦
ã
ã
ª
ã
æ
¹
ã
ã
ã
ç
¥
è
­
ã
æ
·±
ã
ã
ã
æ
¹
ã
ã
ã
²
å
½
ã
µ
ã
¤
ã
ã
§
æ
¥½
ã
ã
å
­¦
ç
¿
ã
ã
¦
ã
¿
ã
¦
ã
ã
ã
ã
ã
â
»
å
½
ã
µ
ã
¤
ã
å
ã
®
ã
µ
ã
³
ã
ã
«
ã
½
ã
¼
ã
¹
ã
¯
ã
ã
ã
ª
ã
ã
¯
ã
»
ã
ã
¡
ã
¤
ã
³
ï
¼
ç
¸
å
½
ï
¼
ã
§
ã
ã
Cè
è
ª**************************************UTF
-
8
Encoding
Debugging
Chart
Debugging
Chart
Mapping
Windows
-
1252
Characters
to
UTF
-
8
Bytes
to
Latin
-
1
Characters
Here
is
a
Encoding
Problem
Chart
that
aids
in
debugging
common
UTF
-
8
character
encoding
problems
.
See
these
3
typical
problem
scenarios
that
the
chart
can
help
with
.
The
following
chart
shows
the
characters
in
Windows
-
1252
from
128
to
255
(
hex
80
to
FF
).
The
Unicode
code
point
for
each
character
is
listed
and
the
hex
values
for
each
of
the
bytes
in
the
UTF
-
8
encoding
for
the
same
characters
.
These
UTF
-
8
bytes
are
also
displayed
as
if
they
were
Windows
-
1252
characters
.
You
can
use
this
chart
to
debug
problems
where
these
sequences
of
Latin
characters
occur
where
only
one
character
was
expected
.
If
you
match
the
sequence
that
occurs
to
the
sequence
in
the
chart
and
the
expected
value
in
the
chart
matches
the
value
that
you
expected
to
see
then
the
problem
is
being
caused
by
UTF
-
8
bytes
being
interpreted
as
Windows
-
1252
(
or
ISO
8859
-
1
)
bytes
.
See
Encoding
Problem
:
Treating
UTF
-
8
Bytes
as
Windows
-
1252
or
ISO
-
8859
-
1
for
a
more
detailed
explanation
.
UTF
-
8
Character
Debug
Tool**************************************https
://
www
.
youtube
.
com
/
watch
%
3
Fv
%
3
DcLGIvKixNNI**************************************URL
コード
結果
%
E
3
%
83
%
8
F
%
E
3
%
82
%
A
4
%
E
3
%
83
%
95
%
E
3
%
83
%
B
3
キーワード
フレーズ
英語
翻訳
検索
語
一部
単語
検索
ヒント
その他
ヒント
ランダム
表示
設定
検索
文字
列
URL
エン
コーディング
前
検索
語
表示
以下
キーワード
中
言葉
Weblio
英和
辞典
和英
辞典
収録
単語
文字
コード
順
(
UTF
-
8
)
場合
前後
言葉
一覧
検索
語
中
部分
的
単語
表示
音声
発音
記号
データ
著作
権
アイコ
ン
クリック
単語
意味
画面
右側
こと
国語
辞書
類語
反対
語
辞典
英和
和英
辞典
日
中
中日
辞典
日
韓
韓
日
辞典
古語
辞典
手話
辞典
インドネシア
語
辞典
タイ
語
辞典
ベトナム
語
辞典
スマート
翻訳
単語
帳
語彙
力
診断
英会話
コラム
weblio
会員
無料
単語
帳
語彙
力
診断
テスト
機能
利用
こと
30
秒
登録
完了
今
会員
登録
Weblio
検索
仕方
FAQ
質問
利用
規約
プライバシー
ポリシー
サイト
マップ
辞書
総合
TOP
ヘルプ
ブラウザ
検索
検索
ツール
モバイル
RSS
フィード
問い合わせ
登録
辞書
推薦
フィードバック
公式
企業
ページ
ウェブリオ
企業
情報
ウェブリオ
転職
インターン
新卒
入社
Weblio
辞書
類語
対義語
辞典
英和
辞典
和英
辞典
Weblio
翻訳
スマート
翻訳
Weblio
英会話
日
中
中日
辞典
日
韓
韓
日
辞典
インドネシア
語
辞典
タイ
語
辞典
ベトナム
語
辞典
古語
辞典
手話
辞典
IT
用語
辞典
バイナリ
海外
通
シル
キー
海外
旅行
保険
比較
ナビ
©
2017
Weblio
RSS
%
E
3
%
83
%
8
F
%
E
3
%
82
%
A
4
%
E
3
%
83
%
95
%
E
3
%
83
%
B
3
%
E
3
%
83
%
8
F
%
E
3
%
82
%
A
4
%
E
3
%
83
%
95
%
E
3
%
83
%
B
3
意味
-
英和
辞典
Weblio
辞書**************************************æ
¥
æ
¬
è
ª
ã
ã
¼
ã
«
ã
»
ã
ã
¼
ã
å
¥
å
ã
®
æ
é
æ
¥
æ
¬
è
ª
ã
ã
¼
ã
«
ã
»
ã
ã
¼
ã
å
¥
å
ã
®
æ
é
æ
¥
æ
¬
è
ª
å
¥
å
ã
ã
¼
ã
«
ã
»
ã
ã
¼
æ
¥
æ
¬
è
ª
å
¥
å
ã
®
æ
é
ã
¢
ã
¼
ã
ã
»
ã
¹
ã
ã
¼
ã
¿
ã
¹
ã
»
ã
ã
¿
ã
³
ã
ã
«
ã
ï
½¥
ã
ã
¿
ã
³
å
¤
æ
ä
½
ç
½®
è
¨­
å
®
ã
ã
¿
ã
³
ã
¯
ã
­
ã
¼
ã
º
ï
½¥
ã
ã
¿
ã
³
è
ª­
ã
¿
ã
å
¥
å
ã
ã
å
¥
å
æ
å
­
ã
å
¤
æ
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
ã
ã
®
ç
«
ã
§
ã
¯:
æ
¥
æ
¬
è
ª
å
¥
å
ã
ã
¼
ã
«
ã
»
ã
ã
¼
æ
¥
æ
¬
è
ª
å
¥
å
ã
®
æ
é
æ
¥
æ
¬
è
ª
å
¥
å
ã
ã
¼
ã
«
ã
»
ã
ã
¼
VJE
for
Photon
(
VJE
)
ã
¯
ã
Photonä
¸
ã
§
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
æ
å
­
ã
æ
¥
æ
¬
è
ª
ã
«
å
¤
æ
ã
ã
ã
æ
¥
æ
¬
è
ª
ã
ã
­
ã
³
ã
ã
ã
³
ã
ã
»
ã
ã
­
ã
»
ã
ã
µ
ï
¼
FEPï
¼
ã
§
ã
ã
VJEã
è
µ·
å
ã
ã
ã
«
ã
¯
ã
pterm
ã
¦
ã
ã
³
ã
ã
¦
ã
§
ã
ä
»¥
ä
¸
ã
®
ã
³
ã
ã
³
ã
ã
å
¥
å
ã
ã
¾
ã
ã
vpim
ã
³
ã
ã
³
ã
ã
©
ã
¤
ã
³
ã
»
ã
ª
ã
ã
·
ã
§
ã
³
ã
¯
ã
ä
»¥
ä
¸
ã
®
ã
ã
ã
ª
ã
ã
¾
ã
ã
-
c
ã
«
ã
©
ã
¼
ã
»
ã
«
ã
¼
ã
½
ã
«
ã
®
ã
ã
ã
ã
«
ã
ã
­
ã
ã
¯
ã
»
ã
«
ã
¼
ã
½
ã
«
ã
ä
½¿
ç
ã
ã
¾
ã
ã
-
d
ä
½¿
ç
ã
ã
è
¾
æ
¸
ã
æ
å
®
ã
ã
¾
ã
ï
¼
ã
ã
ã
©
ã
«
ã
ï
¼
/$(
SYSNAME
)/
phjp
/
vje
/
vjeb
.
dic
ï
¼
-
F
font
ã
ã
ã
©
ã
«
ã
ã
®
ã
ã
©
ã
³
ã
ã
font
ã
§
ç
½®
ã
æ
ã
ã
¾
ã
ã
-
f
ã
ã
©
ã
³
ã
ã
»
ã
µ
ã
¤
ã
º
ã
æ
å
®
ã
ã
¾
ã
ï
¼
ã
ã
ã
©
ã
«
ã
ï
¼
18
ï
¼
ã
-
k
ã
­
ã
¼
ã
»
ã
ã
ã
ã
»
ã
ã
¡
ã
¤
ã
«
ã
æ
å
®
ã
ã
¾
ã
ï
¼
ã
ã
ã
©
ã
«
ã
ï
¼
vje
.
key
)
-
u
ã
ã
­
ã
ã
¯
ã
»
ã
«
ã
¼
ã
½
ã
«
ã
®
ä
»£
ã
ã
ã
«
ã
¢
ã
³
ã
ã
¼
ã
©
ã
¤
ã
³
ã
»
ã
«
ã
¼
ã
½
ã
«
ã
ä
½¿
ç
ã
ã
¾
ã
(
-
c
ã
ä
¸
æ
¸
ã
)
ã
-
s
server
server
ï
¼
ã
ã
¼
ã
å
ã
¾
ã
ã
¯
ã
ã
ã
¤
ã
¹
å
ï
¼
ã
ã
è
µ·
å
ã
ã
¾
ã
ã
-
v
ã
ã
ã
ã
°
æ
å
±
ã
å
º
å
ã
ã
¾
ã
ã
-@
x
y
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
®
å
æ
ä
½
ç
½®
ã
x
.
yã
«
è
¨­
å
®
ã
ã
¾
ã
ã
VJEã
è
µ·
å
ã
ã
ã
ã
ã
Photonã
¯
ã
¼
ã
¯
ã
¹
ã
ã
¼
ã
¹
ã
®
ä
¸­
ã
«
ã
ä
»¥
ä
¸
ã
®
ã
ã
ã
ª
æ
¥
æ
¬
è
ª
å
¥
å
ã
ã
¼
ã
«
ã
»
ã
ã
¼
ã
ç
¾
ã
ã
¾
ã
ã
ã
¢
ã
¼
ã
ã
»
ã
¹
ã
ã
¼
ã
¿
ã
¹
ã
»
ã
ã
¿
ã
³
æ
¥
æ
¬
è
ª
å
¥
å
ã
®
ç
¶
æ
ã
è
¡¨
ç
¤º
ã
ã
¾
ã
ã
ã
¾
ã
ã
ã
ã
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
æ
¥
æ
¬
è
ª
ã
®
å
¥
å
ç
°
å
¢
è
¨­
å
®
ã
å
ä
½
ã
¢
ã
¼
ã
ã
»
ã
ª
ã
ã
·
ã
§
ã
³
ã
å
è
ª
ç
»
é
²
ç
ã
®
ã
ã
¿
ã
³
ã
ç
¾
ã
ã
¾
ã
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
ã
ª
ã
ã
«
ã
ª
ã
ã
¦
ã
ã
ã
ã
ã
«
ã
¯
ã
ç
ç
·
ã
ç
¤º
ã
ã
ã
¾
ã
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
ã
ª
ã
³
ã
«
ã
ª
ã
ã
¦
ã
ã
ã
ã
ã
¯
ã
é
¸
æ
ã
ã
ã
¦
ã
ã
å
¥
å
ã
¢
ã
¼
ã
ã
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
è
©³
ã
ã
ã
¯
ã
æ
¬¡
ç
«
å
¥
å
ç
°
å
¢
ã
®
é
ã
å
ç
§
ã
ã
¦
ã
ã
ã
ã
ã
ï
¼»
æ
¼¢
å
­
ï
¼½
ã
­
ã
¼
ã
¾
ã
ã
¯
[
Alt
]+[~]
ã
æ
¼
ã
ã
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
®
ã
ª
ã
³
ã
»
ã
ª
ã
ã
å
ã
æ
¿
ã
ã
ã
¾
ã
ã
ã
¢
ã
¼
ã
ã
»
ã
¹
ã
ã
¼
ã
¿
ã
¹
ã
»
ã
ã
¿
ã
³
ã
¯
ã
ç
¾
å
é
¸
ã
ã
ã
¦
ã
ã
å
¥
å
ç
°
å
¢
ã
è
¡¨
ç
¤º
ã
ã
¾
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
®
ã
ã
ã
¯[
R
]
ã
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
[
R
]
ã
è
¡¨
ç
¤º
ã
ã
ã
¦
ã
ã
ª
ã
å
å
ã
¯
ã
ã
ã
ª
å
¥
å
ã
é
¸
æ
ã
ã
ã
¦
ã
ã
¾
ã
ã
[
ã
ã
ª]
ã
[
ã
«
ã
]
ã
[
è
±
æ
°]
ã
§
é
¸
æ
ã
ã
ã
¦
ã
ã
å
¥
å
æ
å
­
ç
¨®
ã
ç
¤º
ã
ã
¾
ã
ã
å
è
§
å
¥
å
ã
®
ã
ã
ã
¯[
å
¨]
ã
å
è
§
å
¥
å
ã
®
ã
ã
ã
¯[
å
]
ã
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
ï
¼
ã
¯
å
­¦
ç
¿
æ
©
è
½
ã
ã
ª
ã
³
ã
§
ã
ã
ã
ã
ã
ç
¤º
ã
ã
¾
ã
ã
[
B
]
ã
¯
é
æ
ç
¯
å
¤
æ
ã
[
F
]
ã
¯
è
¤
å
è
ª
å
¤
æ
ã
é
¸
æ
ã
ã
ã
¦
ã
ã
ã
ã
ã
ç
¤º
ã
ã
¾
ã
ã
å
¤
æ
æ
¹
å
¼
ã
ã
ã
³
å
­¦
ç
¿
æ
©
è
½
ã
®
è
©³
ç
´°
ã
¤
ã
ã
¦
ã
¯
ã
å
ä
½
ã
¢
ã
¼
ã
ã
»
ã
ª
ã
ã
·
ã
§
ã
³
ã
®
ç
«
ã
®
ã
å
¤
æ
ã
ª
ã
ã
·
ã
§
ã
³
ã
ã
®
é
ã
å
ç
§
ã
ã
¦
ã
ã
ã
ã
ã
ä
¾
ã
ã
°
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
ã
«
ã
¿
ã
«
ã
å
è
§
å
¥
å
ã
¢
ã
¼
ã
ã
é
æ
ç
¯
å
¤
æ
æ
¹
å
¼
ã
é
¸
æ
ã
ã
ã
¦
ã
ã
¾
ã
ã
ã
¾
ã
ã
å
­¦
ç
¿
æ
©
è
½
ã
ã
ª
ã
³
ã
«
ã
ª
ã
ã
¦
ã
ã
¾
ã
ã
ã
ã
«
ã
ï
½¥
ã
ã
¿
ã
³
æ
©
è
½
ã
æ
ä
½
æ
¹
æ
³
ã
å
ã
ã
ã
ª
ã
ã
ã
ã
¯
ã
ã
ª
ã
³
ã
©
ã
¤
ã
³
ã
ã
«
ã
ã
ä
½¿
ã
ã
¦
ç
»
é
¢
ä
¸
ã
§
è
ª¬
æ
ã
å
ç
§
ã
ã
ã
ã
ã
ã
§
ã
ã
¾
ã
ã
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
ã
ª
ã
³
ã
©
ã
¤
ã
³
ã
»
ã
ã
ã
¥
ã
¢
ã
«
ã
ã
ã
«
ã
ã
ã
¥
ã
¼
ã
¯
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
å
¤
æ
ä
½
ç
½®
è
¨­
å
®
ã
ã
¿
ã
³
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
ã
å
º
å
®
ã
ã
¾
ã
ã
¯
ã
å
ç
ã
ã
«
è
¨­
å
®
ã
ã
¾
ã
ã
ã
å
º
å
®
ã
ã
¢
ã
¼
ã
ã
®
ã
ã
ã
¯
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
¯
ç
»
é
¢
å
·¦
ä
¸­
å
¤®
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
ã
å
ç
ã
ã
¢
ã
¼
ã
ã
®
ã
ã
ã
¯
ã
ã
«
ã
¼
ã
½
ã
«
ã
ã
ã
©
ã
¼
ã
«
ã
¹
ã
ã
ã
¦
ã
ã
ã
¦
ã
ã
³
ã
ã
¦
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
ã
¯
ã
­
ã
¼
ã
º
ï
½¥
ã
ã
¿
ã
³
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
VJEã
ç
µ
ä
º
ã
ã
¾
ã
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
®
æ
é
æ
¥
æ
¬
è
ª
å
¥
å
ã
¯
ã
æ
¬¡
ã
®
æ
é
ã
§
è
¡
ã
ã
¾
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
¢
ã
¼
ã
ã
ã
ª
ã
³
ã
«
å
ã
ã
ã
ã
¦
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
æ
å
­
ã
æ
¥
æ
¬
è
ª
ã
«
å
¤
æ
ã
ã
ã
ã
ã
ã
§
ã
ã
¾
ã
ã
è
ª­
ã
¿
ã
å
¥
å
ã
ã
æ
¹
æ
³
ã
«
ã
¯
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
®
ã
¢
ã
«
ã
ã
¡
ã
ã
ã
ã
ã
å
¥
å
ã
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
®
ã
ã
ª
ã
ã
å
¥
å
ã
ã
ã
ã
ã
ª
å
¥
å
ã
ã
ã
ã
ã
¾
ã
ã
å
¥
å
ã
ã
æ
å
­
ã
¯
å
¥
å
ã
¢
ã
¼
ã
ã
®
è
¨­
å
®
ã
«
å
¿
ã
ã
¦
è
¡¨
ç
¤º
ã
ã
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
å
¼
ã
°
ã
ã
¾
ã
ã
å
¥
å
ã
ã
æ
å
­
ã
ã
æ
¼¢
å
­
ã
»
ã
²
ã
ã
ã
ª
ã
»
ã
«
ã
¿
ã
«
ã
ã
¾
ã
ã
¯
è
±
æ
°
ã
®
æ
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
é
·
ã
æ
ã
ä
¸
å
º¦
ã
«
å
¤
æ
ã
ã
ã
ã
ã
§
ã
ã
å
¤
æ
ã
¢
ã
¼
ã
ã
«
å
¿
ã
ã
¦
é
©
å
ã
ª
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
å
¤
æ
ä
¸­
ã
®
æ
å
­
ã
¯
å
è
»¢
è
¡¨
ç
¤º
ã
ã
ã
ä
½
å
º¦
ã
§
ã
å
¥
ã
®
æ
å
­
ç
¨®
ã
«
å
¤
æ
å
¯
è
½
ã
ª
ã
ã
ã
è
¡¨
ã
ã
¦
ã
ã
¾
ã
ã
å
¤
æ
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
ä
º
ã
§
å
¤
æ
ã
ç
µ
ä
º
ã
ã
¦
ã
æ
¬¡
ã
®
æ
å
­
ã
å
¥
å
ã
§
ã
ã
ç
¶
æ
ã
«
ã
ª
ã
ã
¾
ã
ã
è
ª­
ã
¿
ã
å
¥
å
ã
ã
ã
æ
¥
æ
¬
è
ª
ã
ã
ã
ã
å
è
ª
ã
ä
¾
ã
«
å
¥
å
ã
ã
¾
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
NIHONNGOã
ã
«
ã
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
«
ã
»
ã
ã
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
¾
ã
ã
å
¥
å
æ
å
­
ã
å
¤
æ
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
ã
«
ã
»
ã
ã
ã
ã
ã
ã
æ
å
­
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
[
å
¤
æ
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
æ
å
­
å
ã
æ
¥
æ
¬
è
ª
ã
ã
ç
¢º
å
®
ã
ã
¾
ã
ã
[
Enter
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
VJE
for
Photon
(
VJE
)
ã
¯
ã
Photonä
¸
ã
§
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
æ
å
­
ã
æ
¥
æ
¬
è
ª
ã
«
å
¤
æ
ã
ã
ã
æ
¥
æ
¬
è
ª
ã
ã
­
ã
³
ã
ã
ã
³
ã
ã
»
ã
ã
­
ã
»
ã
ã
µ
ï
¼
FEPï
¼
ã
§
ã
ã
VJEã
è
µ·
å
ã
ã
ã
«
ã
¯
ã
pterm
ã
¦
ã
ã
³
ã
ã
¦
ã
§
ã
ä
»¥
ä
¸
ã
®
ã
³
ã
ã
³
ã
ã
å
¥
å
ã
ã
¾
ã
ã
vpim
ã
³
ã
ã
³
ã
ã
©
ã
¤
ã
³
ã
»
ã
ª
ã
ã
·
ã
§
ã
³
ã
¯
ã
ä
»¥
ä
¸
ã
®
ã
ã
ã
ª
ã
ã
¾
ã
ã
-
c
ã
«
ã
©
ã
¼
ã
»
ã
«
ã
¼
ã
½
ã
«
ã
®
ã
ã
ã
ã
«
ã
ã
­
ã
ã
¯
ã
»
ã
«
ã
¼
ã
½
ã
«
ã
ä
½¿
ç
ã
ã
¾
ã
ã
-
d
ä
½¿
ç
ã
ã
è
¾
æ
¸
ã
æ
å
®
ã
ã
¾
ã
ï
¼
ã
ã
ã
©
ã
«
ã
ï
¼
/$(
SYSNAME
)/
phjp
/
vje
/
vjeb
.
dic
ï
¼
-
F
font
ã
ã
ã
©
ã
«
ã
ã
®
ã
ã
©
ã
³
ã
ã
font
ã
§
ç
½®
ã
æ
ã
ã
¾
ã
ã
-
f
ã
ã
©
ã
³
ã
ã
»
ã
µ
ã
¤
ã
º
ã
æ
å
®
ã
ã
¾
ã
ï
¼
ã
ã
ã
©
ã
«
ã
ï
¼
18
ï
¼
ã
-
k
ã
­
ã
¼
ã
»
ã
ã
ã
ã
»
ã
ã
¡
ã
¤
ã
«
ã
æ
å
®
ã
ã
¾
ã
ï
¼
ã
ã
ã
©
ã
«
ã
ï
¼
vje
.
key
)
-
u
ã
ã
­
ã
ã
¯
ã
»
ã
«
ã
¼
ã
½
ã
«
ã
®
ä
»£
ã
ã
ã
«
ã
¢
ã
³
ã
ã
¼
ã
©
ã
¤
ã
³
ã
»
ã
«
ã
¼
ã
½
ã
«
ã
ä
½¿
ç
ã
ã
¾
ã
(
-
c
ã
ä
¸
æ
¸
ã
)
ã
-
s
server
server
ï
¼
ã
ã
¼
ã
å
ã
¾
ã
ã
¯
ã
ã
ã
¤
ã
¹
å
ï
¼
ã
ã
è
µ·
å
ã
ã
¾
ã
ã
-
v
ã
ã
ã
ã
°
æ
å
±
ã
å
º
å
ã
ã
¾
ã
ã
-@
x
y
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
®
å
æ
ä
½
ç
½®
ã
x
.
yã
«
è
¨­
å
®
ã
ã
¾
ã
ã
VJEã
è
µ·
å
ã
ã
ã
ã
ã
Photonã
¯
ã
¼
ã
¯
ã
¹
ã
ã
¼
ã
¹
ã
®
ä
¸­
ã
«
ã
ä
»¥
ä
¸
ã
®
ã
ã
ã
ª
æ
¥
æ
¬
è
ª
å
¥
å
ã
ã
¼
ã
«
ã
»
ã
ã
¼
ã
ç
¾
ã
ã
¾
ã
ã
ã
¢
ã
¼
ã
ã
»
ã
¹
ã
ã
¼
ã
¿
ã
¹
ã
»
ã
ã
¿
ã
³
æ
¥
æ
¬
è
ª
å
¥
å
ã
®
ç
¶
æ
ã
è
¡¨
ç
¤º
ã
ã
¾
ã
ã
ã
¾
ã
ã
ã
ã
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
æ
¥
æ
¬
è
ª
ã
®
å
¥
å
ç
°
å
¢
è
¨­
å
®
ã
å
ä
½
ã
¢
ã
¼
ã
ã
»
ã
ª
ã
ã
·
ã
§
ã
³
ã
å
è
ª
ç
»
é
²
ç
ã
®
ã
ã
¿
ã
³
ã
ç
¾
ã
ã
¾
ã
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
ã
ª
ã
ã
«
ã
ª
ã
ã
¦
ã
ã
ã
ã
ã
«
ã
¯
ã
ç
ç
·
ã
ç
¤º
ã
ã
ã
¾
ã
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
ã
ª
ã
³
ã
«
ã
ª
ã
ã
¦
ã
ã
ã
ã
ã
¯
ã
é
¸
æ
ã
ã
ã
¦
ã
ã
å
¥
å
ã
¢
ã
¼
ã
ã
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
è
©³
ã
ã
ã
¯
ã
æ
¬¡
ç
«
å
¥
å
ç
°
å
¢
ã
®
é
ã
å
ç
§
ã
ã
¦
ã
ã
ã
ã
ã
ï
¼»
æ
¼¢
å
­
ï
¼½
ã
­
ã
¼
ã
¾
ã
ã
¯
[
Alt
]+[~]
ã
æ
¼
ã
ã
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
®
ã
ª
ã
³
ã
»
ã
ª
ã
ã
å
ã
æ
¿
ã
ã
ã
¾
ã
ã
ã
¢
ã
¼
ã
ã
»
ã
¹
ã
ã
¼
ã
¿
ã
¹
ã
»
ã
ã
¿
ã
³
ã
¯
ã
ç
¾
å
é
¸
ã
ã
ã
¦
ã
ã
å
¥
å
ç
°
å
¢
ã
è
¡¨
ç
¤º
ã
ã
¾
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
®
ã
ã
ã
¯[
R
]
ã
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
[
R
]
ã
è
¡¨
ç
¤º
ã
ã
ã
¦
ã
ã
ª
ã
å
å
ã
¯
ã
ã
ã
ª
å
¥
å
ã
é
¸
æ
ã
ã
ã
¦
ã
ã
¾
ã
ã
[
ã
ã
ª]
ã
[
ã
«
ã
]
ã
[
è
±
æ
°]
ã
§
é
¸
æ
ã
ã
ã
¦
ã
ã
å
¥
å
æ
å
­
ç
¨®
ã
ç
¤º
ã
ã
¾
ã
ã
å
è
§
å
¥
å
ã
®
ã
ã
ã
¯[
å
¨]
ã
å
è
§
å
¥
å
ã
®
ã
ã
ã
¯[
å
]
ã
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
ï
¼
ã
¯
å
­¦
ç
¿
æ
©
è
½
ã
ã
ª
ã
³
ã
§
ã
ã
ã
ã
ã
ç
¤º
ã
ã
¾
ã
ã
[
B
]
ã
¯
é
æ
ç
¯
å
¤
æ
ã
[
F
]
ã
¯
è
¤
å
è
ª
å
¤
æ
ã
é
¸
æ
ã
ã
ã
¦
ã
ã
ã
ã
ã
ç
¤º
ã
ã
¾
ã
ã
å
¤
æ
æ
¹
å
¼
ã
ã
ã
³
å
­¦
ç
¿
æ
©
è
½
ã
®
è
©³
ç
´°
ã
¤
ã
ã
¦
ã
¯
ã
å
ä
½
ã
¢
ã
¼
ã
ã
»
ã
ª
ã
ã
·
ã
§
ã
³
ã
®
ç
«
ã
®
ã
å
¤
æ
ã
ª
ã
ã
·
ã
§
ã
³
ã
ã
®
é
ã
å
ç
§
ã
ã
¦
ã
ã
ã
ã
ã
ä
¾
ã
ã
°
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
ã
«
ã
¿
ã
«
ã
å
è
§
å
¥
å
ã
¢
ã
¼
ã
ã
é
æ
ç
¯
å
¤
æ
æ
¹
å
¼
ã
é
¸
æ
ã
ã
ã
¦
ã
ã
¾
ã
ã
ã
¾
ã
ã
å
­¦
ç
¿
æ
©
è
½
ã
ã
ª
ã
³
ã
«
ã
ª
ã
ã
¦
ã
ã
¾
ã
ã
ã
ã
«
ã
ï
½¥
ã
ã
¿
ã
³
æ
©
è
½
ã
æ
ä
½
æ
¹
æ
³
ã
å
ã
ã
ã
ª
ã
ã
ã
ã
¯
ã
ã
ª
ã
³
ã
©
ã
¤
ã
³
ã
ã
«
ã
ã
ä
½¿
ã
ã
¦
ç
»
é
¢
ä
¸
ã
§
è
ª¬
æ
ã
å
ç
§
ã
ã
ã
ã
ã
ã
§
ã
ã
¾
ã
ã
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
ã
ª
ã
³
ã
©
ã
¤
ã
³
ã
»
ã
ã
ã
¥
ã
¢
ã
«
ã
ã
ã
«
ã
ã
ã
¥
ã
¼
ã
¯
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
å
¤
æ
ä
½
ç
½®
è
¨­
å
®
ã
ã
¿
ã
³
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
ã
å
º
å
®
ã
ã
¾
ã
ã
¯
ã
å
ç
ã
ã
«
è
¨­
å
®
ã
ã
¾
ã
ã
ã
å
º
å
®
ã
ã
¢
ã
¼
ã
ã
®
ã
ã
ã
¯
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
¯
ç
»
é
¢
å
·¦
ä
¸­
å
¤®
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
ã
å
ç
ã
ã
¢
ã
¼
ã
ã
®
ã
ã
ã
¯
ã
ã
«
ã
¼
ã
½
ã
«
ã
ã
ã
©
ã
¼
ã
«
ã
¹
ã
ã
ã
¦
ã
ã
ã
¦
ã
ã
³
ã
ã
¦
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
ã
¯
ã
­
ã
¼
ã
º
ï
½¥
ã
ã
¿
ã
³
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
VJEã
ç
µ
ä
º
ã
ã
¾
ã
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
®
æ
é
æ
¥
æ
¬
è
ª
å
¥
å
ã
¯
ã
æ
¬¡
ã
®
æ
é
ã
§
è
¡
ã
ã
¾
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
¢
ã
¼
ã
ã
ã
ª
ã
³
ã
«
å
ã
ã
ã
ã
¦
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
æ
å
­
ã
æ
¥
æ
¬
è
ª
ã
«
å
¤
æ
ã
ã
ã
ã
ã
ã
§
ã
ã
¾
ã
ã
è
ª­
ã
¿
ã
å
¥
å
ã
ã
æ
¹
æ
³
ã
«
ã
¯
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
®
ã
¢
ã
«
ã
ã
¡
ã
ã
ã
ã
ã
å
¥
å
ã
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
®
ã
ã
ª
ã
ã
å
¥
å
ã
ã
ã
ã
ã
ª
å
¥
å
ã
ã
ã
ã
ã
¾
ã
ã
å
¥
å
ã
ã
æ
å
­
ã
¯
å
¥
å
ã
¢
ã
¼
ã
ã
®
è
¨­
å
®
ã
«
å
¿
ã
ã
¦
è
¡¨
ç
¤º
ã
ã
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
å
¼
ã
°
ã
ã
¾
ã
ã
å
¥
å
ã
ã
æ
å
­
ã
ã
æ
¼¢
å
­
ã
»
ã
²
ã
ã
ã
ª
ã
»
ã
«
ã
¿
ã
«
ã
ã
¾
ã
ã
¯
è
±
æ
°
ã
®
æ
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
é
·
ã
æ
ã
ä
¸
å
º¦
ã
«
å
¤
æ
ã
ã
ã
ã
ã
§
ã
ã
å
¤
æ
ã
¢
ã
¼
ã
ã
«
å
¿
ã
ã
¦
é
©
å
ã
ª
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
å
¤
æ
ä
¸­
ã
®
æ
å
­
ã
¯
å
è
»¢
è
¡¨
ç
¤º
ã
ã
ã
ä
½
å
º¦
ã
§
ã
å
¥
ã
®
æ
å
­
ç
¨®
ã
«
å
¤
æ
å
¯
è
½
ã
ª
ã
ã
ã
è
¡¨
ã
ã
¦
ã
ã
¾
ã
ã
å
¤
æ
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
ä
º
ã
§
å
¤
æ
ã
ç
µ
ä
º
ã
ã
¦
ã
æ
¬¡
ã
®
æ
å
­
ã
å
¥
å
ã
§
ã
ã
ç
¶
æ
ã
«
ã
ª
ã
ã
¾
ã
ã
è
ª­
ã
¿
ã
å
¥
å
ã
ã
ã
æ
¥
æ
¬
è
ª
ã
ã
ã
ã
å
è
ª
ã
ä
¾
ã
«
å
¥
å
ã
ã
¾
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
NIHONNGOã
ã
«
ã
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
«
ã
»
ã
ã
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
¾
ã
ã
å
¥
å
æ
å
­
ã
å
¤
æ
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
ã
«
ã
»
ã
ã
ã
ã
ã
ã
æ
å
­
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
[
å
¤
æ
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
æ
å
­
å
ã
æ
¥
æ
¬
è
ª
ã
ã
ç
¢º
å
®
ã
ã
¾
ã
ã
[
Enter
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
ã
³
ã
ã
³
ã
ã
©
ã
¤
ã
³
ã
»
ã
ª
ã
ã
·
ã
§
ã
³
ã
¯
ã
ä
»¥
ä
¸
ã
®
ã
ã
ã
ª
ã
ã
¾
ã
ã
-
c
ã
«
ã
©
ã
¼
ã
»
ã
«
ã
¼
ã
½
ã
«
ã
®
ã
ã
ã
ã
«
ã
ã
­
ã
ã
¯
ã
»
ã
«
ã
¼
ã
½
ã
«
ã
ä
½¿
ç
ã
ã
¾
ã
ã
-
d
ä
½¿
ç
ã
ã
è
¾
æ
¸
ã
æ
å
®
ã
ã
¾
ã
ï
¼
ã
ã
ã
©
ã
«
ã
ï
¼
/$(
SYSNAME
)/
phjp
/
vje
/
vjeb
.
dic
ï
¼
-
F
font
ã
ã
ã
©
ã
«
ã
ã
®
ã
ã
©
ã
³
ã
ã
font
ã
§
ç
½®
ã
æ
ã
ã
¾
ã
ã
-
f
ã
ã
©
ã
³
ã
ã
»
ã
µ
ã
¤
ã
º
ã
æ
å
®
ã
ã
¾
ã
ï
¼
ã
ã
ã
©
ã
«
ã
ï
¼
18
ï
¼
ã
-
k
ã
­
ã
¼
ã
»
ã
ã
ã
ã
»
ã
ã
¡
ã
¤
ã
«
ã
æ
å
®
ã
ã
¾
ã
ï
¼
ã
ã
ã
©
ã
«
ã
ï
¼
vje
.
key
)
-
u
ã
ã
­
ã
ã
¯
ã
»
ã
«
ã
¼
ã
½
ã
«
ã
®
ä
»£
ã
ã
ã
«
ã
¢
ã
³
ã
ã
¼
ã
©
ã
¤
ã
³
ã
»
ã
«
ã
¼
ã
½
ã
«
ã
ä
½¿
ç
ã
ã
¾
ã
(
-
c
ã
ä
¸
æ
¸
ã
)
ã
-
s
server
server
ï
¼
ã
ã
¼
ã
å
ã
¾
ã
ã
¯
ã
ã
ã
¤
ã
¹
å
ï
¼
ã
ã
è
µ·
å
ã
ã
¾
ã
ã
-
v
ã
ã
ã
ã
°
æ
å
±
ã
å
º
å
ã
ã
¾
ã
ã
-@
x
y
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
®
å
æ
ä
½
ç
½®
ã
x
.
yã
«
è
¨­
å
®
ã
ã
¾
ã
ã
VJEã
è
µ·
å
ã
ã
ã
ã
ã
Photonã
¯
ã
¼
ã
¯
ã
¹
ã
ã
¼
ã
¹
ã
®
ä
¸­
ã
«
ã
ä
»¥
ä
¸
ã
®
ã
ã
ã
ª
æ
¥
æ
¬
è
ª
å
¥
å
ã
ã
¼
ã
«
ã
»
ã
ã
¼
ã
ç
¾
ã
ã
¾
ã
ã
ã
¢
ã
¼
ã
ã
»
ã
¹
ã
ã
¼
ã
¿
ã
¹
ã
»
ã
ã
¿
ã
³
æ
¥
æ
¬
è
ª
å
¥
å
ã
®
ç
¶
æ
ã
è
¡¨
ç
¤º
ã
ã
¾
ã
ã
ã
¾
ã
ã
ã
ã
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
æ
¥
æ
¬
è
ª
ã
®
å
¥
å
ç
°
å
¢
è
¨­
å
®
ã
å
ä
½
ã
¢
ã
¼
ã
ã
»
ã
ª
ã
ã
·
ã
§
ã
³
ã
å
è
ª
ç
»
é
²
ç
ã
®
ã
ã
¿
ã
³
ã
ç
¾
ã
ã
¾
ã
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
ã
ª
ã
ã
«
ã
ª
ã
ã
¦
ã
ã
ã
ã
ã
«
ã
¯
ã
ç
ç
·
ã
ç
¤º
ã
ã
ã
¾
ã
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
ã
ª
ã
³
ã
«
ã
ª
ã
ã
¦
ã
ã
ã
ã
ã
¯
ã
é
¸
æ
ã
ã
ã
¦
ã
ã
å
¥
å
ã
¢
ã
¼
ã
ã
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
è
©³
ã
ã
ã
¯
ã
æ
¬¡
ç
«
å
¥
å
ç
°
å
¢
ã
®
é
ã
å
ç
§
ã
ã
¦
ã
ã
ã
ã
ã
ï
¼»
æ
¼¢
å
­
ï
¼½
ã
­
ã
¼
ã
¾
ã
ã
¯
[
Alt
]+[~]
ã
æ
¼
ã
ã
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
®
ã
ª
ã
³
ã
»
ã
ª
ã
ã
å
ã
æ
¿
ã
ã
ã
¾
ã
ã
ã
¢
ã
¼
ã
ã
»
ã
¹
ã
ã
¼
ã
¿
ã
¹
ã
»
ã
ã
¿
ã
³
ã
¯
ã
ç
¾
å
é
¸
ã
ã
ã
¦
ã
ã
å
¥
å
ç
°
å
¢
ã
è
¡¨
ç
¤º
ã
ã
¾
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
®
ã
ã
ã
¯[
R
]
ã
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
[
R
]
ã
è
¡¨
ç
¤º
ã
ã
ã
¦
ã
ã
ª
ã
å
å
ã
¯
ã
ã
ã
ª
å
¥
å
ã
é
¸
æ
ã
ã
ã
¦
ã
ã
¾
ã
ã
[
ã
ã
ª]
ã
[
ã
«
ã
]
ã
[
è
±
æ
°]
ã
§
é
¸
æ
ã
ã
ã
¦
ã
ã
å
¥
å
æ
å
­
ç
¨®
ã
ç
¤º
ã
ã
¾
ã
ã
å
è
§
å
¥
å
ã
®
ã
ã
ã
¯[
å
¨]
ã
å
è
§
å
¥
å
ã
®
ã
ã
ã
¯[
å
]
ã
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
ï
¼
ã
¯
å
­¦
ç
¿
æ
©
è
½
ã
ã
ª
ã
³
ã
§
ã
ã
ã
ã
ã
ç
¤º
ã
ã
¾
ã
ã
[
B
]
ã
¯
é
æ
ç
¯
å
¤
æ
ã
[
F
]
ã
¯
è
¤
å
è
ª
å
¤
æ
ã
é
¸
æ
ã
ã
ã
¦
ã
ã
ã
ã
ã
ç
¤º
ã
ã
¾
ã
ã
å
¤
æ
æ
¹
å
¼
ã
ã
ã
³
å
­¦
ç
¿
æ
©
è
½
ã
®
è
©³
ç
´°
ã
¤
ã
ã
¦
ã
¯
ã
å
ä
½
ã
¢
ã
¼
ã
ã
»
ã
ª
ã
ã
·
ã
§
ã
³
ã
®
ç
«
ã
®
ã
å
¤
æ
ã
ª
ã
ã
·
ã
§
ã
³
ã
ã
®
é
ã
å
ç
§
ã
ã
¦
ã
ã
ã
ã
ã
ä
¾
ã
ã
°
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
ã
«
ã
¿
ã
«
ã
å
è
§
å
¥
å
ã
¢
ã
¼
ã
ã
é
æ
ç
¯
å
¤
æ
æ
¹
å
¼
ã
é
¸
æ
ã
ã
ã
¦
ã
ã
¾
ã
ã
ã
¾
ã
ã
å
­¦
ç
¿
æ
©
è
½
ã
ã
ª
ã
³
ã
«
ã
ª
ã
ã
¦
ã
ã
¾
ã
ã
ã
ã
«
ã
ï
½¥
ã
ã
¿
ã
³
æ
©
è
½
ã
æ
ä
½
æ
¹
æ
³
ã
å
ã
ã
ã
ª
ã
ã
ã
ã
¯
ã
ã
ª
ã
³
ã
©
ã
¤
ã
³
ã
ã
«
ã
ã
ä
½¿
ã
ã
¦
ç
»
é
¢
ä
¸
ã
§
è
ª¬
æ
ã
å
ç
§
ã
ã
ã
ã
ã
ã
§
ã
ã
¾
ã
ã
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
ã
ª
ã
³
ã
©
ã
¤
ã
³
ã
»
ã
ã
ã
¥
ã
¢
ã
«
ã
ã
ã
«
ã
ã
ã
¥
ã
¼
ã
¯
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
å
¤
æ
ä
½
ç
½®
è
¨­
å
®
ã
ã
¿
ã
³
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
ã
å
º
å
®
ã
ã
¾
ã
ã
¯
ã
å
ç
ã
ã
«
è
¨­
å
®
ã
ã
¾
ã
ã
ã
å
º
å
®
ã
ã
¢
ã
¼
ã
ã
®
ã
ã
ã
¯
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
¯
ç
»
é
¢
å
·¦
ä
¸­
å
¤®
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
ã
å
ç
ã
ã
¢
ã
¼
ã
ã
®
ã
ã
ã
¯
ã
ã
«
ã
¼
ã
½
ã
«
ã
ã
ã
©
ã
¼
ã
«
ã
¹
ã
ã
ã
¦
ã
ã
ã
¦
ã
ã
³
ã
ã
¦
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
ã
¯
ã
­
ã
¼
ã
º
ï
½¥
ã
ã
¿
ã
³
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
VJEã
ç
µ
ä
º
ã
ã
¾
ã
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
®
æ
é
æ
¥
æ
¬
è
ª
å
¥
å
ã
¯
ã
æ
¬¡
ã
®
æ
é
ã
§
è
¡
ã
ã
¾
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
¢
ã
¼
ã
ã
ã
ª
ã
³
ã
«
å
ã
ã
ã
ã
¦
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
æ
å
­
ã
æ
¥
æ
¬
è
ª
ã
«
å
¤
æ
ã
ã
ã
ã
ã
ã
§
ã
ã
¾
ã
ã
è
ª­
ã
¿
ã
å
¥
å
ã
ã
æ
¹
æ
³
ã
«
ã
¯
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
®
ã
¢
ã
«
ã
ã
¡
ã
ã
ã
ã
ã
å
¥
å
ã
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
®
ã
ã
ª
ã
ã
å
¥
å
ã
ã
ã
ã
ã
ª
å
¥
å
ã
ã
ã
ã
ã
¾
ã
ã
å
¥
å
ã
ã
æ
å
­
ã
¯
å
¥
å
ã
¢
ã
¼
ã
ã
®
è
¨­
å
®
ã
«
å
¿
ã
ã
¦
è
¡¨
ç
¤º
ã
ã
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
å
¼
ã
°
ã
ã
¾
ã
ã
å
¥
å
ã
ã
æ
å
­
ã
ã
æ
¼¢
å
­
ã
»
ã
²
ã
ã
ã
ª
ã
»
ã
«
ã
¿
ã
«
ã
ã
¾
ã
ã
¯
è
±
æ
°
ã
®
æ
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
é
·
ã
æ
ã
ä
¸
å
º¦
ã
«
å
¤
æ
ã
ã
ã
ã
ã
§
ã
ã
å
¤
æ
ã
¢
ã
¼
ã
ã
«
å
¿
ã
ã
¦
é
©
å
ã
ª
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
å
¤
æ
ä
¸­
ã
®
æ
å
­
ã
¯
å
è
»¢
è
¡¨
ç
¤º
ã
ã
ã
ä
½
å
º¦
ã
§
ã
å
¥
ã
®
æ
å
­
ç
¨®
ã
«
å
¤
æ
å
¯
è
½
ã
ª
ã
ã
ã
è
¡¨
ã
ã
¦
ã
ã
¾
ã
ã
å
¤
æ
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
ä
º
ã
§
å
¤
æ
ã
ç
µ
ä
º
ã
ã
¦
ã
æ
¬¡
ã
®
æ
å
­
ã
å
¥
å
ã
§
ã
ã
ç
¶
æ
ã
«
ã
ª
ã
ã
¾
ã
ã
è
ª­
ã
¿
ã
å
¥
å
ã
ã
ã
æ
¥
æ
¬
è
ª
ã
ã
ã
ã
å
è
ª
ã
ä
¾
ã
«
å
¥
å
ã
ã
¾
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
NIHONNGOã
ã
«
ã
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
«
ã
»
ã
ã
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
¾
ã
ã
å
¥
å
æ
å
­
ã
å
¤
æ
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
ã
«
ã
»
ã
ã
ã
ã
ã
ã
æ
å
­
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
[
å
¤
æ
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
æ
å
­
å
ã
æ
¥
æ
¬
è
ª
ã
ã
ç
¢º
å
®
ã
ã
¾
ã
ã
[
Enter
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
VJEã
è
µ·
å
ã
ã
ã
ã
ã
Photonã
¯
ã
¼
ã
¯
ã
¹
ã
ã
¼
ã
¹
ã
®
ä
¸­
ã
«
ã
ä
»¥
ä
¸
ã
®
ã
ã
ã
ª
æ
¥
æ
¬
è
ª
å
¥
å
ã
ã
¼
ã
«
ã
»
ã
ã
¼
ã
ç
¾
ã
ã
¾
ã
ã
ã
¢
ã
¼
ã
ã
»
ã
¹
ã
ã
¼
ã
¿
ã
¹
ã
»
ã
ã
¿
ã
³
æ
¥
æ
¬
è
ª
å
¥
å
ã
®
ç
¶
æ
ã
è
¡¨
ç
¤º
ã
ã
¾
ã
ã
ã
¾
ã
ã
ã
ã
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
æ
¥
æ
¬
è
ª
ã
®
å
¥
å
ç
°
å
¢
è
¨­
å
®
ã
å
ä
½
ã
¢
ã
¼
ã
ã
»
ã
ª
ã
ã
·
ã
§
ã
³
ã
å
è
ª
ç
»
é
²
ç
ã
®
ã
ã
¿
ã
³
ã
ç
¾
ã
ã
¾
ã
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
ã
ª
ã
ã
«
ã
ª
ã
ã
¦
ã
ã
ã
ã
ã
«
ã
¯
ã
ç
ç
·
ã
ç
¤º
ã
ã
ã
¾
ã
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
ã
ª
ã
³
ã
«
ã
ª
ã
ã
¦
ã
ã
ã
ã
ã
¯
ã
é
¸
æ
ã
ã
ã
¦
ã
ã
å
¥
å
ã
¢
ã
¼
ã
ã
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
è
©³
ã
ã
ã
¯
ã
æ
¬¡
ç
«
å
¥
å
ç
°
å
¢
ã
®
é
ã
å
ç
§
ã
ã
¦
ã
ã
ã
ã
ã
ï
¼»
æ
¼¢
å
­
ï
¼½
ã
­
ã
¼
ã
¾
ã
ã
¯
[
Alt
]+[~]
ã
æ
¼
ã
ã
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
®
ã
ª
ã
³
ã
»
ã
ª
ã
ã
å
ã
æ
¿
ã
ã
ã
¾
ã
ã
ã
¢
ã
¼
ã
ã
»
ã
¹
ã
ã
¼
ã
¿
ã
¹
ã
»
ã
ã
¿
ã
³
ã
¯
ã
ç
¾
å
é
¸
ã
ã
ã
¦
ã
ã
å
¥
å
ç
°
å
¢
ã
è
¡¨
ç
¤º
ã
ã
¾
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
®
ã
ã
ã
¯[
R
]
ã
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
[
R
]
ã
è
¡¨
ç
¤º
ã
ã
ã
¦
ã
ã
ª
ã
å
å
ã
¯
ã
ã
ã
ª
å
¥
å
ã
é
¸
æ
ã
ã
ã
¦
ã
ã
¾
ã
ã
[
ã
ã
ª]
ã
[
ã
«
ã
]
ã
[
è
±
æ
°]
ã
§
é
¸
æ
ã
ã
ã
¦
ã
ã
å
¥
å
æ
å
­
ç
¨®
ã
ç
¤º
ã
ã
¾
ã
ã
å
è
§
å
¥
å
ã
®
ã
ã
ã
¯[
å
¨]
ã
å
è
§
å
¥
å
ã
®
ã
ã
ã
¯[
å
]
ã
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
ï
¼
ã
¯
å
­¦
ç
¿
æ
©
è
½
ã
ã
ª
ã
³
ã
§
ã
ã
ã
ã
ã
ç
¤º
ã
ã
¾
ã
ã
[
B
]
ã
¯
é
æ
ç
¯
å
¤
æ
ã
[
F
]
ã
¯
è
¤
å
è
ª
å
¤
æ
ã
é
¸
æ
ã
ã
ã
¦
ã
ã
ã
ã
ã
ç
¤º
ã
ã
¾
ã
ã
å
¤
æ
æ
¹
å
¼
ã
ã
ã
³
å
­¦
ç
¿
æ
©
è
½
ã
®
è
©³
ç
´°
ã
¤
ã
ã
¦
ã
¯
ã
å
ä
½
ã
¢
ã
¼
ã
ã
»
ã
ª
ã
ã
·
ã
§
ã
³
ã
®
ç
«
ã
®
ã
å
¤
æ
ã
ª
ã
ã
·
ã
§
ã
³
ã
ã
®
é
ã
å
ç
§
ã
ã
¦
ã
ã
ã
ã
ã
ä
¾
ã
ã
°
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
ã
«
ã
¿
ã
«
ã
å
è
§
å
¥
å
ã
¢
ã
¼
ã
ã
é
æ
ç
¯
å
¤
æ
æ
¹
å
¼
ã
é
¸
æ
ã
ã
ã
¦
ã
ã
¾
ã
ã
ã
¾
ã
ã
å
­¦
ç
¿
æ
©
è
½
ã
ã
ª
ã
³
ã
«
ã
ª
ã
ã
¦
ã
ã
¾
ã
ã
ã
ã
«
ã
ï
½¥
ã
ã
¿
ã
³
æ
©
è
½
ã
æ
ä
½
æ
¹
æ
³
ã
å
ã
ã
ã
ª
ã
ã
ã
ã
¯
ã
ã
ª
ã
³
ã
©
ã
¤
ã
³
ã
ã
«
ã
ã
ä
½¿
ã
ã
¦
ç
»
é
¢
ä
¸
ã
§
è
ª¬
æ
ã
å
ç
§
ã
ã
ã
ã
ã
ã
§
ã
ã
¾
ã
ã
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
ã
ª
ã
³
ã
©
ã
¤
ã
³
ã
»
ã
ã
ã
¥
ã
¢
ã
«
ã
ã
ã
«
ã
ã
ã
¥
ã
¼
ã
¯
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
å
¤
æ
ä
½
ç
½®
è
¨­
å
®
ã
ã
¿
ã
³
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
ã
å
º
å
®
ã
ã
¾
ã
ã
¯
ã
å
ç
ã
ã
«
è
¨­
å
®
ã
ã
¾
ã
ã
ã
å
º
å
®
ã
ã
¢
ã
¼
ã
ã
®
ã
ã
ã
¯
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
¯
ç
»
é
¢
å
·¦
ä
¸­
å
¤®
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
ã
å
ç
ã
ã
¢
ã
¼
ã
ã
®
ã
ã
ã
¯
ã
ã
«
ã
¼
ã
½
ã
«
ã
ã
ã
©
ã
¼
ã
«
ã
¹
ã
ã
ã
¦
ã
ã
ã
¦
ã
ã
³
ã
ã
¦
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
ã
¯
ã
­
ã
¼
ã
º
ï
½¥
ã
ã
¿
ã
³
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
VJEã
ç
µ
ä
º
ã
ã
¾
ã
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
®
æ
é
æ
¥
æ
¬
è
ª
å
¥
å
ã
¯
ã
æ
¬¡
ã
®
æ
é
ã
§
è
¡
ã
ã
¾
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
¢
ã
¼
ã
ã
ã
ª
ã
³
ã
«
å
ã
ã
ã
ã
¦
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
æ
å
­
ã
æ
¥
æ
¬
è
ª
ã
«
å
¤
æ
ã
ã
ã
ã
ã
ã
§
ã
ã
¾
ã
ã
è
ª­
ã
¿
ã
å
¥
å
ã
ã
æ
¹
æ
³
ã
«
ã
¯
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
®
ã
¢
ã
«
ã
ã
¡
ã
ã
ã
ã
ã
å
¥
å
ã
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
®
ã
ã
ª
ã
ã
å
¥
å
ã
ã
ã
ã
ã
ª
å
¥
å
ã
ã
ã
ã
ã
¾
ã
ã
å
¥
å
ã
ã
æ
å
­
ã
¯
å
¥
å
ã
¢
ã
¼
ã
ã
®
è
¨­
å
®
ã
«
å
¿
ã
ã
¦
è
¡¨
ç
¤º
ã
ã
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
å
¼
ã
°
ã
ã
¾
ã
ã
å
¥
å
ã
ã
æ
å
­
ã
ã
æ
¼¢
å
­
ã
»
ã
²
ã
ã
ã
ª
ã
»
ã
«
ã
¿
ã
«
ã
ã
¾
ã
ã
¯
è
±
æ
°
ã
®
æ
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
é
·
ã
æ
ã
ä
¸
å
º¦
ã
«
å
¤
æ
ã
ã
ã
ã
ã
§
ã
ã
å
¤
æ
ã
¢
ã
¼
ã
ã
«
å
¿
ã
ã
¦
é
©
å
ã
ª
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
å
¤
æ
ä
¸­
ã
®
æ
å
­
ã
¯
å
è
»¢
è
¡¨
ç
¤º
ã
ã
ã
ä
½
å
º¦
ã
§
ã
å
¥
ã
®
æ
å
­
ç
¨®
ã
«
å
¤
æ
å
¯
è
½
ã
ª
ã
ã
ã
è
¡¨
ã
ã
¦
ã
ã
¾
ã
ã
å
¤
æ
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
ä
º
ã
§
å
¤
æ
ã
ç
µ
ä
º
ã
ã
¦
ã
æ
¬¡
ã
®
æ
å
­
ã
å
¥
å
ã
§
ã
ã
ç
¶
æ
ã
«
ã
ª
ã
ã
¾
ã
ã
è
ª­
ã
¿
ã
å
¥
å
ã
ã
ã
æ
¥
æ
¬
è
ª
ã
ã
ã
ã
å
è
ª
ã
ä
¾
ã
«
å
¥
å
ã
ã
¾
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
NIHONNGOã
ã
«
ã
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
«
ã
»
ã
ã
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
¾
ã
ã
å
¥
å
æ
å
­
ã
å
¤
æ
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
ã
«
ã
»
ã
ã
ã
ã
ã
ã
æ
å
­
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
[
å
¤
æ
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
æ
å
­
å
ã
æ
¥
æ
¬
è
ª
ã
ã
ç
¢º
å
®
ã
ã
¾
ã
ã
[
Enter
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
ã
¢
ã
¼
ã
ã
»
ã
¹
ã
ã
¼
ã
¿
ã
¹
ã
»
ã
ã
¿
ã
³
æ
¥
æ
¬
è
ª
å
¥
å
ã
®
ç
¶
æ
ã
è
¡¨
ç
¤º
ã
ã
¾
ã
ã
ã
¾
ã
ã
ã
ã
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
æ
¥
æ
¬
è
ª
ã
®
å
¥
å
ç
°
å
¢
è
¨­
å
®
ã
å
ä
½
ã
¢
ã
¼
ã
ã
»
ã
ª
ã
ã
·
ã
§
ã
³
ã
å
è
ª
ç
»
é
²
ç
ã
®
ã
ã
¿
ã
³
ã
ç
¾
ã
ã
¾
ã
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
ã
ª
ã
ã
«
ã
ª
ã
ã
¦
ã
ã
ã
ã
ã
«
ã
¯
ã
ç
ç
·
ã
ç
¤º
ã
ã
ã
¾
ã
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
ã
ª
ã
³
ã
«
ã
ª
ã
ã
¦
ã
ã
ã
ã
ã
¯
ã
é
¸
æ
ã
ã
ã
¦
ã
ã
å
¥
å
ã
¢
ã
¼
ã
ã
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
è
©³
ã
ã
ã
¯
ã
æ
¬¡
ç
«
å
¥
å
ç
°
å
¢
ã
®
é
ã
å
ç
§
ã
ã
¦
ã
ã
ã
ã
ã
ï
¼»
æ
¼¢
å
­
ï
¼½
ã
­
ã
¼
ã
¾
ã
ã
¯
[
Alt
]+[~]
ã
æ
¼
ã
ã
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
®
ã
ª
ã
³
ã
»
ã
ª
ã
ã
å
ã
æ
¿
ã
ã
ã
¾
ã
ã
ã
¢
ã
¼
ã
ã
»
ã
¹
ã
ã
¼
ã
¿
ã
¹
ã
»
ã
ã
¿
ã
³
ã
¯
ã
ç
¾
å
é
¸
ã
ã
ã
¦
ã
ã
å
¥
å
ç
°
å
¢
ã
è
¡¨
ç
¤º
ã
ã
¾
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
®
ã
ã
ã
¯[
R
]
ã
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
[
R
]
ã
è
¡¨
ç
¤º
ã
ã
ã
¦
ã
ã
ª
ã
å
å
ã
¯
ã
ã
ã
ª
å
¥
å
ã
é
¸
æ
ã
ã
ã
¦
ã
ã
¾
ã
ã
[
ã
ã
ª]
ã
[
ã
«
ã
]
ã
[
è
±
æ
°]
ã
§
é
¸
æ
ã
ã
ã
¦
ã
ã
å
¥
å
æ
å
­
ç
¨®
ã
ç
¤º
ã
ã
¾
ã
ã
å
è
§
å
¥
å
ã
®
ã
ã
ã
¯[
å
¨]
ã
å
è
§
å
¥
å
ã
®
ã
ã
ã
¯[
å
]
ã
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
ï
¼
ã
¯
å
­¦
ç
¿
æ
©
è
½
ã
ã
ª
ã
³
ã
§
ã
ã
ã
ã
ã
ç
¤º
ã
ã
¾
ã
ã
[
B
]
ã
¯
é
æ
ç
¯
å
¤
æ
ã
[
F
]
ã
¯
è
¤
å
è
ª
å
¤
æ
ã
é
¸
æ
ã
ã
ã
¦
ã
ã
ã
ã
ã
ç
¤º
ã
ã
¾
ã
ã
å
¤
æ
æ
¹
å
¼
ã
ã
ã
³
å
­¦
ç
¿
æ
©
è
½
ã
®
è
©³
ç
´°
ã
¤
ã
ã
¦
ã
¯
ã
å
ä
½
ã
¢
ã
¼
ã
ã
»
ã
ª
ã
ã
·
ã
§
ã
³
ã
®
ç
«
ã
®
ã
å
¤
æ
ã
ª
ã
ã
·
ã
§
ã
³
ã
ã
®
é
ã
å
ç
§
ã
ã
¦
ã
ã
ã
ã
ã
ä
¾
ã
ã
°
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
ã
«
ã
¿
ã
«
ã
å
è
§
å
¥
å
ã
¢
ã
¼
ã
ã
é
æ
ç
¯
å
¤
æ
æ
¹
å
¼
ã
é
¸
æ
ã
ã
ã
¦
ã
ã
¾
ã
ã
ã
¾
ã
ã
å
­¦
ç
¿
æ
©
è
½
ã
ã
ª
ã
³
ã
«
ã
ª
ã
ã
¦
ã
ã
¾
ã
ã
ã
ã
«
ã
ï
½¥
ã
ã
¿
ã
³
æ
©
è
½
ã
æ
ä
½
æ
¹
æ
³
ã
å
ã
ã
ã
ª
ã
ã
ã
ã
¯
ã
ã
ª
ã
³
ã
©
ã
¤
ã
³
ã
ã
«
ã
ã
ä
½¿
ã
ã
¦
ç
»
é
¢
ä
¸
ã
§
è
ª¬
æ
ã
å
ç
§
ã
ã
ã
ã
ã
ã
§
ã
ã
¾
ã
ã
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
ã
ª
ã
³
ã
©
ã
¤
ã
³
ã
»
ã
ã
ã
¥
ã
¢
ã
«
ã
ã
ã
«
ã
ã
ã
¥
ã
¼
ã
¯
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
å
¤
æ
ä
½
ç
½®
è
¨­
å
®
ã
ã
¿
ã
³
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
ã
å
º
å
®
ã
ã
¾
ã
ã
¯
ã
å
ç
ã
ã
«
è
¨­
å
®
ã
ã
¾
ã
ã
ã
å
º
å
®
ã
ã
¢
ã
¼
ã
ã
®
ã
ã
ã
¯
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
¯
ç
»
é
¢
å
·¦
ä
¸­
å
¤®
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
ã
å
ç
ã
ã
¢
ã
¼
ã
ã
®
ã
ã
ã
¯
ã
ã
«
ã
¼
ã
½
ã
«
ã
ã
ã
©
ã
¼
ã
«
ã
¹
ã
ã
ã
¦
ã
ã
ã
¦
ã
ã
³
ã
ã
¦
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
ã
¯
ã
­
ã
¼
ã
º
ï
½¥
ã
ã
¿
ã
³
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
VJEã
ç
µ
ä
º
ã
ã
¾
ã
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
®
æ
é
æ
¥
æ
¬
è
ª
å
¥
å
ã
¯
ã
æ
¬¡
ã
®
æ
é
ã
§
è
¡
ã
ã
¾
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
¢
ã
¼
ã
ã
ã
ª
ã
³
ã
«
å
ã
ã
ã
ã
¦
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
æ
å
­
ã
æ
¥
æ
¬
è
ª
ã
«
å
¤
æ
ã
ã
ã
ã
ã
ã
§
ã
ã
¾
ã
ã
è
ª­
ã
¿
ã
å
¥
å
ã
ã
æ
¹
æ
³
ã
«
ã
¯
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
®
ã
¢
ã
«
ã
ã
¡
ã
ã
ã
ã
ã
å
¥
å
ã
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
®
ã
ã
ª
ã
ã
å
¥
å
ã
ã
ã
ã
ã
ª
å
¥
å
ã
ã
ã
ã
ã
¾
ã
ã
å
¥
å
ã
ã
æ
å
­
ã
¯
å
¥
å
ã
¢
ã
¼
ã
ã
®
è
¨­
å
®
ã
«
å
¿
ã
ã
¦
è
¡¨
ç
¤º
ã
ã
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
å
¼
ã
°
ã
ã
¾
ã
ã
å
¥
å
ã
ã
æ
å
­
ã
ã
æ
¼¢
å
­
ã
»
ã
²
ã
ã
ã
ª
ã
»
ã
«
ã
¿
ã
«
ã
ã
¾
ã
ã
¯
è
±
æ
°
ã
®
æ
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
é
·
ã
æ
ã
ä
¸
å
º¦
ã
«
å
¤
æ
ã
ã
ã
ã
ã
§
ã
ã
å
¤
æ
ã
¢
ã
¼
ã
ã
«
å
¿
ã
ã
¦
é
©
å
ã
ª
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
å
¤
æ
ä
¸­
ã
®
æ
å
­
ã
¯
å
è
»¢
è
¡¨
ç
¤º
ã
ã
ã
ä
½
å
º¦
ã
§
ã
å
¥
ã
®
æ
å
­
ç
¨®
ã
«
å
¤
æ
å
¯
è
½
ã
ª
ã
ã
ã
è
¡¨
ã
ã
¦
ã
ã
¾
ã
ã
å
¤
æ
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
ä
º
ã
§
å
¤
æ
ã
ç
µ
ä
º
ã
ã
¦
ã
æ
¬¡
ã
®
æ
å
­
ã
å
¥
å
ã
§
ã
ã
ç
¶
æ
ã
«
ã
ª
ã
ã
¾
ã
ã
è
ª­
ã
¿
ã
å
¥
å
ã
ã
ã
æ
¥
æ
¬
è
ª
ã
ã
ã
ã
å
è
ª
ã
ä
¾
ã
«
å
¥
å
ã
ã
¾
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
NIHONNGOã
ã
«
ã
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
«
ã
»
ã
ã
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
¾
ã
ã
å
¥
å
æ
å
­
ã
å
¤
æ
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
ã
«
ã
»
ã
ã
ã
ã
ã
ã
æ
å
­
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
[
å
¤
æ
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
æ
å
­
å
ã
æ
¥
æ
¬
è
ª
ã
ã
ç
¢º
å
®
ã
ã
¾
ã
ã
[
Enter
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
®
ç
¶
æ
ã
è
¡¨
ç
¤º
ã
ã
¾
ã
ã
ã
¾
ã
ã
ã
ã
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
æ
¥
æ
¬
è
ª
ã
®
å
¥
å
ç
°
å
¢
è
¨­
å
®
ã
å
ä
½
ã
¢
ã
¼
ã
ã
»
ã
ª
ã
ã
·
ã
§
ã
³
ã
å
è
ª
ç
»
é
²
ç
ã
®
ã
ã
¿
ã
³
ã
ç
¾
ã
ã
¾
ã
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
ã
ª
ã
ã
«
ã
ª
ã
ã
¦
ã
ã
ã
ã
ã
«
ã
¯
ã
ç
ç
·
ã
ç
¤º
ã
ã
ã
¾
ã
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
ã
ª
ã
³
ã
«
ã
ª
ã
ã
¦
ã
ã
ã
ã
ã
¯
ã
é
¸
æ
ã
ã
ã
¦
ã
ã
å
¥
å
ã
¢
ã
¼
ã
ã
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
è
©³
ã
ã
ã
¯
ã
æ
¬¡
ç
«
å
¥
å
ç
°
å
¢
ã
®
é
ã
å
ç
§
ã
ã
¦
ã
ã
ã
ã
ã
ï
¼»
æ
¼¢
å
­
ï
¼½
ã
­
ã
¼
ã
¾
ã
ã
¯
[
Alt
]+[~]
ã
æ
¼
ã
ã
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
®
ã
ª
ã
³
ã
»
ã
ª
ã
ã
å
ã
æ
¿
ã
ã
ã
¾
ã
ã
ã
¢
ã
¼
ã
ã
»
ã
¹
ã
ã
¼
ã
¿
ã
¹
ã
»
ã
ã
¿
ã
³
ã
¯
ã
ç
¾
å
é
¸
ã
ã
ã
¦
ã
ã
å
¥
å
ç
°
å
¢
ã
è
¡¨
ç
¤º
ã
ã
¾
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
®
ã
ã
ã
¯[
R
]
ã
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
[
R
]
ã
è
¡¨
ç
¤º
ã
ã
ã
¦
ã
ã
ª
ã
å
å
ã
¯
ã
ã
ã
ª
å
¥
å
ã
é
¸
æ
ã
ã
ã
¦
ã
ã
¾
ã
ã
[
ã
ã
ª]
ã
[
ã
«
ã
]
ã
[
è
±
æ
°]
ã
§
é
¸
æ
ã
ã
ã
¦
ã
ã
å
¥
å
æ
å
­
ç
¨®
ã
ç
¤º
ã
ã
¾
ã
ã
å
è
§
å
¥
å
ã
®
ã
ã
ã
¯[
å
¨]
ã
å
è
§
å
¥
å
ã
®
ã
ã
ã
¯[
å
]
ã
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
ï
¼
ã
¯
å
­¦
ç
¿
æ
©
è
½
ã
ã
ª
ã
³
ã
§
ã
ã
ã
ã
ã
ç
¤º
ã
ã
¾
ã
ã
[
B
]
ã
¯
é
æ
ç
¯
å
¤
æ
ã
[
F
]
ã
¯
è
¤
å
è
ª
å
¤
æ
ã
é
¸
æ
ã
ã
ã
¦
ã
ã
ã
ã
ã
ç
¤º
ã
ã
¾
ã
ã
å
¤
æ
æ
¹
å
¼
ã
ã
ã
³
å
­¦
ç
¿
æ
©
è
½
ã
®
è
©³
ç
´°
ã
¤
ã
ã
¦
ã
¯
ã
å
ä
½
ã
¢
ã
¼
ã
ã
»
ã
ª
ã
ã
·
ã
§
ã
³
ã
®
ç
«
ã
®
ã
å
¤
æ
ã
ª
ã
ã
·
ã
§
ã
³
ã
ã
®
é
ã
å
ç
§
ã
ã
¦
ã
ã
ã
ã
ã
ä
¾
ã
ã
°
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
ã
«
ã
¿
ã
«
ã
å
è
§
å
¥
å
ã
¢
ã
¼
ã
ã
é
æ
ç
¯
å
¤
æ
æ
¹
å
¼
ã
é
¸
æ
ã
ã
ã
¦
ã
ã
¾
ã
ã
ã
¾
ã
ã
å
­¦
ç
¿
æ
©
è
½
ã
ã
ª
ã
³
ã
«
ã
ª
ã
ã
¦
ã
ã
¾
ã
ã
ã
ã
«
ã
ï
½¥
ã
ã
¿
ã
³
æ
©
è
½
ã
æ
ä
½
æ
¹
æ
³
ã
å
ã
ã
ã
ª
ã
ã
ã
ã
¯
ã
ã
ª
ã
³
ã
©
ã
¤
ã
³
ã
ã
«
ã
ã
ä
½¿
ã
ã
¦
ç
»
é
¢
ä
¸
ã
§
è
ª¬
æ
ã
å
ç
§
ã
ã
ã
ã
ã
ã
§
ã
ã
¾
ã
ã
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
ã
ª
ã
³
ã
©
ã
¤
ã
³
ã
»
ã
ã
ã
¥
ã
¢
ã
«
ã
ã
ã
«
ã
ã
ã
¥
ã
¼
ã
¯
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
å
¤
æ
ä
½
ç
½®
è
¨­
å
®
ã
ã
¿
ã
³
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
ã
å
º
å
®
ã
ã
¾
ã
ã
¯
ã
å
ç
ã
ã
«
è
¨­
å
®
ã
ã
¾
ã
ã
ã
å
º
å
®
ã
ã
¢
ã
¼
ã
ã
®
ã
ã
ã
¯
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
¯
ç
»
é
¢
å
·¦
ä
¸­
å
¤®
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
ã
å
ç
ã
ã
¢
ã
¼
ã
ã
®
ã
ã
ã
¯
ã
ã
«
ã
¼
ã
½
ã
«
ã
ã
ã
©
ã
¼
ã
«
ã
¹
ã
ã
ã
¦
ã
ã
ã
¦
ã
ã
³
ã
ã
¦
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
ã
¯
ã
­
ã
¼
ã
º
ï
½¥
ã
ã
¿
ã
³
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
VJEã
ç
µ
ä
º
ã
ã
¾
ã
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
®
æ
é
æ
¥
æ
¬
è
ª
å
¥
å
ã
¯
ã
æ
¬¡
ã
®
æ
é
ã
§
è
¡
ã
ã
¾
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
¢
ã
¼
ã
ã
ã
ª
ã
³
ã
«
å
ã
ã
ã
ã
¦
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
æ
å
­
ã
æ
¥
æ
¬
è
ª
ã
«
å
¤
æ
ã
ã
ã
ã
ã
ã
§
ã
ã
¾
ã
ã
è
ª­
ã
¿
ã
å
¥
å
ã
ã
æ
¹
æ
³
ã
«
ã
¯
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
®
ã
¢
ã
«
ã
ã
¡
ã
ã
ã
ã
ã
å
¥
å
ã
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
®
ã
ã
ª
ã
ã
å
¥
å
ã
ã
ã
ã
ã
ª
å
¥
å
ã
ã
ã
ã
ã
¾
ã
ã
å
¥
å
ã
ã
æ
å
­
ã
¯
å
¥
å
ã
¢
ã
¼
ã
ã
®
è
¨­
å
®
ã
«
å
¿
ã
ã
¦
è
¡¨
ç
¤º
ã
ã
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
å
¼
ã
°
ã
ã
¾
ã
ã
å
¥
å
ã
ã
æ
å
­
ã
ã
æ
¼¢
å
­
ã
»
ã
²
ã
ã
ã
ª
ã
»
ã
«
ã
¿
ã
«
ã
ã
¾
ã
ã
¯
è
±
æ
°
ã
®
æ
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
é
·
ã
æ
ã
ä
¸
å
º¦
ã
«
å
¤
æ
ã
ã
ã
ã
ã
§
ã
ã
å
¤
æ
ã
¢
ã
¼
ã
ã
«
å
¿
ã
ã
¦
é
©
å
ã
ª
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
å
¤
æ
ä
¸­
ã
®
æ
å
­
ã
¯
å
è
»¢
è
¡¨
ç
¤º
ã
ã
ã
ä
½
å
º¦
ã
§
ã
å
¥
ã
®
æ
å
­
ç
¨®
ã
«
å
¤
æ
å
¯
è
½
ã
ª
ã
ã
ã
è
¡¨
ã
ã
¦
ã
ã
¾
ã
ã
å
¤
æ
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
ä
º
ã
§
å
¤
æ
ã
ç
µ
ä
º
ã
ã
¦
ã
æ
¬¡
ã
®
æ
å
­
ã
å
¥
å
ã
§
ã
ã
ç
¶
æ
ã
«
ã
ª
ã
ã
¾
ã
ã
è
ª­
ã
¿
ã
å
¥
å
ã
ã
ã
æ
¥
æ
¬
è
ª
ã
ã
ã
ã
å
è
ª
ã
ä
¾
ã
«
å
¥
å
ã
ã
¾
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
NIHONNGOã
ã
«
ã
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
«
ã
»
ã
ã
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
¾
ã
ã
å
¥
å
æ
å
­
ã
å
¤
æ
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
ã
«
ã
»
ã
ã
ã
ã
ã
ã
æ
å
­
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
[
å
¤
æ
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
æ
å
­
å
ã
æ
¥
æ
¬
è
ª
ã
ã
ç
¢º
å
®
ã
ã
¾
ã
ã
[
Enter
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
ã
¢
ã
¼
ã
ã
»
ã
¹
ã
ã
¼
ã
¿
ã
¹
ã
»
ã
ã
¿
ã
³
ã
¯
ã
ç
¾
å
é
¸
ã
ã
ã
¦
ã
ã
å
¥
å
ç
°
å
¢
ã
è
¡¨
ç
¤º
ã
ã
¾
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
®
ã
ã
ã
¯[
R
]
ã
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
[
R
]
ã
è
¡¨
ç
¤º
ã
ã
ã
¦
ã
ã
ª
ã
å
å
ã
¯
ã
ã
ã
ª
å
¥
å
ã
é
¸
æ
ã
ã
ã
¦
ã
ã
¾
ã
ã
[
ã
ã
ª]
ã
[
ã
«
ã
]
ã
[
è
±
æ
°]
ã
§
é
¸
æ
ã
ã
ã
¦
ã
ã
å
¥
å
æ
å
­
ç
¨®
ã
ç
¤º
ã
ã
¾
ã
ã
å
è
§
å
¥
å
ã
®
ã
ã
ã
¯[
å
¨]
ã
å
è
§
å
¥
å
ã
®
ã
ã
ã
¯[
å
]
ã
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
ï
¼
ã
¯
å
­¦
ç
¿
æ
©
è
½
ã
ã
ª
ã
³
ã
§
ã
ã
ã
ã
ã
ç
¤º
ã
ã
¾
ã
ã
[
B
]
ã
¯
é
æ
ç
¯
å
¤
æ
ã
[
F
]
ã
¯
è
¤
å
è
ª
å
¤
æ
ã
é
¸
æ
ã
ã
ã
¦
ã
ã
ã
ã
ã
ç
¤º
ã
ã
¾
ã
ã
å
¤
æ
æ
¹
å
¼
ã
ã
ã
³
å
­¦
ç
¿
æ
©
è
½
ã
®
è
©³
ç
´°
ã
¤
ã
ã
¦
ã
¯
ã
å
ä
½
ã
¢
ã
¼
ã
ã
»
ã
ª
ã
ã
·
ã
§
ã
³
ã
®
ç
«
ã
®
ã
å
¤
æ
ã
ª
ã
ã
·
ã
§
ã
³
ã
ã
®
é
ã
å
ç
§
ã
ã
¦
ã
ã
ã
ã
ã
ä
¾
ã
ã
°
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
ã
«
ã
¿
ã
«
ã
å
è
§
å
¥
å
ã
¢
ã
¼
ã
ã
é
æ
ç
¯
å
¤
æ
æ
¹
å
¼
ã
é
¸
æ
ã
ã
ã
¦
ã
ã
¾
ã
ã
ã
¾
ã
ã
å
­¦
ç
¿
æ
©
è
½
ã
ã
ª
ã
³
ã
«
ã
ª
ã
ã
¦
ã
ã
¾
ã
ã
ã
ã
«
ã
ï
½¥
ã
ã
¿
ã
³
æ
©
è
½
ã
æ
ä
½
æ
¹
æ
³
ã
å
ã
ã
ã
ª
ã
ã
ã
ã
¯
ã
ã
ª
ã
³
ã
©
ã
¤
ã
³
ã
ã
«
ã
ã
ä
½¿
ã
ã
¦
ç
»
é
¢
ä
¸
ã
§
è
ª¬
æ
ã
å
ç
§
ã
ã
ã
ã
ã
ã
§
ã
ã
¾
ã
ã
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
ã
ª
ã
³
ã
©
ã
¤
ã
³
ã
»
ã
ã
ã
¥
ã
¢
ã
«
ã
ã
ã
«
ã
ã
ã
¥
ã
¼
ã
¯
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
å
¤
æ
ä
½
ç
½®
è
¨­
å
®
ã
ã
¿
ã
³
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
ã
å
º
å
®
ã
ã
¾
ã
ã
¯
ã
å
ç
ã
ã
«
è
¨­
å
®
ã
ã
¾
ã
ã
ã
å
º
å
®
ã
ã
¢
ã
¼
ã
ã
®
ã
ã
ã
¯
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
¯
ç
»
é
¢
å
·¦
ä
¸­
å
¤®
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
ã
å
ç
ã
ã
¢
ã
¼
ã
ã
®
ã
ã
ã
¯
ã
ã
«
ã
¼
ã
½
ã
«
ã
ã
ã
©
ã
¼
ã
«
ã
¹
ã
ã
ã
¦
ã
ã
ã
¦
ã
ã
³
ã
ã
¦
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
ã
¯
ã
­
ã
¼
ã
º
ï
½¥
ã
ã
¿
ã
³
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
VJEã
ç
µ
ä
º
ã
ã
¾
ã
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
®
æ
é
æ
¥
æ
¬
è
ª
å
¥
å
ã
¯
ã
æ
¬¡
ã
®
æ
é
ã
§
è
¡
ã
ã
¾
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
¢
ã
¼
ã
ã
ã
ª
ã
³
ã
«
å
ã
ã
ã
ã
¦
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
æ
å
­
ã
æ
¥
æ
¬
è
ª
ã
«
å
¤
æ
ã
ã
ã
ã
ã
ã
§
ã
ã
¾
ã
ã
è
ª­
ã
¿
ã
å
¥
å
ã
ã
æ
¹
æ
³
ã
«
ã
¯
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
®
ã
¢
ã
«
ã
ã
¡
ã
ã
ã
ã
ã
å
¥
å
ã
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
®
ã
ã
ª
ã
ã
å
¥
å
ã
ã
ã
ã
ã
ª
å
¥
å
ã
ã
ã
ã
ã
¾
ã
ã
å
¥
å
ã
ã
æ
å
­
ã
¯
å
¥
å
ã
¢
ã
¼
ã
ã
®
è
¨­
å
®
ã
«
å
¿
ã
ã
¦
è
¡¨
ç
¤º
ã
ã
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
å
¼
ã
°
ã
ã
¾
ã
ã
å
¥
å
ã
ã
æ
å
­
ã
ã
æ
¼¢
å
­
ã
»
ã
²
ã
ã
ã
ª
ã
»
ã
«
ã
¿
ã
«
ã
ã
¾
ã
ã
¯
è
±
æ
°
ã
®
æ
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
é
·
ã
æ
ã
ä
¸
å
º¦
ã
«
å
¤
æ
ã
ã
ã
ã
ã
§
ã
ã
å
¤
æ
ã
¢
ã
¼
ã
ã
«
å
¿
ã
ã
¦
é
©
å
ã
ª
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
å
¤
æ
ä
¸­
ã
®
æ
å
­
ã
¯
å
è
»¢
è
¡¨
ç
¤º
ã
ã
ã
ä
½
å
º¦
ã
§
ã
å
¥
ã
®
æ
å
­
ç
¨®
ã
«
å
¤
æ
å
¯
è
½
ã
ª
ã
ã
ã
è
¡¨
ã
ã
¦
ã
ã
¾
ã
ã
å
¤
æ
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
ä
º
ã
§
å
¤
æ
ã
ç
µ
ä
º
ã
ã
¦
ã
æ
¬¡
ã
®
æ
å
­
ã
å
¥
å
ã
§
ã
ã
ç
¶
æ
ã
«
ã
ª
ã
ã
¾
ã
ã
è
ª­
ã
¿
ã
å
¥
å
ã
ã
ã
æ
¥
æ
¬
è
ª
ã
ã
ã
ã
å
è
ª
ã
ä
¾
ã
«
å
¥
å
ã
ã
¾
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
NIHONNGOã
ã
«
ã
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
«
ã
»
ã
ã
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
¾
ã
ã
å
¥
å
æ
å
­
ã
å
¤
æ
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
ã
«
ã
»
ã
ã
ã
ã
ã
ã
æ
å
­
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
[
å
¤
æ
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
æ
å
­
å
ã
æ
¥
æ
¬
è
ª
ã
ã
ç
¢º
å
®
ã
ã
¾
ã
ã
[
Enter
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
ä
¾
ã
ã
°
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
ã
«
ã
¿
ã
«
ã
å
è
§
å
¥
å
ã
¢
ã
¼
ã
ã
é
æ
ç
¯
å
¤
æ
æ
¹
å
¼
ã
é
¸
æ
ã
ã
ã
¦
ã
ã
¾
ã
ã
ã
¾
ã
ã
å
­¦
ç
¿
æ
©
è
½
ã
ã
ª
ã
³
ã
«
ã
ª
ã
ã
¦
ã
ã
¾
ã
ã
ã
ã
«
ã
ï
½¥
ã
ã
¿
ã
³
æ
©
è
½
ã
æ
ä
½
æ
¹
æ
³
ã
å
ã
ã
ã
ª
ã
ã
ã
ã
¯
ã
ã
ª
ã
³
ã
©
ã
¤
ã
³
ã
ã
«
ã
ã
ä
½¿
ã
ã
¦
ç
»
é
¢
ä
¸
ã
§
è
ª¬
æ
ã
å
ç
§
ã
ã
ã
ã
ã
ã
§
ã
ã
¾
ã
ã
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
ã
ª
ã
³
ã
©
ã
¤
ã
³
ã
»
ã
ã
ã
¥
ã
¢
ã
«
ã
ã
ã
«
ã
ã
ã
¥
ã
¼
ã
¯
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
å
¤
æ
ä
½
ç
½®
è
¨­
å
®
ã
ã
¿
ã
³
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
ã
å
º
å
®
ã
ã
¾
ã
ã
¯
ã
å
ç
ã
ã
«
è
¨­
å
®
ã
ã
¾
ã
ã
ã
å
º
å
®
ã
ã
¢
ã
¼
ã
ã
®
ã
ã
ã
¯
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
¯
ç
»
é
¢
å
·¦
ä
¸­
å
¤®
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
ã
å
ç
ã
ã
¢
ã
¼
ã
ã
®
ã
ã
ã
¯
ã
ã
«
ã
¼
ã
½
ã
«
ã
ã
ã
©
ã
¼
ã
«
ã
¹
ã
ã
ã
¦
ã
ã
ã
¦
ã
ã
³
ã
ã
¦
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
ã
¯
ã
­
ã
¼
ã
º
ï
½¥
ã
ã
¿
ã
³
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
VJEã
ç
µ
ä
º
ã
ã
¾
ã
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
®
æ
é
æ
¥
æ
¬
è
ª
å
¥
å
ã
¯
ã
æ
¬¡
ã
®
æ
é
ã
§
è
¡
ã
ã
¾
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
¢
ã
¼
ã
ã
ã
ª
ã
³
ã
«
å
ã
ã
ã
ã
¦
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
æ
å
­
ã
æ
¥
æ
¬
è
ª
ã
«
å
¤
æ
ã
ã
ã
ã
ã
ã
§
ã
ã
¾
ã
ã
è
ª­
ã
¿
ã
å
¥
å
ã
ã
æ
¹
æ
³
ã
«
ã
¯
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
®
ã
¢
ã
«
ã
ã
¡
ã
ã
ã
ã
ã
å
¥
å
ã
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
®
ã
ã
ª
ã
ã
å
¥
å
ã
ã
ã
ã
ã
ª
å
¥
å
ã
ã
ã
ã
ã
¾
ã
ã
å
¥
å
ã
ã
æ
å
­
ã
¯
å
¥
å
ã
¢
ã
¼
ã
ã
®
è
¨­
å
®
ã
«
å
¿
ã
ã
¦
è
¡¨
ç
¤º
ã
ã
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
å
¼
ã
°
ã
ã
¾
ã
ã
å
¥
å
ã
ã
æ
å
­
ã
ã
æ
¼¢
å
­
ã
»
ã
²
ã
ã
ã
ª
ã
»
ã
«
ã
¿
ã
«
ã
ã
¾
ã
ã
¯
è
±
æ
°
ã
®
æ
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
é
·
ã
æ
ã
ä
¸
å
º¦
ã
«
å
¤
æ
ã
ã
ã
ã
ã
§
ã
ã
å
¤
æ
ã
¢
ã
¼
ã
ã
«
å
¿
ã
ã
¦
é
©
å
ã
ª
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
å
¤
æ
ä
¸­
ã
®
æ
å
­
ã
¯
å
è
»¢
è
¡¨
ç
¤º
ã
ã
ã
ä
½
å
º¦
ã
§
ã
å
¥
ã
®
æ
å
­
ç
¨®
ã
«
å
¤
æ
å
¯
è
½
ã
ª
ã
ã
ã
è
¡¨
ã
ã
¦
ã
ã
¾
ã
ã
å
¤
æ
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
ä
º
ã
§
å
¤
æ
ã
ç
µ
ä
º
ã
ã
¦
ã
æ
¬¡
ã
®
æ
å
­
ã
å
¥
å
ã
§
ã
ã
ç
¶
æ
ã
«
ã
ª
ã
ã
¾
ã
ã
è
ª­
ã
¿
ã
å
¥
å
ã
ã
ã
æ
¥
æ
¬
è
ª
ã
ã
ã
ã
å
è
ª
ã
ä
¾
ã
«
å
¥
å
ã
ã
¾
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
NIHONNGOã
ã
«
ã
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
«
ã
»
ã
ã
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
¾
ã
ã
å
¥
å
æ
å
­
ã
å
¤
æ
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
ã
«
ã
»
ã
ã
ã
ã
ã
ã
æ
å
­
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
[
å
¤
æ
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
æ
å
­
å
ã
æ
¥
æ
¬
è
ª
ã
ã
ç
¢º
å
®
ã
ã
¾
ã
ã
[
Enter
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
ã
«
ã
¿
ã
«
ã
å
è
§
å
¥
å
ã
¢
ã
¼
ã
ã
é
æ
ç
¯
å
¤
æ
æ
¹
å
¼
ã
é
¸
æ
ã
ã
ã
¦
ã
ã
¾
ã
ã
ã
¾
ã
ã
å
­¦
ç
¿
æ
©
è
½
ã
ã
ª
ã
³
ã
«
ã
ª
ã
ã
¦
ã
ã
¾
ã
ã
ã
ã
«
ã
ï
½¥
ã
ã
¿
ã
³
æ
©
è
½
ã
æ
ä
½
æ
¹
æ
³
ã
å
ã
ã
ã
ª
ã
ã
ã
ã
¯
ã
ã
ª
ã
³
ã
©
ã
¤
ã
³
ã
ã
«
ã
ã
ä
½¿
ã
ã
¦
ç
»
é
¢
ä
¸
ã
§
è
ª¬
æ
ã
å
ç
§
ã
ã
ã
ã
ã
ã
§
ã
ã
¾
ã
ã
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
ã
ª
ã
³
ã
©
ã
¤
ã
³
ã
»
ã
ã
ã
¥
ã
¢
ã
«
ã
ã
ã
«
ã
ã
ã
¥
ã
¼
ã
¯
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
å
¤
æ
ä
½
ç
½®
è
¨­
å
®
ã
ã
¿
ã
³
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
ã
å
º
å
®
ã
ã
¾
ã
ã
¯
ã
å
ç
ã
ã
«
è
¨­
å
®
ã
ã
¾
ã
ã
ã
å
º
å
®
ã
ã
¢
ã
¼
ã
ã
®
ã
ã
ã
¯
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
¯
ç
»
é
¢
å
·¦
ä
¸­
å
¤®
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
ã
å
ç
ã
ã
¢
ã
¼
ã
ã
®
ã
ã
ã
¯
ã
ã
«
ã
¼
ã
½
ã
«
ã
ã
ã
©
ã
¼
ã
«
ã
¹
ã
ã
ã
¦
ã
ã
ã
¦
ã
ã
³
ã
ã
¦
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
ã
¯
ã
­
ã
¼
ã
º
ï
½¥
ã
ã
¿
ã
³
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
VJEã
ç
µ
ä
º
ã
ã
¾
ã
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
®
æ
é
æ
¥
æ
¬
è
ª
å
¥
å
ã
¯
ã
æ
¬¡
ã
®
æ
é
ã
§
è
¡
ã
ã
¾
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
¢
ã
¼
ã
ã
ã
ª
ã
³
ã
«
å
ã
ã
ã
ã
¦
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
æ
å
­
ã
æ
¥
æ
¬
è
ª
ã
«
å
¤
æ
ã
ã
ã
ã
ã
ã
§
ã
ã
¾
ã
ã
è
ª­
ã
¿
ã
å
¥
å
ã
ã
æ
¹
æ
³
ã
«
ã
¯
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
®
ã
¢
ã
«
ã
ã
¡
ã
ã
ã
ã
ã
å
¥
å
ã
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
®
ã
ã
ª
ã
ã
å
¥
å
ã
ã
ã
ã
ã
ª
å
¥
å
ã
ã
ã
ã
ã
¾
ã
ã
å
¥
å
ã
ã
æ
å
­
ã
¯
å
¥
å
ã
¢
ã
¼
ã
ã
®
è
¨­
å
®
ã
«
å
¿
ã
ã
¦
è
¡¨
ç
¤º
ã
ã
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
å
¼
ã
°
ã
ã
¾
ã
ã
å
¥
å
ã
ã
æ
å
­
ã
ã
æ
¼¢
å
­
ã
»
ã
²
ã
ã
ã
ª
ã
»
ã
«
ã
¿
ã
«
ã
ã
¾
ã
ã
¯
è
±
æ
°
ã
®
æ
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
é
·
ã
æ
ã
ä
¸
å
º¦
ã
«
å
¤
æ
ã
ã
ã
ã
ã
§
ã
ã
å
¤
æ
ã
¢
ã
¼
ã
ã
«
å
¿
ã
ã
¦
é
©
å
ã
ª
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
å
¤
æ
ä
¸­
ã
®
æ
å
­
ã
¯
å
è
»¢
è
¡¨
ç
¤º
ã
ã
ã
ä
½
å
º¦
ã
§
ã
å
¥
ã
®
æ
å
­
ç
¨®
ã
«
å
¤
æ
å
¯
è
½
ã
ª
ã
ã
ã
è
¡¨
ã
ã
¦
ã
ã
¾
ã
ã
å
¤
æ
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
ä
º
ã
§
å
¤
æ
ã
ç
µ
ä
º
ã
ã
¦
ã
æ
¬¡
ã
®
æ
å
­
ã
å
¥
å
ã
§
ã
ã
ç
¶
æ
ã
«
ã
ª
ã
ã
¾
ã
ã
è
ª­
ã
¿
ã
å
¥
å
ã
ã
ã
æ
¥
æ
¬
è
ª
ã
ã
ã
ã
å
è
ª
ã
ä
¾
ã
«
å
¥
å
ã
ã
¾
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
NIHONNGOã
ã
«
ã
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
«
ã
»
ã
ã
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
¾
ã
ã
å
¥
å
æ
å
­
ã
å
¤
æ
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
ã
«
ã
»
ã
ã
ã
ã
ã
ã
æ
å
­
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
[
å
¤
æ
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
æ
å
­
å
ã
æ
¥
æ
¬
è
ª
ã
ã
ç
¢º
å
®
ã
ã
¾
ã
ã
[
Enter
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
ã
«
ã
¿
ã
«
ã
å
è
§
å
¥
å
ã
¢
ã
¼
ã
ã
é
æ
ç
¯
å
¤
æ
æ
¹
å
¼
ã
é
¸
æ
ã
ã
ã
¦
ã
ã
¾
ã
ã
ã
¾
ã
ã
å
­¦
ç
¿
æ
©
è
½
ã
ã
ª
ã
³
ã
«
ã
ª
ã
ã
¦
ã
ã
¾
ã
ã
ã
ã
«
ã
ï
½¥
ã
ã
¿
ã
³
æ
©
è
½
ã
æ
ä
½
æ
¹
æ
³
ã
å
ã
ã
ã
ª
ã
ã
ã
ã
¯
ã
ã
ª
ã
³
ã
©
ã
¤
ã
³
ã
ã
«
ã
ã
ä
½¿
ã
ã
¦
ç
»
é
¢
ä
¸
ã
§
è
ª¬
æ
ã
å
ç
§
ã
ã
ã
ã
ã
ã
§
ã
ã
¾
ã
ã
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
ã
ª
ã
³
ã
©
ã
¤
ã
³
ã
»
ã
ã
ã
¥
ã
¢
ã
«
ã
ã
ã
«
ã
ã
ã
¥
ã
¼
ã
¯
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
å
¤
æ
ä
½
ç
½®
è
¨­
å
®
ã
ã
¿
ã
³
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
ã
å
º
å
®
ã
ã
¾
ã
ã
¯
ã
å
ç
ã
ã
«
è
¨­
å
®
ã
ã
¾
ã
ã
ã
å
º
å
®
ã
ã
¢
ã
¼
ã
ã
®
ã
ã
ã
¯
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
¯
ç
»
é
¢
å
·¦
ä
¸­
å
¤®
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
ã
å
ç
ã
ã
¢
ã
¼
ã
ã
®
ã
ã
ã
¯
ã
ã
«
ã
¼
ã
½
ã
«
ã
ã
ã
©
ã
¼
ã
«
ã
¹
ã
ã
ã
¦
ã
ã
ã
¦
ã
ã
³
ã
ã
¦
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
ã
¯
ã
­
ã
¼
ã
º
ï
½¥
ã
ã
¿
ã
³
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
VJEã
ç
µ
ä
º
ã
ã
¾
ã
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
®
æ
é
æ
¥
æ
¬
è
ª
å
¥
å
ã
¯
ã
æ
¬¡
ã
®
æ
é
ã
§
è
¡
ã
ã
¾
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
¢
ã
¼
ã
ã
ã
ª
ã
³
ã
«
å
ã
ã
ã
ã
¦
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
æ
å
­
ã
æ
¥
æ
¬
è
ª
ã
«
å
¤
æ
ã
ã
ã
ã
ã
ã
§
ã
ã
¾
ã
ã
è
ª­
ã
¿
ã
å
¥
å
ã
ã
æ
¹
æ
³
ã
«
ã
¯
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
®
ã
¢
ã
«
ã
ã
¡
ã
ã
ã
ã
ã
å
¥
å
ã
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
®
ã
ã
ª
ã
ã
å
¥
å
ã
ã
ã
ã
ã
ª
å
¥
å
ã
ã
ã
ã
ã
¾
ã
ã
å
¥
å
ã
ã
æ
å
­
ã
¯
å
¥
å
ã
¢
ã
¼
ã
ã
®
è
¨­
å
®
ã
«
å
¿
ã
ã
¦
è
¡¨
ç
¤º
ã
ã
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
å
¼
ã
°
ã
ã
¾
ã
ã
å
¥
å
ã
ã
æ
å
­
ã
ã
æ
¼¢
å
­
ã
»
ã
²
ã
ã
ã
ª
ã
»
ã
«
ã
¿
ã
«
ã
ã
¾
ã
ã
¯
è
±
æ
°
ã
®
æ
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
é
·
ã
æ
ã
ä
¸
å
º¦
ã
«
å
¤
æ
ã
ã
ã
ã
ã
§
ã
ã
å
¤
æ
ã
¢
ã
¼
ã
ã
«
å
¿
ã
ã
¦
é
©
å
ã
ª
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
å
¤
æ
ä
¸­
ã
®
æ
å
­
ã
¯
å
è
»¢
è
¡¨
ç
¤º
ã
ã
ã
ä
½
å
º¦
ã
§
ã
å
¥
ã
®
æ
å
­
ç
¨®
ã
«
å
¤
æ
å
¯
è
½
ã
ª
ã
ã
ã
è
¡¨
ã
ã
¦
ã
ã
¾
ã
ã
å
¤
æ
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
ä
º
ã
§
å
¤
æ
ã
ç
µ
ä
º
ã
ã
¦
ã
æ
¬¡
ã
®
æ
å
­
ã
å
¥
å
ã
§
ã
ã
ç
¶
æ
ã
«
ã
ª
ã
ã
¾
ã
ã
è
ª­
ã
¿
ã
å
¥
å
ã
ã
ã
æ
¥
æ
¬
è
ª
ã
ã
ã
ã
å
è
ª
ã
ä
¾
ã
«
å
¥
å
ã
ã
¾
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
NIHONNGOã
ã
«
ã
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
«
ã
»
ã
ã
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
¾
ã
ã
å
¥
å
æ
å
­
ã
å
¤
æ
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
ã
«
ã
»
ã
ã
ã
ã
ã
ã
æ
å
­
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
[
å
¤
æ
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
æ
å
­
å
ã
æ
¥
æ
¬
è
ª
ã
ã
ç
¢º
å
®
ã
ã
¾
ã
ã
[
Enter
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
æ
©
è
½
ã
æ
ä
½
æ
¹
æ
³
ã
å
ã
ã
ã
ª
ã
ã
ã
ã
¯
ã
ã
ª
ã
³
ã
©
ã
¤
ã
³
ã
ã
«
ã
ã
ä
½¿
ã
ã
¦
ç
»
é
¢
ä
¸
ã
§
è
ª¬
æ
ã
å
ç
§
ã
ã
ã
ã
ã
ã
§
ã
ã
¾
ã
ã
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
ã
ª
ã
³
ã
©
ã
¤
ã
³
ã
»
ã
ã
ã
¥
ã
¢
ã
«
ã
ã
ã
«
ã
ã
ã
¥
ã
¼
ã
¯
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
å
¤
æ
ä
½
ç
½®
è
¨­
å
®
ã
ã
¿
ã
³
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
ã
å
º
å
®
ã
ã
¾
ã
ã
¯
ã
å
ç
ã
ã
«
è
¨­
å
®
ã
ã
¾
ã
ã
ã
å
º
å
®
ã
ã
¢
ã
¼
ã
ã
®
ã
ã
ã
¯
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
¯
ç
»
é
¢
å
·¦
ä
¸­
å
¤®
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
ã
å
ç
ã
ã
¢
ã
¼
ã
ã
®
ã
ã
ã
¯
ã
ã
«
ã
¼
ã
½
ã
«
ã
ã
ã
©
ã
¼
ã
«
ã
¹
ã
ã
ã
¦
ã
ã
ã
¦
ã
ã
³
ã
ã
¦
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
ã
¯
ã
­
ã
¼
ã
º
ï
½¥
ã
ã
¿
ã
³
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
VJEã
ç
µ
ä
º
ã
ã
¾
ã
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
®
æ
é
æ
¥
æ
¬
è
ª
å
¥
å
ã
¯
ã
æ
¬¡
ã
®
æ
é
ã
§
è
¡
ã
ã
¾
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
¢
ã
¼
ã
ã
ã
ª
ã
³
ã
«
å
ã
ã
ã
ã
¦
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
æ
å
­
ã
æ
¥
æ
¬
è
ª
ã
«
å
¤
æ
ã
ã
ã
ã
ã
ã
§
ã
ã
¾
ã
ã
è
ª­
ã
¿
ã
å
¥
å
ã
ã
æ
¹
æ
³
ã
«
ã
¯
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
®
ã
¢
ã
«
ã
ã
¡
ã
ã
ã
ã
ã
å
¥
å
ã
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
®
ã
ã
ª
ã
ã
å
¥
å
ã
ã
ã
ã
ã
ª
å
¥
å
ã
ã
ã
ã
ã
¾
ã
ã
å
¥
å
ã
ã
æ
å
­
ã
¯
å
¥
å
ã
¢
ã
¼
ã
ã
®
è
¨­
å
®
ã
«
å
¿
ã
ã
¦
è
¡¨
ç
¤º
ã
ã
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
å
¼
ã
°
ã
ã
¾
ã
ã
å
¥
å
ã
ã
æ
å
­
ã
ã
æ
¼¢
å
­
ã
»
ã
²
ã
ã
ã
ª
ã
»
ã
«
ã
¿
ã
«
ã
ã
¾
ã
ã
¯
è
±
æ
°
ã
®
æ
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
é
·
ã
æ
ã
ä
¸
å
º¦
ã
«
å
¤
æ
ã
ã
ã
ã
ã
§
ã
ã
å
¤
æ
ã
¢
ã
¼
ã
ã
«
å
¿
ã
ã
¦
é
©
å
ã
ª
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
å
¤
æ
ä
¸­
ã
®
æ
å
­
ã
¯
å
è
»¢
è
¡¨
ç
¤º
ã
ã
ã
ä
½
å
º¦
ã
§
ã
å
¥
ã
®
æ
å
­
ç
¨®
ã
«
å
¤
æ
å
¯
è
½
ã
ª
ã
ã
ã
è
¡¨
ã
ã
¦
ã
ã
¾
ã
ã
å
¤
æ
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
ä
º
ã
§
å
¤
æ
ã
ç
µ
ä
º
ã
ã
¦
ã
æ
¬¡
ã
®
æ
å
­
ã
å
¥
å
ã
§
ã
ã
ç
¶
æ
ã
«
ã
ª
ã
ã
¾
ã
ã
è
ª­
ã
¿
ã
å
¥
å
ã
ã
ã
æ
¥
æ
¬
è
ª
ã
ã
ã
ã
å
è
ª
ã
ä
¾
ã
«
å
¥
å
ã
ã
¾
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
NIHONNGOã
ã
«
ã
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
«
ã
»
ã
ã
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
¾
ã
ã
å
¥
å
æ
å
­
ã
å
¤
æ
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
ã
«
ã
»
ã
ã
ã
ã
ã
ã
æ
å
­
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
[
å
¤
æ
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
æ
å
­
å
ã
æ
¥
æ
¬
è
ª
ã
ã
ç
¢º
å
®
ã
ã
¾
ã
ã
[
Enter
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
ã
å
º
å
®
ã
ã
¾
ã
ã
¯
ã
å
ç
ã
ã
«
è
¨­
å
®
ã
ã
¾
ã
ã
ã
å
º
å
®
ã
ã
¢
ã
¼
ã
ã
®
ã
ã
ã
¯
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
¯
ç
»
é
¢
å
·¦
ä
¸­
å
¤®
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
ã
å
ç
ã
ã
¢
ã
¼
ã
ã
®
ã
ã
ã
¯
ã
ã
«
ã
¼
ã
½
ã
«
ã
ã
ã
©
ã
¼
ã
«
ã
¹
ã
ã
ã
¦
ã
ã
ã
¦
ã
ã
³
ã
ã
¦
ã
«
è
¡¨
ç
¤º
ã
ã
ã
¾
ã
ã
ã
¯
ã
­
ã
¼
ã
º
ï
½¥
ã
ã
¿
ã
³
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
VJEã
ç
µ
ä
º
ã
ã
¾
ã
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
®
æ
é
æ
¥
æ
¬
è
ª
å
¥
å
ã
¯
ã
æ
¬¡
ã
®
æ
é
ã
§
è
¡
ã
ã
¾
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
¢
ã
¼
ã
ã
ã
ª
ã
³
ã
«
å
ã
ã
ã
ã
¦
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
æ
å
­
ã
æ
¥
æ
¬
è
ª
ã
«
å
¤
æ
ã
ã
ã
ã
ã
ã
§
ã
ã
¾
ã
ã
è
ª­
ã
¿
ã
å
¥
å
ã
ã
æ
¹
æ
³
ã
«
ã
¯
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
®
ã
¢
ã
«
ã
ã
¡
ã
ã
ã
ã
ã
å
¥
å
ã
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
®
ã
ã
ª
ã
ã
å
¥
å
ã
ã
ã
ã
ã
ª
å
¥
å
ã
ã
ã
ã
ã
¾
ã
ã
å
¥
å
ã
ã
æ
å
­
ã
¯
å
¥
å
ã
¢
ã
¼
ã
ã
®
è
¨­
å
®
ã
«
å
¿
ã
ã
¦
è
¡¨
ç
¤º
ã
ã
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
å
¼
ã
°
ã
ã
¾
ã
ã
å
¥
å
ã
ã
æ
å
­
ã
ã
æ
¼¢
å
­
ã
»
ã
²
ã
ã
ã
ª
ã
»
ã
«
ã
¿
ã
«
ã
ã
¾
ã
ã
¯
è
±
æ
°
ã
®
æ
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
é
·
ã
æ
ã
ä
¸
å
º¦
ã
«
å
¤
æ
ã
ã
ã
ã
ã
§
ã
ã
å
¤
æ
ã
¢
ã
¼
ã
ã
«
å
¿
ã
ã
¦
é
©
å
ã
ª
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
å
¤
æ
ä
¸­
ã
®
æ
å
­
ã
¯
å
è
»¢
è
¡¨
ç
¤º
ã
ã
ã
ä
½
å
º¦
ã
§
ã
å
¥
ã
®
æ
å
­
ç
¨®
ã
«
å
¤
æ
å
¯
è
½
ã
ª
ã
ã
ã
è
¡¨
ã
ã
¦
ã
ã
¾
ã
ã
å
¤
æ
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
ä
º
ã
§
å
¤
æ
ã
ç
µ
ä
º
ã
ã
¦
ã
æ
¬¡
ã
®
æ
å
­
ã
å
¥
å
ã
§
ã
ã
ç
¶
æ
ã
«
ã
ª
ã
ã
¾
ã
ã
è
ª­
ã
¿
ã
å
¥
å
ã
ã
ã
æ
¥
æ
¬
è
ª
ã
ã
ã
ã
å
è
ª
ã
ä
¾
ã
«
å
¥
å
ã
ã
¾
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
NIHONNGOã
ã
«
ã
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
«
ã
»
ã
ã
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
¾
ã
ã
å
¥
å
æ
å
­
ã
å
¤
æ
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
ã
«
ã
»
ã
ã
ã
ã
ã
ã
æ
å
­
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
[
å
¤
æ
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
æ
å
­
å
ã
æ
¥
æ
¬
è
ª
ã
ã
ç
¢º
å
®
ã
ã
¾
ã
ã
[
Enter
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
ã
ã
®
ã
ã
¿
ã
³
ã
ã
¯
ã
ª
ã
ã
¯
ã
ã
ã
ã
VJEã
ç
µ
ä
º
ã
ã
¾
ã
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
®
æ
é
æ
¥
æ
¬
è
ª
å
¥
å
ã
¯
ã
æ
¬¡
ã
®
æ
é
ã
§
è
¡
ã
ã
¾
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
¢
ã
¼
ã
ã
ã
ª
ã
³
ã
«
å
ã
ã
ã
ã
¦
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
æ
å
­
ã
æ
¥
æ
¬
è
ª
ã
«
å
¤
æ
ã
ã
ã
ã
ã
ã
§
ã
ã
¾
ã
ã
è
ª­
ã
¿
ã
å
¥
å
ã
ã
æ
¹
æ
³
ã
«
ã
¯
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
®
ã
¢
ã
«
ã
ã
¡
ã
ã
ã
ã
ã
å
¥
å
ã
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
®
ã
ã
ª
ã
ã
å
¥
å
ã
ã
ã
ã
ã
ª
å
¥
å
ã
ã
ã
ã
ã
¾
ã
ã
å
¥
å
ã
ã
æ
å
­
ã
¯
å
¥
å
ã
¢
ã
¼
ã
ã
®
è
¨­
å
®
ã
«
å
¿
ã
ã
¦
è
¡¨
ç
¤º
ã
ã
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
å
¼
ã
°
ã
ã
¾
ã
ã
å
¥
å
ã
ã
æ
å
­
ã
ã
æ
¼¢
å
­
ã
»
ã
²
ã
ã
ã
ª
ã
»
ã
«
ã
¿
ã
«
ã
ã
¾
ã
ã
¯
è
±
æ
°
ã
®
æ
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
é
·
ã
æ
ã
ä
¸
å
º¦
ã
«
å
¤
æ
ã
ã
ã
ã
ã
§
ã
ã
å
¤
æ
ã
¢
ã
¼
ã
ã
«
å
¿
ã
ã
¦
é
©
å
ã
ª
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
å
¤
æ
ä
¸­
ã
®
æ
å
­
ã
¯
å
è
»¢
è
¡¨
ç
¤º
ã
ã
ã
ä
½
å
º¦
ã
§
ã
å
¥
ã
®
æ
å
­
ç
¨®
ã
«
å
¤
æ
å
¯
è
½
ã
ª
ã
ã
ã
è
¡¨
ã
ã
¦
ã
ã
¾
ã
ã
å
¤
æ
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
ä
º
ã
§
å
¤
æ
ã
ç
µ
ä
º
ã
ã
¦
ã
æ
¬¡
ã
®
æ
å
­
ã
å
¥
å
ã
§
ã
ã
ç
¶
æ
ã
«
ã
ª
ã
ã
¾
ã
ã
è
ª­
ã
¿
ã
å
¥
å
ã
ã
ã
æ
¥
æ
¬
è
ª
ã
ã
ã
ã
å
è
ª
ã
ä
¾
ã
«
å
¥
å
ã
ã
¾
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
NIHONNGOã
ã
«
ã
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
«
ã
»
ã
ã
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
¾
ã
ã
å
¥
å
æ
å
­
ã
å
¤
æ
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
ã
«
ã
»
ã
ã
ã
ã
ã
ã
æ
å
­
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
[
å
¤
æ
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
æ
å
­
å
ã
æ
¥
æ
¬
è
ª
ã
ã
ç
¢º
å
®
ã
ã
¾
ã
ã
[
Enter
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
¯
ã
æ
¬¡
ã
®
æ
é
ã
§
è
¡
ã
ã
¾
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
¢
ã
¼
ã
ã
ã
ª
ã
³
ã
«
å
ã
ã
ã
ã
¦
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
æ
å
­
ã
æ
¥
æ
¬
è
ª
ã
«
å
¤
æ
ã
ã
ã
ã
ã
ã
§
ã
ã
¾
ã
ã
è
ª­
ã
¿
ã
å
¥
å
ã
ã
æ
¹
æ
³
ã
«
ã
¯
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
®
ã
¢
ã
«
ã
ã
¡
ã
ã
ã
ã
ã
å
¥
å
ã
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
®
ã
ã
ª
ã
ã
å
¥
å
ã
ã
ã
ã
ã
ª
å
¥
å
ã
ã
ã
ã
ã
¾
ã
ã
å
¥
å
ã
ã
æ
å
­
ã
¯
å
¥
å
ã
¢
ã
¼
ã
ã
®
è
¨­
å
®
ã
«
å
¿
ã
ã
¦
è
¡¨
ç
¤º
ã
ã
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
å
¼
ã
°
ã
ã
¾
ã
ã
å
¥
å
ã
ã
æ
å
­
ã
ã
æ
¼¢
å
­
ã
»
ã
²
ã
ã
ã
ª
ã
»
ã
«
ã
¿
ã
«
ã
ã
¾
ã
ã
¯
è
±
æ
°
ã
®
æ
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
é
·
ã
æ
ã
ä
¸
å
º¦
ã
«
å
¤
æ
ã
ã
ã
ã
ã
§
ã
ã
å
¤
æ
ã
¢
ã
¼
ã
ã
«
å
¿
ã
ã
¦
é
©
å
ã
ª
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
å
¤
æ
ä
¸­
ã
®
æ
å
­
ã
¯
å
è
»¢
è
¡¨
ç
¤º
ã
ã
ã
ä
½
å
º¦
ã
§
ã
å
¥
ã
®
æ
å
­
ç
¨®
ã
«
å
¤
æ
å
¯
è
½
ã
ª
ã
ã
ã
è
¡¨
ã
ã
¦
ã
ã
¾
ã
ã
å
¤
æ
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
ä
º
ã
§
å
¤
æ
ã
ç
µ
ä
º
ã
ã
¦
ã
æ
¬¡
ã
®
æ
å
­
ã
å
¥
å
ã
§
ã
ã
ç
¶
æ
ã
«
ã
ª
ã
ã
¾
ã
ã
è
ª­
ã
¿
ã
å
¥
å
ã
ã
ã
æ
¥
æ
¬
è
ª
ã
ã
ã
ã
å
è
ª
ã
ä
¾
ã
«
å
¥
å
ã
ã
¾
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
NIHONNGOã
ã
«
ã
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
«
ã
»
ã
ã
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
¾
ã
ã
å
¥
å
æ
å
­
ã
å
¤
æ
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
ã
«
ã
»
ã
ã
ã
ã
ã
ã
æ
å
­
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
[
å
¤
æ
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
æ
å
­
å
ã
æ
¥
æ
¬
è
ª
ã
ã
ç
¢º
å
®
ã
ã
¾
ã
ã
[
Enter
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
æ
¥
æ
¬
è
ª
å
¥
å
ã
¢
ã
¼
ã
ã
ã
ª
ã
³
ã
«
å
ã
ã
ã
ã
¦
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
æ
å
­
ã
æ
¥
æ
¬
è
ª
ã
«
å
¤
æ
ã
ã
ã
ã
ã
ã
§
ã
ã
¾
ã
ã
è
ª­
ã
¿
ã
å
¥
å
ã
ã
æ
¹
æ
³
ã
«
ã
¯
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
®
ã
¢
ã
«
ã
ã
¡
ã
ã
ã
ã
ã
å
¥
å
ã
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
®
ã
ã
ª
ã
ã
å
¥
å
ã
ã
ã
ã
ã
ª
å
¥
å
ã
ã
ã
ã
ã
¾
ã
ã
å
¥
å
ã
ã
æ
å
­
ã
¯
å
¥
å
ã
¢
ã
¼
ã
ã
®
è
¨­
å
®
ã
«
å
¿
ã
ã
¦
è
¡¨
ç
¤º
ã
ã
ã
æ
ª
ç
¢º
å
®
æ
å
­
å
ã
å
¼
ã
°
ã
ã
¾
ã
ã
å
¥
å
ã
ã
æ
å
­
ã
ã
æ
¼¢
å
­
ã
»
ã
²
ã
ã
ã
ª
ã
»
ã
«
ã
¿
ã
«
ã
ã
¾
ã
ã
¯
è
±
æ
°
ã
®
æ
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
é
·
ã
æ
ã
ä
¸
å
º¦
ã
«
å
¤
æ
ã
ã
ã
ã
ã
§
ã
ã
å
¤
æ
ã
¢
ã
¼
ã
ã
«
å
¿
ã
ã
¦
é
©
å
ã
ª
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
å
¤
æ
ä
¸­
ã
®
æ
å
­
ã
¯
å
è
»¢
è
¡¨
ç
¤º
ã
ã
ã
ä
½
å
º¦
ã
§
ã
å
¥
ã
®
æ
å
­
ç
¨®
ã
«
å
¤
æ
å
¯
è
½
ã
ª
ã
ã
ã
è
¡¨
ã
ã
¦
ã
ã
¾
ã
ã
å
¤
æ
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
ä
º
ã
§
å
¤
æ
ã
ç
µ
ä
º
ã
ã
¦
ã
æ
¬¡
ã
®
æ
å
­
ã
å
¥
å
ã
§
ã
ã
ç
¶
æ
ã
«
ã
ª
ã
ã
¾
ã
ã
è
ª­
ã
¿
ã
å
¥
å
ã
ã
ã
æ
¥
æ
¬
è
ª
ã
ã
ã
ã
å
è
ª
ã
ä
¾
ã
«
å
¥
å
ã
ã
¾
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
NIHONNGOã
ã
«
ã
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
«
ã
»
ã
ã
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
¾
ã
ã
å
¥
å
æ
å
­
ã
å
¤
æ
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
ã
«
ã
»
ã
ã
ã
ã
ã
ã
æ
å
­
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
[
å
¤
æ
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
æ
å
­
å
ã
æ
¥
æ
¬
è
ª
ã
ã
ç
¢º
å
®
ã
ã
¾
ã
ã
[
Enter
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
ã
æ
¥
æ
¬
è
ª
ã
ã
ã
ã
å
è
ª
ã
ä
¾
ã
«
å
¥
å
ã
ã
¾
ã
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
NIHONNGOã
ã
«
ã
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
«
ã
»
ã
ã
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
¾
ã
ã
å
¥
å
æ
å
­
ã
å
¤
æ
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
ã
«
ã
»
ã
ã
ã
ã
ã
ã
æ
å
­
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
[
å
¤
æ
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
æ
å
­
å
ã
æ
¥
æ
¬
è
ª
ã
ã
ç
¢º
å
®
ã
ã
¾
ã
ã
[
Enter
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
ã
­
ã
¼
ã
å
­
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
NIHONNGOã
ã
«
ã
å
¥
å
ã
®
ã
ã
ã
¯
ã
ã
«
ã
»
ã
ã
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
¾
ã
ã
å
¥
å
æ
å
­
ã
å
¤
æ
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
ã
«
ã
»
ã
ã
ã
ã
ã
ã
æ
å
­
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
[
å
¤
æ
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
æ
å
­
å
ã
æ
¥
æ
¬
è
ª
ã
ã
ç
¢º
å
®
ã
ã
¾
ã
ã
[
Enter
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
å
¥
å
æ
å
­
ã
å
¤
æ
ã
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
ã
«
ã
»
ã
ã
ã
ã
ã
ã
æ
å
­
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
[
å
¤
æ
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
æ
å
­
å
ã
æ
¥
æ
¬
è
ª
ã
ã
ç
¢º
å
®
ã
ã
¾
ã
ã
[
Enter
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
ã
­
ã
¼
ã
ã
¼
ã
ã
ã
å
¥
å
ã
ã
ã
ã
«
ã
»
ã
ã
ã
ã
ã
ã
æ
å
­
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
¾
ã
ã
[
å
¤
æ
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
æ
å
­
å
ã
æ
¥
æ
¬
è
ª
ã
ã
ç
¢º
å
®
ã
ã
¾
ã
ã
[
Enter
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
[
å
¤
æ
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
æ
å
­
å
ã
æ
¥
æ
¬
è
ª
ã
ã
ç
¢º
å
®
ã
ã
¾
ã
ã
[
Enter
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
æ
å
­
ã
ç
¢º
å
®
ã
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
æ
å
­
å
ã
æ
¥
æ
¬
è
ª
ã
ã
ç
¢º
å
®
ã
ã
¾
ã
ã
[
Enter
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
æ
¼¢
å
­
ã
«
å
¤
æ
ã
ã
æ
å
­
å
ã
æ
¥
æ
¬
è
ª
ã
ã
ç
¢º
å
®
ã
ã
¾
ã
ã
[
Enter
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
[
Enter
]
ã
­
ã
¼
ã
æ
¼
ã
ã
¾
ã
Copyright
@
2017
QNX
Software
Systems
Limited
a
subsidiary
of
BlackBerry
.
æ
¥
æ
¬
è
ª
ã
ã
¼
ã
«
ã
»
ã
ã
¼
ã
å
¥
å
ã
®
æ
é**************************************最近
話題
Web
言語
Elixir
紹介
執筆
者
プロフィール
記事
メタデータ
関連
記事
その他
カテゴリー
その他
メニュー
検索
RSS
シェア
Elixir
注目
理由
インストール
手順
シンタックス
特徴
まとめ
かん
ひで
設定
カテゴリー
開催
予定
イベント
7
/
1
(
土
)
開催
Developers
.
IO
2017
登録
受付
中
2
回
Alteryx
User
Group
in
東京
2017
/
07
/
03
(
月
)
開催
#
alteryx
_
ug
7
/
4
火
クラス
メソッド
会社
説明
会
開催
満員
御礼
入門
セミナー
シリーズ
二
回
AWS
GitHub
DevOps
ハンズオン
in
東京
7
/
19
(
水
)
大阪
基幹
システム
AWS
事例
可用性
システム
AWS
移行
開催
カテゴリー
一覧
タグ
一覧
カテゴリー
選択
パイプライン
演算
子
パターン
マッチ
無限
ストリーム
リスト
内包
表記
最初
サンプル
説明
サンプル
コード
結果
記事
公開
1
年
以上
経過
情報
可能
性
注意
ここ
最近
Elixir
言語
Web
プログラマー
界隈
話題
Elixir
Erlang
VM
上
Ruby
風味
関数
型
言語
Rails
コミッタ
Jose
Valim
さん
プログラミング
言語
言語
Erlang
並行
性
Ruby
開発
生産
性
今回
言語
背景
文法
特徴
ここ
数
年
Web
アプリケーション
以下
問題
これら
解決
ため
従来
マルチスレッド
イベント
駆動
スタイル
開発
の
どちら
様々
問題
実装
上
問題
プログラマ
並行
処理
性能
モダン
シンタックス
ライブラリ
プログラミング
言語
開発
要望
プログラマー
間
それ
Elixir
誕生
背景
Mac
環境
説明
Homebrew
簡単
インストール
ruby
irb
よう
REPL
iex
コマンド
雰囲気
ため
サンプル
コード
詳細
後
説明
今
理解
大丈夫
たより
Ruby
サンプル
コード
こと
主
特徴
シンプル
コード
説明
Elixir
一番
特徴
パイプライン
演算
子
|&
gt
;
関数
関数
返却
値
次
関数
一
引数
動き
Elixir
実装
とき
関数
作成
パイプライン
演算
子
関数
こと
処理
実装
Haskell
関数
型
言語
馴染み
パターン
マッチ
Elixir
いろいろ
ところ
簡単
例
右辺
Map
キー
値
:
name
左辺
Map
キー
値
:
name
一致
場合
変数
company
"
classmethod
"
文字
列
束縛
(
Elixir
Map
%{:
key
=&
gt
;
value
}
形式
記述
パターン
マッチ
サンプル
一つ
次
再帰
リスト
要素
数
カウント
サンプル
size
関数
実行
よう
変数
値
束縛
1
加算
tail
引数
指定
size
関数
再帰
呼び出し
最後
引数
リスト
空
処理
終了
終了
条件
リスト
空
場合
とき
処理
記述
フィボナッチ
数列
無限
ストリーム
例
処理
遅延
評価
Enum
.
take
(
10
)
計算
実行
ファイル
ストリーム
例
Enum
.
max
_
by
(&
amp
;
String
.
length
/
1
)
ファイル
読み込み
処理
実行
数学
集合
内包
的
記法
よう
もの
リスト
フィルタ
リング
変換
もの
今回
サンプル
リスト
内包
表記
Haskell
Elixir
次
よう
ここ
Elixir
関数
型
言語
機能
説明
これ
最初
サンプル
コード
内容
理解
アプリケーション
エントリ
ポイント
関数
fetch
_
entry
コード
次
順
処理
実行
実行
結果
パイプライン
演算
子
次
関数
一
引数
decode
_
response
説明
関数
の
API
呼び出し
結果
Map
型
データ
(
前
処理
パイプライン
演算
子
こと
実現
)。
データ
パターン
マッチ
status
_
code
値
200
場合
処理
デコード
API
呼び出し
結果
データ
以下
量
一部
記載
status
_
code
キー
最後
行
decode
_
response
関数
status
_
code
値
body
要素
関数
実行
こと
よう
デコード
JSON
配列
extract
_
entry
関数
説明
名前
関数
def
defp
宣言
の
気
defp
Elixir
プライベート
関数
宣言
とき
記法
以下
記述
配列
先頭
要素
追加
意味
2
要素
追加
場合
ブック
マーク
API
サンプル
コード
場合
処理
res
配列
抽出
情報
追加
Elixir
関係
の
サンプル
コード
結果
AWS
モバイル
開発
認識
会社
結果
簡単
サンプル
Elixir
シンタックス
特徴
ここ
私
個人
感想
次
よう
今回
分散
プログラミング
エラー
処理
あたり
次回
予定
クラス
メソッド
株式会社
RANK
15
Exp
.
158
657
技術
筆者
仕事
依頼
時
クラス
メソッド
株式会社
問い合わせ
今年
Developers
.
IO
2017
技術
者
夏
祭り
東京
麹
町
丸
一
日
開催
マニアック
セッション
基調
講演
テーマ
AWS
他
OAuth
サーバ
レス
VUI
未来
技術
一緒
勉強
00
00
00
00
DAYS
HOURS
MINUTES
SECONDS
申し込み
こちら
Alteryx
User
Group
2
回
Inspire
2017
参加
報告
会
2017
年
06
月
05
日
2017
[…]
7
月
4
日
会社
説明
会
こと
面接
気
人
話
方
是非
可能
限り
質問
お答え
AWS
活用
ビジネス
かた
GitHub
業務
PM
PL
開発
者
かた
必聴
開発
環境
DevOps
大阪
6
/
9
開催
予定
参加
費
無料
大阪
開催
ビジネス
セミナー
Amazon
Web
Services
(
以下
AWS
)
上
基幹
系
システム
移行
企業
年々
増加
セキュリティ
可用性
向上
課題
一つ
セミナー
800
以上
プロジェクト
AWS
導入
実績
クラス
メソッド
可用性
クラスターソフトウェア・ベンダー
サイオステクノロジー
ミッション
クリティカル
基幹
業務
AWS
上
導入
移行
成功
ポイント
導入
IDOM
様
事例
中心
説明
©
Classmethod
Inc
.
All
rights
reserved
.
Developers
.
IO
クラス
メソッド
株式会社
運営
AWS
iOS
HTML
5
技術
情報
サイト
最近
話題
Web
言語
Elixir
紹介
Developers
.
IO**************************************ã
ã
¼
ã
·
ã
ã
¯
ã
±
ã
¢
ã
¹
ã
ã
·
ã
ã
«
ã
±
ã
¢
ã
ã
¼
ã
¹
ã
¡
ã
¼
ã
¯
è
©³
ã
ã
è
¦
ã
å
ç
²§
æ
°´
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
æ
¹§
ã
ä
¸
ã
ã
ã
ã
ã
ª
ã
ã
ª
ã
ã
ã
ã
ã
ã
§
æ
º
ã
ã
ã
è
¬
ç
å
ç
²§
æ
°´
å
ç
²§
æ
°´
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
ã
ã
ã
ã
ã
ã
ã
ª
ã
§
æ
º
ã
ã
ã
æ
ã
ã
é
¡
å
°
è
±¡
ã
¸
å
°
ã
ã
è
¬
ç
ç
¾
ç
½
å
ç
²§
æ
°´
å
ç
²§
æ
°´
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
³
ã
ª
ã
ã
ã
æ
¿
å
¯
ã
ª
ã
ã
ã
ã
ã
§
ä
¸
è
³ª
ã
ª
ã
ã
ª
æ
ã
ã
ã
ã
ã
æ
¿
å
¯
å
ç
²§
æ
°´
ä
¹³
æ
¶²
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
æ
¹§
ã
ä
¸
ã
ã
ã
ã
ã
ª
ã
ã
ª
ã
ã
ã
ã
ã
ã
ä
¿
ã
¤
ã
è
¬
ç
ä
¹³
æ
¶²
ä
¹³
æ
¶²
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
ã
ã
ã
ã
ã
ã
ã
ª
ã
§
æ
º
ã
ã
ã
æ
ã
ã
é
¡
å
°
è
±¡
ã
ä
¿
ã
¤
ã
è
¬
ç
ç
¾
ç
½
ä
¹³
æ
¶²
ä
¹³
æ
¶²
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
³
ã
ª
ã
ã
ã
æ
¿
å
¯
ã
ª
ã
ã
ã
ã
ã
§
ä
¸
è
³ª
ã
ª
ã
ã
ª
æ
ã
è
²
ã
¿
ä
¿
ã
¤
æ
¿
å
¯
ä
¹³
æ
¶²
ç
¾
å
®¹
ä
¹³
æ
¶²
ï
¼
æ
¥
ä
¸­
ç
ï
¼
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ç
´«
å
¤
ç
·
ã
ª
ã
©
ã
ã
å
®
ã
ã
å
¤
æ
¹
ã
¾
ã
§
ã
ã
ª
ã
ç
¶
ã
ã
æ
ã
®
ä
¹³
æ
¶²
ç
¾
å
®¹
ä
¹³
æ
¶²
ï
¼
æ
¥
ä
¸­
ç
ï
¼
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ç
´«
å
¤
ç
·
ã
ª
ã
©
ã
ã
å
®
ã
ã
å
¤
æ
¹
ã
¾
ã
§
ã
ã
ª
ã
ç
¶
ã
ã
æ
ã
®
ä
¹³
æ
¶²
ç
¾
å
®¹
ä
¹³
æ
¶²
ï
¼
æ
¥
ä
¸­
ç
ï
¼
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
æ
ª
å
½±
é
¿
ã
ã
å
®
ã
ã
ª
ã
ã
ã
æ
ã
ã
ã
ã
ã
ª
ã
ã
­
ã
¼
ã
ã
ã
ã
æ
ã
®
ç
¾
ç
½
ä
¹³
æ
¶²
ç
¾
å
®¹
ä
¹³
æ
¶²
ï
¼
æ
¥
ä
¸­
ç
ï
¼
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
æ
ª
å
½±
é
¿
ã
ã
å
®
ã
ã
ª
ã
ã
ã
æ
ã
ã
ã
ã
ã
ª
ã
ã
­
ã
¼
ã
ã
ã
ã
æ
ã
®
ç
¾
ç
½
ä
¹³
æ
¶²
ç
¾
å
®¹
ä
¹³
æ
¶²
ï
¼
æ
¥
ä
¸­
ç
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
³
ã
ª
ã
ã
ã
ç
¬
æ
ã
«
è
è
²
ã
ç
¾
ã
ã
è
¦
ã
ã
æ
¥
ä
¸­
ã
®
ç
¾
è
ã
å
®
ã
æ
¿
å
¯
ã
ã
­
ã
ã
¯
ã
¿
ã
¼
ã
¡
ã
¼
ã
¯
è
½
ã
ã
ï
¼
ã
¯
ã
¬
ã
³
ã
¸
ã
³
ã
°
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
å
¯
ç
ã
¡
ã
¼
ã
¯
ã
æ
º¶
ã
ã
ã
¦
è
½
ã
ã
ã
ã
ª
ã
¤
ã
«
ã
¿
ã
¤
ã
ã
®
ã
¡
ã
¼
ã
¯
è
½
ã
ã
ã
¡
ã
¼
ã
¯
è
½
ã
ã
ï
¼
ã
¯
ã
¬
ã
³
ã
¸
ã
³
ã
°
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
å
¸
ç
ã
ã
¦
ã
ã
ã
ã
ã
ã
ã
¸
ã
§
ã
«
ã
¿
ã
¤
ã
ã
®
ã
¡
ã
¼
ã
¯
è
½
ã
ã
ã
¡
ã
¼
ã
¯
è
½
ã
ã
ï
¼
ã
¯
ã
¬
ã
³
ã
¸
ã
³
ã
°
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ã
ã
ã
ã
å
ã
¿
è
¾¼
ã
ã
§
è
½
ã
ã
ã
ã
¯
ã
ª
ã
¼
ã
ã
¿
ã
¤
ã
ã
®
ã
¡
ã
¼
ã
¯
è
½
ã
ã
ã
¡
ã
¼
ã
¯
è
½
ã
ã
ï
¼
ã
¯
ã
¬
ã
³
ã
¸
ã
³
ã
°
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ã
µ
ã
ã
ã
µ
ã
ã
ã
ã
¦
è
½
ã
ã
ã
ã
­
ã
¼
ã
·
ã
§
ã
³
ã
¿
ã
¤
ã
ã
®
ã
¡
ã
¼
ã
¯
è
½
ã
ã
ã
¡
ã
¼
ã
¯
è
½
ã
ã
ï
¼
ã
¯
ã
¬
ã
³
ã
¸
ã
³
ã
°
ï
¼
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
è
ã
®
ã
«
ã
ã
è
¦
å
ã
ã
¯
ã
ª
ã
¢
ã
ã
ª
ã
¤
ã
«
ã
¿
ã
¤
ã
ã
®
è
¬
ç
ã
¡
ã
¼
ã
¯
è
½
ã
ã
ã
¡
ã
¼
ã
¯
è
½
ã
ã
ï
¼
ã
¯
ã
¬
ã
³
ã
¸
ã
³
ã
°
ï
¼
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
ã
«
ã
ã
ã
®
ã
ª
ã
ç
è
ã
¸
ã
ã
¸
ã
§
ã
«
ã
¯
ã
ª
ã
¼
ã
ã
¿
ã
¤
ã
ã
®
è
¬
ç
ã
¡
ã
¼
ã
¯
è
½
ã
ã
æ
é
¡
æ
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ã
²
ã
æ
¼
ã
ã
§
å
¼¾
å
æ
³¡
ã
ã
ã
·
ã
ã
æ
³¡
ç
«
ã
¦
ã
ã
³
ã
ã
¿
ã
¤
ã
ã
®
æ
é
¡
ã
ã
¼
ã
¹
æ
é
¡
æ
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
å
¼¾
å
æ
³¡
ã
§
ã
µ
ã
ã
ã
ã
ã
ã
ã
ã
ª
è
ã
«
æ
ã
ã
ã
ã
æ
é
¡
ã
ã
©
ã
¼
ã
æ
é
¡
æ
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
è
ã
®
ã
«
ã
ã
è
¦
å
ã
é
¤
å
»
ã
ã
ã
ã
ã
ã
¯
ã
ª
ã
¢
ã
«
å
°
ã
è
¬
ç
æ
é
¡
ã
ã
©
ã
¼
ã
æ
é
¡
æ
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
è
ã
®
ã
«
ã
ã
è
¦
å
ã
é
¤
å
»
ã
ã
ã
ã
ã
ã
¯
ã
ª
ã
¢
ã
«
å
°
ã
è
¬
ç
æ
é
¡
ç
³
ã
ã
æ
é
¡
æ
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
³
ã
ª
ã
ã
ã
ã
·
ã
«
ã
­
ã
¼
ã
ª
æ
¿
å
¯
æ
³¡
ã
§
è
æ
²¢
ã
«
æ
ã
æ
¿
å
¯
æ
é
¡
ã
ã
«
ã
¯
ç
¾
å
®¹
æ
¶²
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
å
ç
¸®
ã
®
ä
¸
æ
»´
ã
§
ã
ä
¸
å
ã
ã
®
ã
ã
ª
ã
ç
¾
å
®¹
æ
¿
å
¯
æ
¶²
ç
¾
å
®¹
æ
¶²
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ç
®
ã
ã
å
ã
ã
ã
®
è
ã
«
ã
ã
ã
ª
ã
ä
¸
ã
ã
è
¬
ç
é
å
ç
ç
¾
å
®¹
æ
¶²
ç
¾
å
®¹
æ
¶²
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
æ
¯
ç
©´
ã
®
æ
°
ã
«
ã
ª
ã
ã
»
ã
ã
«
ã
ã
ª
æ
ã
ä
¸
ã
ã
ã
è
¬
ç
ç
¾
å
®¹
æ
¶²
ã
¯
ã
ª
ã
¼
ã
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
è
²©
å
£²
å
ï
¼
è
³
ç
å
ã
¬
ã
ã
ã
ã
¤
ã
¿
ã
«
ã
¯
ã
ª
ã
¼
ã
V
è
¬
ç
æ
å
¹
æ
å
ç
ç
²
ã
¬
ã
ã
ã
¼
ã
«
é
å
ã
ç
¾
å
®¹
æ
¿
å
¯
ã
ª
ã
³
ã
¯
ã
«
ã
¯
ã
ª
ã
¼
ã
ã
¯
ã
ª
ã
¼
ã
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
è
±
ã
ã
«
ã
ã
ã
ã
ã
ã
ã
ª
ã
ã
ã
ã
¼
ã
¸
ã
ã
ã
¯
ã
ª
ã
¼
ã
ã
¯
ã
ª
ã
¼
ã
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
è
ã
ç
ã
¾
ã
å
¤
ã
ã
å
¤
ã
«
ã
ç
¾
å
®¹
æ
¿
å
¯
ã
¯
ã
ª
ã
¼
ã
ã
¯
ã
ª
ã
¼
ã
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
ç
´«
å
¤
ç
·
ã
«
ã
ã
è
è
²
å
°
è
±¡
ã
®
å
¤
å
ã
é
²
ã
ã
è
¬
ç
ç
¾
ç
½
ã
¸
ã
§
ã
«
ã
¯
ã
ª
ã
¼
ã
ã
¯
ã
ª
ã
¼
ã
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
³
ã
ª
ã
ã
ã
æ
º
ã
¡
ã
ã
ã
ã
ã
ã
§
ç
®
ã
ã
ã
«
ã
ã
ª
ã
æ
¿
å
¯
ã
¢
ã
¤
ã
¯
ã
ª
ã
¼
ã
ã
ã
ã
µ
ã
¼
ã
¸
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
å
¼
ã
ã
ã
¾
ã
ã
ã
ã
ª
è
ã
¸
å
°
ã
ã
ã
ã
ã
µ
ã
¼
ã
¸
ã
¯
ã
ª
ã
¼
ã
ã
ã
ã
µ
ã
¼
ã
¸
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
ç
¾
ç
½
æ
å
ã
ã
ã
ã
ã
è
ã
¸
ã
è
¬
ç
ã
ã
ã
µ
ã
¼
ã
¸
ã
¯
ã
ª
ã
¼
ã
å
ã
ã
å
ç
²§
æ
°´
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
å
¼
ã
ã
ã
ã
¦
ã
ã
ã
ã
ã
ç
¶
ã
ã
å
ã
ã
å
ç
²§
æ
°´
å
ã
ã
å
ç
²§
æ
°´
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
æ
¯
ç
©´
ã
å
¼
ã
ã
ã
ã
¦
ã
¯
ã
ª
ã
¢
ã
ª
è
ã
¸
ã
è
¬
ç
ç
¾
ç
½
å
ã
ã
å
ç
²§
æ
°´
ã
ã
ã
¯
ã
»
ã
ã
¹
ã
¯
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ã
·
ã
ã
·
ã
ã
¸
ã
§
ã
«
ã
«
ç
¾
å
®¹
æ
å
ã
ã
ã
·
ã
ã
®
å
¡
ã
ã
¦
å
¯
ã
ã
ã
ã
¯
ã
ã
ã
¯
ã
»
ã
ã
¹
ã
¯
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
è
²©
å
£²
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
ã
¯
ã
ª
ã
¢
ã
¸
ã
§
ã
«
C
ç
¾
ç
½
æ
å
¹
æ
å
é
å
ã
å
¡
ã
ã
¦
å
¯
ã
ç
¾
ç
½
ã
¸
ã
§
ã
«
ã
ã
ã
¯
ã
»
ã
ã
¹
ã
¯
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
è
ã
ã
²
ã
ã
ã
¦
ã
ã
ã
¡
ã
ã
·
ã
¼
ã
ç
¶
ç
¾
å
®¹
æ
¶²
ã
ã
¹
ã
¯
ã
ã
ã
¯
ã
»
ã
ã
¹
ã
¯
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
æ
·±
ã
æ
°
ã
«
ã
ª
ã
ç
®
ã
ã
ã
é
ä
¸­
ã
±
ã
¢
ã
ã
ã
è
¬
ç
ã
·
ã
¼
ã
ç
¶
ã
¢
ã
¤
ã
ã
¹
ã
¯
ã
ã
ã
¯
ã
»
ã
ã
¹
ã
¯
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
2
ã
¹
ã
ã
ã
ã
§
é
ä
¸­
ã
±
ã
¢
ã
è
¬
ç
ç
¾
å
®¹
æ
¶²
ã
è
¬
ç
ç
¾
ç
½
ã
ã
¹
ã
¯
ã
ã
¡
ã
³
ã
ã
¼
ã
·
ã
§
ã
³
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ã
ã
ã
¿
ã
»
è
²
ã
ã
©
ã
»
æ
¯
ç
©´
ã
®
å
½±
ã
ã
²
ã
å
¡
ã
ã
§
æ
ã
ã
å
¤
ã
ã
ã
ã
¦
ã
ã
ª
ã
¼
ã
ã
¡
ã
³
ã
ã
¼
ã
·
ã
§
ã
³
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ã
²
ã
ã
¬
ã
ã
§
é
«
ã
é
æ
å
º¦
ã
ã
ã
ç
´°
ã
ã
ç
¾
ç
½
ç
è
ã
®
ã
ã
ã
«
ä
»
ä
¸
ã
ã
ã
ã
¡
ã
³
ã
ã
¼
ã
·
ã
§
ã
³
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
å
°
ã
ã
ã
æ
¯
ç
©´
ã
ª
ã
©
ã
®
æ
©
ã
¿
ã
ã
«
ã
ã
¼
ã
ã
ã
ã
ª
æ
ã
ç
¶
ã
ã
ã
ã
«
ã
¸
ã
§
ã
³
ã
ã
¡
ã
³
ã
ã
¼
ã
·
ã
§
ã
³
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ã
²
ã
ã
¬
ã
ã
§
é
«
ã
é
æ
å
º¦
ã
ã
¿
ã
ã
¿
ã
ã
ã
ç
¾
ç
½
ç
è
ã
®
ã
ã
ã
«
ä
»
ä
¸
ã
ã
å
ç
²§
ä
¸
å
°
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ã
ã
ã
¿
ã
»
ã
·
ã
ã
»
è
²
ã
ã
ã
ã
«
ã
ã
¼
ã
ã
¦
ã
æ
ã
ã
è
è
²
ã
«
æ
ã
ã
å
ç
²§
ä
¸
å
°
å
ç
²§
ä
¸
å
°
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ã
­
ã
¡
ã
æ
¯
ç
©´
ã
è
²
ã
ã
©
ã
ç
¬
æ
ã
«
è
æ
­£
ã
ç
¾
è
ã
ã
­
ã
¼
ã
ã
ã
å
ç
²§
ä
¸
å
°
ã
ã
ã
ã
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ã
ã
ã
¿
ã
å
¹
å
¸
ã
æ
¶
ã
ã
ã
¤
ã
ã
é
æ
æ
ã
æ
¼
å
º
ã
ã
ã
«
ã
¼
ã
¹
ã
ã
¦
ã
ã
¼
ã
ã
ã
ã
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
å
ç
²§
ç
ã
ã
«
ã
ã
ã
ã
§
ã
µ
ã
ã
ã
ä
¸
è
³ª
ã
ª
è
ã
ã
¤
ã
ã
ã
ã
¬
ã
¹
ã
ã
ã
¦
ã
ã
¼
â
»
ç
¾
ç
½
ã
ã
¯
ã
ã
¡
ã
©
ã
ã
³
ã
®
ç
æ
ã
æ
ã
ã
ã
·
ã
ã
»
ã
½
ã
ã
«
ã
¹
ã
é
²
ã
ã
ã
ã
§
ã
ã
å
å
æ
å
±
ï
½
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ï
¼
ELIXIRï
¼
ï
½
è
³
ç
å**************************************Platform
features
-
ã
ã
©
ã
ã
ã
ã
©
ã
¼
ã
ã
®
ç
¹
å
¾´
Language
features
-
è
è
ª
ã
®
ç
¹
å
¾´
Tooling
features
-
ã
ã
¼
ã
«
ã
®
ç
¹
å
¾´
News
:
Elixir
v
1
.
0
.
0
released
Join
the
Community
Important
links
Learning
resources
Code
editor
support
Sponsors
Elixir
ã
¯
ã
¹
ã
±
ã
¼
ã
«
ã
ã
ã
ã
ã
¡
ã
³
ã
ã
ã
³
ã
¹
ã
ã
ã
ã
ã
¢
ã
ã
ª
ã
±
ã
¼
ã
·
ã
§
ã
³
ã
ä
½
ã
ã
ã
ã
®
å
ç
ã
ª
é
¢
æ
°
å
è
è
ª
ã
§
ã
ã
Elixir
is
a
dynamic
functional
language
designed
for
building
scalable
and
maintainable
applications
.
Elixir
ã
¯
Erlang
VM
ã
æ
´»
ç
ã
ã
¦
ã
ã
¾
ã
ï
¼
Erlang
VM
ã
¯
ä
½
ã
¬
ã
¤
ã
ã
³
ã
·
ã
§
ï
¼
å
æ
å
ã
ã
¤
è
é
å
®³
æ
§
ã
®
ã
ã
ã
·
ã
¹
ã
ã
ã
ã
ã
¦
ç
¥
ã
ã
ã
¦
ã
ã
ï
¼
Web
é
ç
º
ã
ç
µ
ã
¿
è
¾¼
ã
¿
ã
½
ã
ã
ã
¦
ã
§
ã
¢
ã
®
é
å
ã
§
ä
½¿
ã
ã
ã
¦
æ
å
ã
ã
¦
ã
ã
¾
ã
ã
Elixir
leverages
the
Erlang
VM
known
for
running
low
-
latency
distributed
and
fault
-
tolerant
systems
while
also
being
successfully
used
in
web
development
and
the
embedded
software
domain
.
ã
ã
ã
Elixir
ã
®
ã
ã
ã
ç
¥
ã
ã
«
ã
¯
ï
¼
getting
started
guide
ã
å
ç
§
ã
ã
¦
ã
ã
ã
ã
ã
ã
ã
®
ã
¾
ã
¾
è
ª­
ã
¿
é
²
ã
ã
ã
ã
ã
©
ã
ã
ã
ã
©
ã
¼
ã
ã
è
è
ª
ï
¼
ã
ã
¼
ã
«
ã
«
ã
¤
ã
ã
¦
ã
®
æ
¦
è
¦
ã
æ
æ
¡
ã
§
ã
ã
¾
ã
ã
To
learn
more
about
Elixir
check
our
getting
started
guide
.
Or
keep
reading
to
get
an
overview
of
the
platform
language
and
tools
.
å
ã
¦
ã
®
Elixir
ã
³
ã
¼
ã
ã
¯
å
®
è
¡
ã
®
ã
ã
ã
®
è
»½
é
ã
¹
ã
¬
ã
ã
(
ã
ã
­
ã
»
ã
¹
ã
å
¼
ã
°
ã
ã
¦
ã
ã
¾
ã
)
ã
®
ä
¸­
ã
§
å
ã
ã
¾
ã
ï
¼
è
»½
é
ã
¹
ã
¬
ã
ã
ã
¯
ã
ä
º
ã
ã
«
å
é
¢
ã
ã
ã
ã
ã
¦
ã
ã
ï
¼
ã
¡
ã
ã
»
ã
¼
ã
¸
ç
µ
ç
±
ã
§
æ
å
±
ã
ã
ã
ã
ã
ã
ã
¾
ã
:
All
Elixir
code
runs
inside
lightweight
threads
of
execution
(
called
processes
)
that
are
isolated
and
exchange
information
via
messages
:
è
»½
é
ã
ª
æ
§
è
³ª
ã
«
ã
ã
ï
¼
å
ã
ã
ã
·
ã
³
å
ã
§
æ
°
å
ä
¸
ã
®
ã
ã
­
ã
»
ã
¹
ã
å
æ
ã
«
å
ä
½
ã
ã
ã
ã
ã
ç
ã
ã
ã
ã
ã
¾
ã
ã
ã
ã
ã
­
ã
»
ã
¹
ã
¯
å
é
¢
ã
ã
¦
ã
ã
ã
®
ã
§
ï
¼
ã
ã
ã
ã
ç
¬
ç
«
ã
ã
¦
GC
ã
å
ã
ã
ã
ã
ã
ã
§
ã
ï
¼
ã
·
ã
¹
ã
ã
å
ä
½
ã
§
ã
®
å
æ
­¢
ã
æ
¸
ã
ã
ï
¼
å
ã
¦
ã
®
ã
ã
·
ã
³
ã
ª
ã
½
ã
¼
ã
¹
ã
å
¯
è
½
ã
ª
é
ã
å
¹
ç
ç
ã
«
å
©
ç
¨(
å
ç
ã
¹
ã
±
ã
¼
ã
ª
ã
³
ã
°)
ã
§
ã
ã
¾
ã
ã
Due
do
their
lightweight
nature
it
is
not
uncommon
to
have
hundreds
of
thousands
of
processes
running
concurrently
in
the
same
machine
.
Isolation
allows
processes
to
be
garbage
collected
independently
reducing
system
-
wide
pauses
and
using
all
machine
resources
as
efficiently
as
possible
(
vertical
scaling
).
ã
ã
­
ã
»
ã
¹
ã
¯
å
ã
ã
ã
ã
ã
¯
ã
¼
ã
¯
å
ã
§
ã
®
ç
°
ã
ª
ã
ã
ã
·
ã
³
ä
¸
ã
«
ã
ã
å
¥
ã
®
ã
ã
­
ã
»
ã
¹
ã
ã
ã
ã
ã
ã
§
ã
ã
¾
ã
ã
ã
ã
ã
¯
å
æ
ã
®
å
º
ç
¤
ã
ã
ã
¦
æ
ä
¾
ã
ã
ï
¼
é
ç
º
è
ã
¯
è
¤
æ
°
ã
®
ã
ã
¼
ã
ã
«
è
·¨
ã
ã
ä
½
æ
¥­
ã
ã
ã
¾
ã
è
ª¿
æ
ã
ã
¦
å
ã
ã
ã
(
æ
°´
å
¹³
ã
¹
ã
±
ã
¼
ã
ª
ã
³
ã
°)
ã
ã
ã
«
ã
ª
ã
ã
¾
ã
ã
Processes
are
also
able
to
communicate
with
other
processes
running
on
different
machines
in
the
same
network
.
This
provides
the
foundation
for
distribution
allowing
developers
to
coordinate
work
across
multiple
nodes
(
horizontal
scaling
).
ã
ã
­
ã
ã
¯
ã
·
ã
§
ã
³
ç
°
å
¢
ã
§
ä
º
æ
ã
ã
ª
ã
ã
ã
ã
è
µ·
ã
ã
ã
®
ã
¯
é
¿
ã
ã
ã
ã
®
ã
ª
ã
ç
¾
å
®
ã
§
ã
ã
ã
ã
ã
ã
¯
ã
¼
ã
¯
ï
¼
ã
ã
¡
ã
¤
ã
«
ã
·
ã
¹
ã
ã
ï
¼
ã
ã
®
ä
»
ç
¬¬
ä
¸
è
ã
®
ã
ª
ã
½
ã
¼
ã
¹
ã
è
ã
ã
«
å
«
ã
ã
ã
ï
¼
ã
ã
ã
«
ä
º
æ
ã
ã
ª
ã
ã
ã
ã
¯
å
¢
ã
ã
¾
ã
ã
The
unavoidable
truth
about
software
running
in
production
is
that
things
will
go
wrong
.
Even
more
when
we
take
network
file
systems
and
other
third
-
party
resources
into
account
.
é
å
®³
ã
«
å
¯¾
å
¦
ã
ã
ã
ã
ï
¼
Elixir
ã
§
ã
¯
ï
¼
ä
º
å
®
é
ã
ã
«
ç
©
ä
º
ã
ã
ã
ã
ª
ã
ã
ª
ã
ã
ã
ã
ï
¼
ã
·
ã
¹
ã
ã
ã
®
ä
¸
é
ã
ã
©
ã
®
ã
ã
ã
«
å
è
µ·
å
ã
ã
ã
ã
æ
±º
ã
ã
ã
ã
ã
¹
ã
¼
ã
ã
¼
ã
ã
¤
ã
¶
ã
¼
ã
ã
ã
ã
ã
®
ã
æ
ä
¾
ã
ã
¦
ã
ã
¾
ã
ã
ã
ã
®
ã
ã
ã
å
ä
½
ã
ä
¿
è
¨¼
ã
ã
ã
¦
ã
ã
ã
ã
ã
æ
¢
ã
«
ã
ã
ã
ã
¦
ã
ã
å
æ
ç
¶
æ
ã
¸
ã
æ
»
ã
ã
¾
ã
:
To
cope
with
failures
Elixir
provides
supervisors
which
describe
how
to
restart
parts
of
your
system
when
things
go
awry
going
back
to
a
known
initial
state
that
is
guaranteed
to
work
:
é
¢
æ
°
å
ã
ã
­
ã
°
ã
©
ã
ã
³
ã
°
ã
¯
é
ç
º
è
ã
ã
³
ã
¼
ã
ã
ç
­
ã
ï
¼
é
ã
ï
¼
ã
¡
ã
³
ã
ã
ã
³
ã
¹
ã
ã
ã
ã
æ
¸
ã
ã
ã
ã
®
å
©
ã
ã
ã
ª
ã
ã
ã
ã
ª
ã
³
ã
¼
ã
ã
ã
³
ã
°
ã
¹
ã
¿
ã
¤
ã
«
ã
æ
å
¥¨
ã
ã
¾
ã
ã
ä
¾
ã
ã
°
ï
¼
ã
ã
¿
ã
¼
ã
³
ã
ã
ã
ã
³
ã
°
ã
¯
é
ç
º
è
ã
ã
ã
¼
ã
¿
æ
§
é
ã
è
§£
ã
ã
¦
ï
¼
ä
¸­
è
º«
ã
¸
ã
®
ã
¢
ã
¯
ã
»
ã
¹
ã
ç
°¡
å
ã
«
ã
§
ã
ã
ã
ã
ã
«
ã
ã
¾
ã
:
Functional
programming
promotes
a
coding
style
that
helps
developers
write
code
that
is
short
fast
and
maintainable
.
For
example
pattern
matching
allows
developers
to
easily
destructure
data
and
access
its
contents
:
ã
ã
¿
ã
¼
ã
³
ã
ã
ã
ã
³
ã
°
ã
ã
¬
ã
¼
ã
ã
ä
¸
ç
·
ã
«
ä
½¿
ã
ã
ï
¼
ã
ã
ã
¤
ã
ã
®
ã
³
ã
¼
ã
ã
å
®
è
¡
ã
ã
ã
ã
ã
®
å
·
ä
½
ç
ã
ª
æ
¡
ä
»¶
ã
ç
°¡
æ
½
ã
«
ç
¤º
ã
ã
ã
ã
ã
§
ã
ã
¾
ã
:
When
mixed
with
guards
pattern
matching
allows
us
to
elegantly
match
and
assert
specific
conditions
for
some
code
to
execute
:
Elixir
ã
¯
ã
ã
ª
ã
ã
®
ã
½
ã
ã
ã
¦
ã
§
ã
¢
ã
ä
º
æ
³
ã
®
ç
¯
å
²
å
ã
§
å
ä
½
ã
ã
¦
ã
ã
ã
ã
ã
ç
¢º
ã
ã
ã
ã
ã
ï
¼
ã
ã
ã
ã
®
ç
¹
å
¾´
ã
«
å
¤§
ã
ã
é
¼
ã
ã
¦
ã
ã
¾
ã
ï
¼
ã
ã
ã
¦
ï
¼
æ
³
å
®
å
¤
ã
«
ã
ª
ã
ã
ã
ã
ï
¼
ã
å
¿
é
ã
ª
ã
ï
¼
ã
¹
ã
¼
ã
ã
¼
ã
ã
¤
ã
¶
ã
¼
ã
å
¼
ã
æ
»
ã
ã
¦
ã
ã
ã
¾
ã
ï
¼
Elixir
relies
heavily
on
those
features
to
ensure
your
software
is
working
under
the
expected
constraints
.
And
when
it
is
not
don
'
t
worry
supervisors
got
your
back
!
Elixir
ã
¯
ç
ç
æ
§
ã
®
å
ä
¸
ã
®
ã
ã
ï
¼
é
ç
º
è
ã
ç
¹
å
®
ã
®
é
å
ã
®
ã
ã
ã
«
è
è
ª
ã
è
ª
ç
¶
ã
«
æ
¡
å
¼µ
ã
§
ã
ã
ã
ã
ï
¼
æ
¡
å
¼µ
ã
ã
ã
ã
ã
ã
ã
«
è
¨­
è
ã
ã
ã
¦
ã
ã
¾
ã
ã
Elixir
has
been
designed
to
be
extensible
letting
developers
naturally
extend
the
language
to
particular
domains
in
order
to
increase
their
productivity
.
ä
¾
ã
ã
ã
¦
ï
¼
ExUnit
ã
å
¼
ã
°
ã
ã
Elixir
ã
®
ã
ã
¹
ã
ã
ã
¬
ã
¼
ã
ã
¯
ã
¼
ã
¯
ã
§
å
ç
ã
ª
ã
ã
¹
ã
ã
±
ã
¼
ã
¹
ã
æ
¸
ã
ã
¦
ã
¿
ã
¾
ã
ã
ã
:
As
an
example
let
'
s
write
a
simple
test
case
using
Elixir
'
s
test
framework
called
ExUnit
:
ã
ª
ã
ã
·
ã
§
ã
³
async
:
true
ã
§
ã
ã
§
ã
ã
ã
ã
è
¤
æ
°
ã
®
CPU
ã
³
ã
¢
ã
ä
½¿
ã
ã
¦
ã
ã
¹
ã
ã
ä
¸¦
å
ã
§
è
µ°
ã
ã
ã
ã
ã
ã
«
ã
ª
ã
ï
¼
assert
æ
©
è
½
ã
§
ã
ã
ª
ã
ã
®
ã
³
ã
¼
ã
ã
æ
¤
è
¨¼
ã
ï
¼
å
¤±
æ
ã
ã
å
å
ã
¯
ã
ã
ã
ã
ã
ã
ã
¬
ã
ã
¼
ã
ã
æ
ä
¾
ã
ã
¾
ã
ã
ã
ã
ã
ã
®
ç
¹
å
¾´
ã
¯
Elixir
ã
®
ã
ã
¯
ã
­
ã
ä
½¿
ã
ã
¦
æ
§
ç
¯
ã
ã
ã
¦
ã
ã
ï
¼
ã
¾
ã
ã
§
ã
ã
ã
ã
è
è
ª
ã
®
ä
¸
é
ã
§
ã
ã
ã
ã
®
ã
ã
ã
«
æ
°
ã
ã
æ
§
æ
ã
è
¿½
å
ã
§
ã
ã
ã
ã
ã
«
ã
ª
ã
ã
¦
ã
ã
¾
ã
ã
The
async
:
true
option
allows
test
s
to
run
in
parallel
using
as
many
CPU
cores
as
possible
while
the
assert
functionality
can
introspect
your
code
providing
great
reports
in
case
of
failures
.
Those
features
are
built
using
Elixir
macros
making
it
possible
to
add
new
constructs
as
if
they
were
part
of
the
language
itself
.
Elixir
ã
¯
é
ç
º
ã
ç
°¡
å
ã
«
ã
ã
ã
ã
ã
®
ç
æ
ã
ã
ã
ã
¼
ã
«
ã
»
ã
ã
ã
ä
¸
ç
·
ã
«
å
æ
¢±
ã
ã
¦
ã
ã
¾
ã
ã
Mix
ã
¯
é
ç
º
ã
ç
°¡
å
ã
«
ã
ã
ã
ã
ã
®
ç
æ
ã
ã
ã
ã
¼
ã
«
ã
»
ã
ã
ã
ä
¸
ç
·
ã
«
å
æ
¢±
ã
ã
¦
ã
ã
¾
ã
:
Elixir
ships
with
a
great
set
of
tools
to
ease
development
.
Mix
is
a
build
tool
that
allows
you
to
easily
create
projects
manage
tasks
run
tests
and
more
:
Mix
ã
¯
ä
¾
å
­
æ
§
ã
ç
®¡
ç
ã
§
ã
ï
¼
Hex
ã
ã
ã
±
ã
¼
ã
¸
ã
ã
ã
¼
ã
¸
ã
ã
¼
ã
ã
ã
¾
ã
ç
µ±
å
ã
ã
ã
¦
ã
ã
¾
ã
ï
¼
Hex
ã
§
ã
¯
ä
¾
å
­
é
¢
ä
¿
ã
®
è
§£
æ
±º
ã
ã
ª
ã
¢
ã
¼
ã
ã
«
ã
ã
ã
ã
ã
±
ã
¼
ã
¸
ã
®
å
å
¾
ã
è
¡
ã
ã
¾
ã
ã
Mix
is
also
able
to
manage
dependencies
and
integrates
nicely
with
the
Hex
package
manager
which
provides
dependency
resolution
and
the
ability
to
remotely
fetch
packages
.
IEx
(
Elixirã
®
ã
¤
ã
³
ã
¿
ã
©
ã
¯
ã
ã
ã
ã
·
ã
§
ã
«)
ã
ã
ã
ã
ã
ã
ã
ª
ã
ã
¼
ã
«
ã
¯
è
è
ª
ã
æ
§
ã
ã
ª
è
¦³
ç
¹
ã
§
ã
ã
ã
ã
ã
®
ã
«
æ
´»
ç
ã
§
ã
ï
¼
ã
ã
©
ã
¼
ã
ã
ã
ã
ã
ã
ã
ã
­
ã
¥
ã
¡
ã
³
ã
ã
å
ã
ã
ã
ã
è
¯
ã
ã
ã
®
ã
§
ã
ã
ã
¾
ã
ï
¼
è
ª
å
è
å
®
ï
¼
ã
ã
ã
ã
°
ã
ã
¼
ã
«
ï
¼
ã
³
ã
¼
ã
å
è
ª­
ã
¿
è
¾¼
ã
¿
ã
ª
ã
©
ã
ã
ã
ã
ã
ã
®
ã
ã
©
ã
ã
ã
ã
©
ã
¼
ã
ã
ã
ã
¦
ã
æ
ä
¾
ã
ã
ã
¦
ã
ã
¾
ã
:
Tools
like
IEx
(
Elixir
'
s
interactive
shell
)
are
able
to
leverage
many
aspects
of
the
language
and
platform
to
provide
auto
-
complete
debugging
tools
code
reloading
as
well
as
nicely
formatted
documentation
:
Elixir
ã
¯
Erlang
VM
ä
¸
ã
§
å
ä
½
ã
ï
¼
Erlang
ã
®
ã
ã
³
ã
·
ã
¹
ã
ã
ã
¸
å
¶
é
ã
ª
ã
ã
«
ã
¢
ã
¯
ã
»
ã
¹
ã
§
ã
ã
¾
ã
ï
¼
Erlang
ã
¯
Heroku
Whatsapp
Klarna
Basho
ã
ª
ã
©
ã
®
ä
¼
ç
¤¾
ã
§
å
¤
ã
ã
®
å
æ
ï
¼
è
é
å
®³
æ
§
ã
®
é
«
ã
ã
¢
ã
ã
ª
ã
±
ã
¼
ã
·
ã
§
ã
³
ã
®
æ
§
ç
¯
ã
«
ä
½¿
ã
ã
ã
¦
ã
ã
¾
ã
ã
Elixir
ã
ã
­
ã
°
ã
©
ã
ã
¼
ã
¯
å
®
è
¡
æ
ã
³
ã
¹
ã
ã
ª
ã
ã
«
ã
©
ã
ã
ª
Erlang
ã
®
é
¢
æ
°
ã
å
¼
ã
³
å
º
ã
ã
ã
ã
ã
§
ã
ã
¾
ã
ã
Elixir
runs
on
the
Erlang
VM
giving
developers
complete
access
to
Erlang
'
s
ecosystem
used
by
companies
like
Heroku
Whatsapp
Klarna
Basho
and
many
more
to
build
distributed
fault
-
tolerant
applications
.
An
Elixir
programmer
can
invoke
any
Erlang
function
with
no
runtime
cost
:
ã
ã
ã
Elixir
ã
®
ã
ã
ã
ç
¥
ã
ã
«
ã
¯
ã
getting
started
guide
ã
å
ç
§
ã
ã
¦
ã
ã
ã
ã
ã
ã
ª
ã
³
ã
©
ã
¤
ã
³
ã
ã
­
ã
¥
ã
¡
ã
³
ã
ã
Erlang
é
ç
º
è
ã
®
ã
ã
ã
®
ç
­
æ
é
ä
¸­
å
å
º§
ã
ç
æ
ã
ã
¦
ã
ã
¾
ã
ã
To
learn
more
about
Elixir
check
our
getting
started
guide
.
We
also
have
online
documentation
available
and
a
Crash
Course
for
Erlang
developers
.
Elixir**************************************ã
ã
¼
ã
·
ã
ã
¯
ã
±
ã
¢
ã
¹
ã
ã
·
ã
ã
«
ã
±
ã
¢
ã
ã
¼
ã
¹
ã
¡
ã
¼
ã
¯
è
©³
ã
ã
è
¦
ã
å
ç
²§
æ
°´
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
æ
¹§
ã
ä
¸
ã
ã
ã
ã
ã
ª
ã
ã
ª
ã
ã
ã
ã
ã
ã
§
æ
º
ã
ã
ã
è
¬
ç
å
ç
²§
æ
°´
å
ç
²§
æ
°´
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
ã
ã
ã
ã
ã
ã
ã
ª
ã
§
æ
º
ã
ã
ã
æ
ã
ã
é
¡
å
°
è
±¡
ã
¸
å
°
ã
ã
è
¬
ç
ç
¾
ç
½
å
ç
²§
æ
°´
å
ç
²§
æ
°´
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
³
ã
ª
ã
ã
ã
æ
¿
å
¯
ã
ª
ã
ã
ã
ã
ã
§
ä
¸
è
³ª
ã
ª
ã
ã
ª
æ
ã
ã
ã
ã
ã
æ
¿
å
¯
å
ç
²§
æ
°´
ä
¹³
æ
¶²
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
æ
¹§
ã
ä
¸
ã
ã
ã
ã
ã
ª
ã
ã
ª
ã
ã
ã
ã
ã
ã
ä
¿
ã
¤
ã
è
¬
ç
ä
¹³
æ
¶²
ä
¹³
æ
¶²
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
ã
ã
ã
ã
ã
ã
ã
ª
ã
§
æ
º
ã
ã
ã
æ
ã
ã
é
¡
å
°
è
±¡
ã
ä
¿
ã
¤
ã
è
¬
ç
ç
¾
ç
½
ä
¹³
æ
¶²
ä
¹³
æ
¶²
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
³
ã
ª
ã
ã
ã
æ
¿
å
¯
ã
ª
ã
ã
ã
ã
ã
§
ä
¸
è
³ª
ã
ª
ã
ã
ª
æ
ã
è
²
ã
¿
ä
¿
ã
¤
æ
¿
å
¯
ä
¹³
æ
¶²
ç
¾
å
®¹
ä
¹³
æ
¶²
ï
¼
æ
¥
ä
¸­
ç
ï
¼
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ç
´«
å
¤
ç
·
ã
ª
ã
©
ã
ã
å
®
ã
ã
å
¤
æ
¹
ã
¾
ã
§
ã
ã
ª
ã
ç
¶
ã
ã
æ
ã
®
ä
¹³
æ
¶²
ç
¾
å
®¹
ä
¹³
æ
¶²
ï
¼
æ
¥
ä
¸­
ç
ï
¼
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ç
´«
å
¤
ç
·
ã
ª
ã
©
ã
ã
å
®
ã
ã
å
¤
æ
¹
ã
¾
ã
§
ã
ã
ª
ã
ç
¶
ã
ã
æ
ã
®
ä
¹³
æ
¶²
ç
¾
å
®¹
ä
¹³
æ
¶²
ï
¼
æ
¥
ä
¸­
ç
ï
¼
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
æ
ª
å
½±
é
¿
ã
ã
å
®
ã
ã
ª
ã
ã
ã
æ
ã
ã
ã
ã
ã
ª
ã
ã
­
ã
¼
ã
ã
ã
ã
æ
ã
®
ç
¾
ç
½
ä
¹³
æ
¶²
ç
¾
å
®¹
ä
¹³
æ
¶²
ï
¼
æ
¥
ä
¸­
ç
ï
¼
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
æ
ª
å
½±
é
¿
ã
ã
å
®
ã
ã
ª
ã
ã
ã
æ
ã
ã
ã
ã
ã
ª
ã
ã
­
ã
¼
ã
ã
ã
ã
æ
ã
®
ç
¾
ç
½
ä
¹³
æ
¶²
ç
¾
å
®¹
ä
¹³
æ
¶²
ï
¼
æ
¥
ä
¸­
ç
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
³
ã
ª
ã
ã
ã
ç
¬
æ
ã
«
è
è
²
ã
ç
¾
ã
ã
è
¦
ã
ã
æ
¥
ä
¸­
ã
®
ç
¾
è
ã
å
®
ã
æ
¿
å
¯
ã
ã
­
ã
ã
¯
ã
¿
ã
¼
ã
¡
ã
¼
ã
¯
è
½
ã
ã
ï
¼
ã
¯
ã
¬
ã
³
ã
¸
ã
³
ã
°
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
å
¯
ç
ã
¡
ã
¼
ã
¯
ã
æ
º¶
ã
ã
ã
¦
è
½
ã
ã
ã
ã
ª
ã
¤
ã
«
ã
¿
ã
¤
ã
ã
®
ã
¡
ã
¼
ã
¯
è
½
ã
ã
ã
¡
ã
¼
ã
¯
è
½
ã
ã
ï
¼
ã
¯
ã
¬
ã
³
ã
¸
ã
³
ã
°
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
å
¸
ç
ã
ã
¦
ã
ã
ã
ã
ã
ã
ã
¸
ã
§
ã
«
ã
¿
ã
¤
ã
ã
®
ã
¡
ã
¼
ã
¯
è
½
ã
ã
ã
¡
ã
¼
ã
¯
è
½
ã
ã
ï
¼
ã
¯
ã
¬
ã
³
ã
¸
ã
³
ã
°
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ã
ã
ã
ã
å
ã
¿
è
¾¼
ã
ã
§
è
½
ã
ã
ã
ã
¯
ã
ª
ã
¼
ã
ã
¿
ã
¤
ã
ã
®
ã
¡
ã
¼
ã
¯
è
½
ã
ã
ã
¡
ã
¼
ã
¯
è
½
ã
ã
ï
¼
ã
¯
ã
¬
ã
³
ã
¸
ã
³
ã
°
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ã
µ
ã
ã
ã
µ
ã
ã
ã
ã
¦
è
½
ã
ã
ã
ã
­
ã
¼
ã
·
ã
§
ã
³
ã
¿
ã
¤
ã
ã
®
ã
¡
ã
¼
ã
¯
è
½
ã
ã
ã
¡
ã
¼
ã
¯
è
½
ã
ã
ï
¼
ã
¯
ã
¬
ã
³
ã
¸
ã
³
ã
°
ï
¼
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
è
ã
®
ã
«
ã
ã
è
¦
å
ã
ã
¯
ã
ª
ã
¢
ã
ã
ª
ã
¤
ã
«
ã
¿
ã
¤
ã
ã
®
è
¬
ç
ã
¡
ã
¼
ã
¯
è
½
ã
ã
ã
¡
ã
¼
ã
¯
è
½
ã
ã
ï
¼
ã
¯
ã
¬
ã
³
ã
¸
ã
³
ã
°
ï
¼
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
ã
«
ã
ã
ã
®
ã
ª
ã
ç
è
ã
¸
ã
ã
¸
ã
§
ã
«
ã
¯
ã
ª
ã
¼
ã
ã
¿
ã
¤
ã
ã
®
è
¬
ç
ã
¡
ã
¼
ã
¯
è
½
ã
ã
æ
é
¡
æ
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ã
²
ã
æ
¼
ã
ã
§
å
¼¾
å
æ
³¡
ã
ã
ã
·
ã
ã
æ
³¡
ç
«
ã
¦
ã
ã
³
ã
ã
¿
ã
¤
ã
ã
®
æ
é
¡
ã
ã
¼
ã
¹
æ
é
¡
æ
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
å
¼¾
å
æ
³¡
ã
§
ã
µ
ã
ã
ã
ã
ã
ã
ã
ã
ª
è
ã
«
æ
ã
ã
ã
ã
æ
é
¡
ã
ã
©
ã
¼
ã
æ
é
¡
æ
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
è
ã
®
ã
«
ã
ã
è
¦
å
ã
é
¤
å
»
ã
ã
ã
ã
ã
ã
¯
ã
ª
ã
¢
ã
«
å
°
ã
è
¬
ç
æ
é
¡
ã
ã
©
ã
¼
ã
æ
é
¡
æ
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
è
ã
®
ã
«
ã
ã
è
¦
å
ã
é
¤
å
»
ã
ã
ã
ã
ã
ã
¯
ã
ª
ã
¢
ã
«
å
°
ã
è
¬
ç
æ
é
¡
ç
³
ã
ã
æ
é
¡
æ
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
³
ã
ª
ã
ã
ã
ã
·
ã
«
ã
­
ã
¼
ã
ª
æ
¿
å
¯
æ
³¡
ã
§
è
æ
²¢
ã
«
æ
ã
æ
¿
å
¯
æ
é
¡
ã
ã
«
ã
¯
ç
¾
å
®¹
æ
¶²
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
å
ç
¸®
ã
®
ä
¸
æ
»´
ã
§
ã
ä
¸
å
ã
ã
®
ã
ã
ª
ã
ç
¾
å
®¹
æ
¿
å
¯
æ
¶²
ç
¾
å
®¹
æ
¶²
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ç
®
ã
ã
å
ã
ã
ã
®
è
ã
«
ã
ã
ã
ª
ã
ä
¸
ã
ã
è
¬
ç
é
å
ç
ç
¾
å
®¹
æ
¶²
ç
¾
å
®¹
æ
¶²
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
æ
¯
ç
©´
ã
®
æ
°
ã
«
ã
ª
ã
ã
»
ã
ã
«
ã
ã
ª
æ
ã
ä
¸
ã
ã
ã
è
¬
ç
ç
¾
å
®¹
æ
¶²
ã
¯
ã
ª
ã
¼
ã
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
è
²©
å
£²
å
ï
¼
è
³
ç
å
ã
¬
ã
ã
ã
ã
¤
ã
¿
ã
«
ã
¯
ã
ª
ã
¼
ã
V
è
¬
ç
æ
å
¹
æ
å
ç
ç
²
ã
¬
ã
ã
ã
¼
ã
«
é
å
ã
ç
¾
å
®¹
æ
¿
å
¯
ã
ª
ã
³
ã
¯
ã
«
ã
¯
ã
ª
ã
¼
ã
ã
¯
ã
ª
ã
¼
ã
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
è
±
ã
ã
«
ã
ã
ã
ã
ã
ã
ã
ª
ã
ã
ã
ã
¼
ã
¸
ã
ã
ã
¯
ã
ª
ã
¼
ã
ã
¯
ã
ª
ã
¼
ã
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
è
ã
ç
ã
¾
ã
å
¤
ã
ã
å
¤
ã
«
ã
ç
¾
å
®¹
æ
¿
å
¯
ã
¯
ã
ª
ã
¼
ã
ã
¯
ã
ª
ã
¼
ã
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
ç
´«
å
¤
ç
·
ã
«
ã
ã
è
è
²
å
°
è
±¡
ã
®
å
¤
å
ã
é
²
ã
ã
è
¬
ç
ç
¾
ç
½
ã
¸
ã
§
ã
«
ã
¯
ã
ª
ã
¼
ã
ã
¯
ã
ª
ã
¼
ã
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
³
ã
ª
ã
ã
ã
æ
º
ã
¡
ã
ã
ã
ã
ã
ã
§
ç
®
ã
ã
ã
«
ã
ã
ª
ã
æ
¿
å
¯
ã
¢
ã
¤
ã
¯
ã
ª
ã
¼
ã
ã
ã
ã
µ
ã
¼
ã
¸
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
å
¼
ã
ã
ã
¾
ã
ã
ã
ã
ª
è
ã
¸
å
°
ã
ã
ã
ã
ã
µ
ã
¼
ã
¸
ã
¯
ã
ª
ã
¼
ã
ã
ã
ã
µ
ã
¼
ã
¸
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
ç
¾
ç
½
æ
å
ã
ã
ã
ã
ã
è
ã
¸
ã
è
¬
ç
ã
ã
ã
µ
ã
¼
ã
¸
ã
¯
ã
ª
ã
¼
ã
å
ã
ã
å
ç
²§
æ
°´
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
å
¼
ã
ã
ã
ã
¦
ã
ã
ã
ã
ã
ç
¶
ã
ã
å
ã
ã
å
ç
²§
æ
°´
å
ã
ã
å
ç
²§
æ
°´
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
æ
¯
ç
©´
ã
å
¼
ã
ã
ã
ã
¦
ã
¯
ã
ª
ã
¢
ã
ª
è
ã
¸
ã
è
¬
ç
ç
¾
ç
½
å
ã
ã
å
ç
²§
æ
°´
ã
ã
ã
¯
ã
»
ã
ã
¹
ã
¯
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ã
·
ã
ã
·
ã
ã
¸
ã
§
ã
«
ã
«
ç
¾
å
®¹
æ
å
ã
ã
ã
·
ã
ã
®
å
¡
ã
ã
¦
å
¯
ã
ã
ã
ã
¯
ã
ã
ã
¯
ã
»
ã
ã
¹
ã
¯
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
è
²©
å
£²
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
ã
¯
ã
ª
ã
¢
ã
¸
ã
§
ã
«
C
ç
¾
ç
½
æ
å
¹
æ
å
é
å
ã
å
¡
ã
ã
¦
å
¯
ã
ç
¾
ç
½
ã
¸
ã
§
ã
«
ã
ã
ã
¯
ã
»
ã
ã
¹
ã
¯
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
è
ã
ã
²
ã
ã
ã
¦
ã
ã
ã
¡
ã
ã
·
ã
¼
ã
ç
¶
ç
¾
å
®¹
æ
¶²
ã
ã
¹
ã
¯
ã
ã
ã
¯
ã
»
ã
ã
¹
ã
¯
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
æ
·±
ã
æ
°
ã
«
ã
ª
ã
ç
®
ã
ã
ã
é
ä
¸­
ã
±
ã
¢
ã
ã
ã
è
¬
ç
ã
·
ã
¼
ã
ç
¶
ã
¢
ã
¤
ã
ã
¹
ã
¯
ã
ã
ã
¯
ã
»
ã
ã
¹
ã
¯
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
2
ã
¹
ã
ã
ã
ã
§
é
ä
¸­
ã
±
ã
¢
ã
è
¬
ç
ç
¾
å
®¹
æ
¶²
ã
è
¬
ç
ç
¾
ç
½
ã
ã
¹
ã
¯
ã
ã
¡
ã
³
ã
ã
¼
ã
·
ã
§
ã
³
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ã
ã
ã
¿
ã
»
è
²
ã
ã
©
ã
»
æ
¯
ç
©´
ã
®
å
½±
ã
ã
²
ã
å
¡
ã
ã
§
æ
ã
ã
å
¤
ã
ã
ã
ã
¦
ã
ã
ª
ã
¼
ã
ã
¡
ã
³
ã
ã
¼
ã
·
ã
§
ã
³
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ã
²
ã
ã
¬
ã
ã
§
é
«
ã
é
æ
å
º¦
ã
ã
ã
ç
´°
ã
ã
ç
¾
ç
½
ç
è
ã
®
ã
ã
ã
«
ä
»
ä
¸
ã
ã
ã
ã
¡
ã
³
ã
ã
¼
ã
·
ã
§
ã
³
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
å
°
ã
ã
ã
æ
¯
ç
©´
ã
ª
ã
©
ã
®
æ
©
ã
¿
ã
ã
«
ã
ã
¼
ã
ã
ã
ã
ª
æ
ã
ç
¶
ã
ã
ã
ã
«
ã
¸
ã
§
ã
³
ã
ã
¡
ã
³
ã
ã
¼
ã
·
ã
§
ã
³
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ã
²
ã
ã
¬
ã
ã
§
é
«
ã
é
æ
å
º¦
ã
ã
¿
ã
ã
¿
ã
ã
ã
ç
¾
ç
½
ç
è
ã
®
ã
ã
ã
«
ä
»
ä
¸
ã
ã
å
ç
²§
ä
¸
å
°
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ã
ã
ã
¿
ã
»
ã
·
ã
ã
»
è
²
ã
ã
ã
ã
«
ã
ã
¼
ã
ã
¦
ã
æ
ã
ã
è
è
²
ã
«
æ
ã
ã
å
ç
²§
ä
¸
å
°
å
ç
²§
ä
¸
å
°
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ã
­
ã
¡
ã
æ
¯
ç
©´
ã
è
²
ã
ã
©
ã
ç
¬
æ
ã
«
è
æ
­£
ã
ç
¾
è
ã
ã
­
ã
¼
ã
ã
ã
å
ç
²§
ä
¸
å
°
ã
ã
ã
ã
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ã
ã
ã
¿
ã
å
¹
å
¸
ã
æ
¶
ã
ã
ã
¤
ã
ã
é
æ
æ
ã
æ
¼
å
º
ã
ã
ã
«
ã
¼
ã
¹
ã
ã
¦
ã
ã
¼
ã
ã
ã
ã
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
å
ç
²§
ç
ã
ã
«
ã
ã
ã
ã
§
ã
µ
ã
ã
ã
ä
¸
è
³ª
ã
ª
è
ã
ã
¤
ã
ã
ã
ã
¬
ã
¹
ã
ã
ã
¦
ã
ã
¼
â
»
ç
¾
ç
½
ã
ã
¯
ã
ã
¡
ã
©
ã
ã
³
ã
®
ç
æ
ã
æ
ã
ã
ã
·
ã
ã
»
ã
½
ã
ã
«
ã
¹
ã
é
²
ã
ã
ã
ã
§
ã
ã
å
å
æ
å
±
ï
½
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ï
¼
ELIXIRï
¼
ï
½
è
³
ç
å**************************************ã
å
¡
ã
ã
¦
å
¯
ã
ã
¸
ã
§
ã
«
ã
ã
ã
¯
ã
»
ç
¾
ç
½
ã
ã
ã
ç
¯
15
ç
§
ã
å
¤
æ
¹
ã
ª
ã
®
ã
«
ã
ã
ã
ã
ã
ã
ç
¯
15
ç
§
ã
è
ã
æ
é
«
ã
®
å
³
æ
¹
ã
«
ã
Aç
¯
15
ç
§
ã
è
ã
æ
é
«
ã
®
å
³
æ
¹
ã
«
ã
Bç
¯
15
ç
§
CMæ
å
±
ï
½
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ï
¼
ELIXIRï
¼
ï
½
è
³
ç
å**************************************å
ç
²§
æ
°´
ã
®
å
¾
1
æ
¬
ã
§
ã
å
¤
æ
¹
ã
¾
ã
§
ã
ã
ã
ã
ª
ã
ã
ã
ã
¤
ã
ç
ã
ç
¶
ã
ã
æ
ã
®
ä
¹³
æ
¶²
â
»
è
³
ç
å
è
ª¿
ã
¹
ç
¾
å
®¹
ä
¹³
æ
¶²(
æ
¥
ä
¸­
ç
¨)(
å
»
è
¬
é
å
¤
å
)
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
SPF
30
ã
»
PA
++++
SPF
50
+
ã
»
PA
++++
ç
¾
å
®¹
ä
¹³
æ
¶²(
æ
¥
ä
¸­
ç
¨)(
å
»
è
¬
é
å
¤
å
)
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
SPF
30
ã
»
PA
++++
SPF
50
+
ã
»
PA
++++
æ
ã
®
ä
¹³
æ
¶²
ã
ã
¼
ã
±
ã
¢
ã
¬
ã
ã
ª
ã
¥
ã
¼
ã
·
ã
§
ã
³
ï
½
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ï
¼
ELIXIRï
¼
ï
½
è
³
ç
å**************************************クリス
先生
英語
授業
発音
æ
:」
コメント
ランキング
ジャンル
人気
記事
ランキング
Ameba
トピックス
ブログ
公式
トップブロガー
応募
芸能人
有名人
ブログ
開設
クリス
先生
生徒
さん
読者
ブログ
更新
情報
アクセス
簡単
AD
画像
一覧
Ameba
人気
ブログ
ディズニー
好き
レポ
吉田
さん
ファミリーオフィ
...
ディズニー・エクスプローラーズ・ロッジ
ホテル
...
吉田
さん
ファミリーオフィ
...
マジックアクセス・サマーパーティ
(^...
吉田
さん
ファミリーオフィ
...
香港
ディズニー
リゾート
旅
日本
～
香港
到着
～
ホテ
...
インテリア
DIY
ほんとう
必要
物
持
...
布団
進化
レ
...
インテリア
暮らし
ヒン
...
ツラ
草むしり
解放
♡
わが家
雑草
対策
♪
インテリア
暮らし
ヒン
...
無印
整理
ボックス
シンデレラ
フィット
コン
...
写真
(
風景
)
シンクロニシティ
～
意味
...
あなた
未来
さ
みるく
ロサンゼルス
...
雲の上
～　
Destiny
...
愛知
あじさい
祭り
期間
中
円空
仏
安置
所
...
PR
たくさん
芸能人
有名人
Ameba
ブログ
無料
簡単
こと
ブログ
引っ越し
こちら
多く
方
紹介
ブログ
執筆
方
公式
トップブロガー
認定
Ameba
ブログ
芸能人
有名人
ブログ
希望
著名
人
方
事務所
様
随時
募集
発音
æ
:」｜
クリス
先生
英語
授業**************************************ã
ã
¼
ã
·
ã
ã
¯
ã
±
ã
¢
ã
¹
ã
ã
·
ã
ã
«
ã
±
ã
¢
ã
ã
¼
ã
¹
ã
¡
ã
¼
ã
¯
è
©³
ã
ã
è
¦
ã
å
ç
²§
æ
°´
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
æ
¹§
ã
ä
¸
ã
ã
ã
ã
ã
ª
ã
ã
ª
ã
ã
ã
ã
ã
ã
§
æ
º
ã
ã
ã
è
¬
ç
å
ç
²§
æ
°´
å
ç
²§
æ
°´
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
ã
ã
ã
ã
ã
ã
ã
ª
ã
§
æ
º
ã
ã
ã
æ
ã
ã
é
¡
å
°
è
±¡
ã
¸
å
°
ã
ã
è
¬
ç
ç
¾
ç
½
å
ç
²§
æ
°´
å
ç
²§
æ
°´
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
³
ã
ª
ã
ã
ã
æ
¿
å
¯
ã
ª
ã
ã
ã
ã
ã
§
ä
¸
è
³ª
ã
ª
ã
ã
ª
æ
ã
ã
ã
ã
ã
æ
¿
å
¯
å
ç
²§
æ
°´
ä
¹³
æ
¶²
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
æ
¹§
ã
ä
¸
ã
ã
ã
ã
ã
ª
ã
ã
ª
ã
ã
ã
ã
ã
ã
ä
¿
ã
¤
ã
è
¬
ç
ä
¹³
æ
¶²
ä
¹³
æ
¶²
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
ã
ã
ã
ã
ã
ã
ã
ª
ã
§
æ
º
ã
ã
ã
æ
ã
ã
é
¡
å
°
è
±¡
ã
ä
¿
ã
¤
ã
è
¬
ç
ç
¾
ç
½
ä
¹³
æ
¶²
ä
¹³
æ
¶²
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
³
ã
ª
ã
ã
ã
æ
¿
å
¯
ã
ª
ã
ã
ã
ã
ã
§
ä
¸
è
³ª
ã
ª
ã
ã
ª
æ
ã
è
²
ã
¿
ä
¿
ã
¤
æ
¿
å
¯
ä
¹³
æ
¶²
ç
¾
å
®¹
ä
¹³
æ
¶²
ï
¼
æ
¥
ä
¸­
ç
ï
¼
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ç
´«
å
¤
ç
·
ã
ª
ã
©
ã
ã
å
®
ã
ã
å
¤
æ
¹
ã
¾
ã
§
ã
ã
ª
ã
ç
¶
ã
ã
æ
ã
®
ä
¹³
æ
¶²
ç
¾
å
®¹
ä
¹³
æ
¶²
ï
¼
æ
¥
ä
¸­
ç
ï
¼
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ç
´«
å
¤
ç
·
ã
ª
ã
©
ã
ã
å
®
ã
ã
å
¤
æ
¹
ã
¾
ã
§
ã
ã
ª
ã
ç
¶
ã
ã
æ
ã
®
ä
¹³
æ
¶²
ç
¾
å
®¹
ä
¹³
æ
¶²
ï
¼
æ
¥
ä
¸­
ç
ï
¼
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
æ
ª
å
½±
é
¿
ã
ã
å
®
ã
ã
ª
ã
ã
ã
æ
ã
ã
ã
ã
ã
ª
ã
ã
­
ã
¼
ã
ã
ã
ã
æ
ã
®
ç
¾
ç
½
ä
¹³
æ
¶²
ç
¾
å
®¹
ä
¹³
æ
¶²
ï
¼
æ
¥
ä
¸­
ç
ï
¼
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
æ
ª
å
½±
é
¿
ã
ã
å
®
ã
ã
ª
ã
ã
ã
æ
ã
ã
ã
ã
ã
ª
ã
ã
­
ã
¼
ã
ã
ã
ã
æ
ã
®
ç
¾
ç
½
ä
¹³
æ
¶²
ç
¾
å
®¹
ä
¹³
æ
¶²
ï
¼
æ
¥
ä
¸­
ç
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
³
ã
ª
ã
ã
ã
ç
¬
æ
ã
«
è
è
²
ã
ç
¾
ã
ã
è
¦
ã
ã
æ
¥
ä
¸­
ã
®
ç
¾
è
ã
å
®
ã
æ
¿
å
¯
ã
ã
­
ã
ã
¯
ã
¿
ã
¼
ã
¡
ã
¼
ã
¯
è
½
ã
ã
ï
¼
ã
¯
ã
¬
ã
³
ã
¸
ã
³
ã
°
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
å
¯
ç
ã
¡
ã
¼
ã
¯
ã
æ
º¶
ã
ã
ã
¦
è
½
ã
ã
ã
ã
ª
ã
¤
ã
«
ã
¿
ã
¤
ã
ã
®
ã
¡
ã
¼
ã
¯
è
½
ã
ã
ã
¡
ã
¼
ã
¯
è
½
ã
ã
ï
¼
ã
¯
ã
¬
ã
³
ã
¸
ã
³
ã
°
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
å
¸
ç
ã
ã
¦
ã
ã
ã
ã
ã
ã
ã
¸
ã
§
ã
«
ã
¿
ã
¤
ã
ã
®
ã
¡
ã
¼
ã
¯
è
½
ã
ã
ã
¡
ã
¼
ã
¯
è
½
ã
ã
ï
¼
ã
¯
ã
¬
ã
³
ã
¸
ã
³
ã
°
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ã
ã
ã
ã
å
ã
¿
è
¾¼
ã
ã
§
è
½
ã
ã
ã
ã
¯
ã
ª
ã
¼
ã
ã
¿
ã
¤
ã
ã
®
ã
¡
ã
¼
ã
¯
è
½
ã
ã
ã
¡
ã
¼
ã
¯
è
½
ã
ã
ï
¼
ã
¯
ã
¬
ã
³
ã
¸
ã
³
ã
°
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ã
µ
ã
ã
ã
µ
ã
ã
ã
ã
¦
è
½
ã
ã
ã
ã
­
ã
¼
ã
·
ã
§
ã
³
ã
¿
ã
¤
ã
ã
®
ã
¡
ã
¼
ã
¯
è
½
ã
ã
ã
¡
ã
¼
ã
¯
è
½
ã
ã
ï
¼
ã
¯
ã
¬
ã
³
ã
¸
ã
³
ã
°
ï
¼
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
è
ã
®
ã
«
ã
ã
è
¦
å
ã
ã
¯
ã
ª
ã
¢
ã
ã
ª
ã
¤
ã
«
ã
¿
ã
¤
ã
ã
®
è
¬
ç
ã
¡
ã
¼
ã
¯
è
½
ã
ã
ã
¡
ã
¼
ã
¯
è
½
ã
ã
ï
¼
ã
¯
ã
¬
ã
³
ã
¸
ã
³
ã
°
ï
¼
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
ã
«
ã
ã
ã
®
ã
ª
ã
ç
è
ã
¸
ã
ã
¸
ã
§
ã
«
ã
¯
ã
ª
ã
¼
ã
ã
¿
ã
¤
ã
ã
®
è
¬
ç
ã
¡
ã
¼
ã
¯
è
½
ã
ã
æ
é
¡
æ
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ã
²
ã
æ
¼
ã
ã
§
å
¼¾
å
æ
³¡
ã
ã
ã
·
ã
ã
æ
³¡
ç
«
ã
¦
ã
ã
³
ã
ã
¿
ã
¤
ã
ã
®
æ
é
¡
ã
ã
¼
ã
¹
æ
é
¡
æ
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
å
¼¾
å
æ
³¡
ã
§
ã
µ
ã
ã
ã
ã
ã
ã
ã
ã
ª
è
ã
«
æ
ã
ã
ã
ã
æ
é
¡
ã
ã
©
ã
¼
ã
æ
é
¡
æ
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
è
ã
®
ã
«
ã
ã
è
¦
å
ã
é
¤
å
»
ã
ã
ã
ã
ã
ã
¯
ã
ª
ã
¢
ã
«
å
°
ã
è
¬
ç
æ
é
¡
ã
ã
©
ã
¼
ã
æ
é
¡
æ
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
è
ã
®
ã
«
ã
ã
è
¦
å
ã
é
¤
å
»
ã
ã
ã
ã
ã
ã
¯
ã
ª
ã
¢
ã
«
å
°
ã
è
¬
ç
æ
é
¡
ç
³
ã
ã
æ
é
¡
æ
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
³
ã
ª
ã
ã
ã
ã
·
ã
«
ã
­
ã
¼
ã
ª
æ
¿
å
¯
æ
³¡
ã
§
è
æ
²¢
ã
«
æ
ã
æ
¿
å
¯
æ
é
¡
ã
ã
«
ã
¯
ç
¾
å
®¹
æ
¶²
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
å
ç
¸®
ã
®
ä
¸
æ
»´
ã
§
ã
ä
¸
å
ã
ã
®
ã
ã
ª
ã
ç
¾
å
®¹
æ
¿
å
¯
æ
¶²
ç
¾
å
®¹
æ
¶²
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ç
®
ã
ã
å
ã
ã
ã
®
è
ã
«
ã
ã
ã
ª
ã
ä
¸
ã
ã
è
¬
ç
é
å
ç
ç
¾
å
®¹
æ
¶²
ç
¾
å
®¹
æ
¶²
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
æ
¯
ç
©´
ã
®
æ
°
ã
«
ã
ª
ã
ã
»
ã
ã
«
ã
ã
ª
æ
ã
ä
¸
ã
ã
ã
è
¬
ç
ç
¾
å
®¹
æ
¶²
ã
¯
ã
ª
ã
¼
ã
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
è
²©
å
£²
å
ï
¼
è
³
ç
å
ã
¬
ã
ã
ã
ã
¤
ã
¿
ã
«
ã
¯
ã
ª
ã
¼
ã
V
è
¬
ç
æ
å
¹
æ
å
ç
ç
²
ã
¬
ã
ã
ã
¼
ã
«
é
å
ã
ç
¾
å
®¹
æ
¿
å
¯
ã
ª
ã
³
ã
¯
ã
«
ã
¯
ã
ª
ã
¼
ã
ã
¯
ã
ª
ã
¼
ã
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
è
±
ã
ã
«
ã
ã
ã
ã
ã
ã
ã
ª
ã
ã
ã
ã
¼
ã
¸
ã
ã
ã
¯
ã
ª
ã
¼
ã
ã
¯
ã
ª
ã
¼
ã
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
è
ã
ç
ã
¾
ã
å
¤
ã
ã
å
¤
ã
«
ã
ç
¾
å
®¹
æ
¿
å
¯
ã
¯
ã
ª
ã
¼
ã
ã
¯
ã
ª
ã
¼
ã
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
ç
´«
å
¤
ç
·
ã
«
ã
ã
è
è
²
å
°
è
±¡
ã
®
å
¤
å
ã
é
²
ã
ã
è
¬
ç
ç
¾
ç
½
ã
¸
ã
§
ã
«
ã
¯
ã
ª
ã
¼
ã
ã
¯
ã
ª
ã
¼
ã
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
³
ã
ª
ã
ã
ã
æ
º
ã
¡
ã
ã
ã
ã
ã
ã
§
ç
®
ã
ã
ã
«
ã
ã
ª
ã
æ
¿
å
¯
ã
¢
ã
¤
ã
¯
ã
ª
ã
¼
ã
ã
ã
ã
µ
ã
¼
ã
¸
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
å
¼
ã
ã
ã
¾
ã
ã
ã
ã
ª
è
ã
¸
å
°
ã
ã
ã
ã
ã
µ
ã
¼
ã
¸
ã
¯
ã
ª
ã
¼
ã
ã
ã
ã
µ
ã
¼
ã
¸
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
ç
¾
ç
½
æ
å
ã
ã
ã
ã
ã
è
ã
¸
ã
è
¬
ç
ã
ã
ã
µ
ã
¼
ã
¸
ã
¯
ã
ª
ã
¼
ã
å
ã
ã
å
ç
²§
æ
°´
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
å
¼
ã
ã
ã
ã
¦
ã
ã
ã
ã
ã
ç
¶
ã
ã
å
ã
ã
å
ç
²§
æ
°´
å
ã
ã
å
ç
²§
æ
°´
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
æ
¯
ç
©´
ã
å
¼
ã
ã
ã
ã
¦
ã
¯
ã
ª
ã
¢
ã
ª
è
ã
¸
ã
è
¬
ç
ç
¾
ç
½
å
ã
ã
å
ç
²§
æ
°´
ã
ã
ã
¯
ã
»
ã
ã
¹
ã
¯
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ã
·
ã
ã
·
ã
ã
¸
ã
§
ã
«
ã
«
ç
¾
å
®¹
æ
å
ã
ã
ã
·
ã
ã
®
å
¡
ã
ã
¦
å
¯
ã
ã
ã
ã
¯
ã
ã
ã
¯
ã
»
ã
ã
¹
ã
¯
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
è
²©
å
£²
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
ã
¯
ã
ª
ã
¢
ã
¸
ã
§
ã
«
C
ç
¾
ç
½
æ
å
¹
æ
å
é
å
ã
å
¡
ã
ã
¦
å
¯
ã
ç
¾
ç
½
ã
¸
ã
§
ã
«
ã
ã
ã
¯
ã
»
ã
ã
¹
ã
¯
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
è
ã
ã
²
ã
ã
ã
¦
ã
ã
ã
¡
ã
ã
·
ã
¼
ã
ç
¶
ç
¾
å
®¹
æ
¶²
ã
ã
¹
ã
¯
ã
ã
ã
¯
ã
»
ã
ã
¹
ã
¯
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
æ
·±
ã
æ
°
ã
«
ã
ª
ã
ç
®
ã
ã
ã
é
ä
¸­
ã
±
ã
¢
ã
ã
ã
è
¬
ç
ã
·
ã
¼
ã
ç
¶
ã
¢
ã
¤
ã
ã
¹
ã
¯
ã
ã
ã
¯
ã
»
ã
ã
¹
ã
¯
ï
¼
å
»
è
¬
é
å
¤
å
ï
¼
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
ã
¯
ã
¤
ã
2
ã
¹
ã
ã
ã
ã
§
é
ä
¸­
ã
±
ã
¢
ã
è
¬
ç
ç
¾
å
®¹
æ
¶²
ã
è
¬
ç
ç
¾
ç
½
ã
ã
¹
ã
¯
ã
ã
¡
ã
³
ã
ã
¼
ã
·
ã
§
ã
³
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ã
ã
ã
¿
ã
»
è
²
ã
ã
©
ã
»
æ
¯
ç
©´
ã
®
å
½±
ã
ã
²
ã
å
¡
ã
ã
§
æ
ã
ã
å
¤
ã
ã
ã
ã
¦
ã
ã
ª
ã
¼
ã
ã
¡
ã
³
ã
ã
¼
ã
·
ã
§
ã
³
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ã
²
ã
ã
¬
ã
ã
§
é
«
ã
é
æ
å
º¦
ã
ã
ã
ç
´°
ã
ã
ç
¾
ç
½
ç
è
ã
®
ã
ã
ã
«
ä
»
ä
¸
ã
ã
ã
ã
¡
ã
³
ã
ã
¼
ã
·
ã
§
ã
³
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
å
°
ã
ã
ã
æ
¯
ç
©´
ã
ª
ã
©
ã
®
æ
©
ã
¿
ã
ã
«
ã
ã
¼
ã
ã
ã
ã
ª
æ
ã
ç
¶
ã
ã
ã
ã
«
ã
¸
ã
§
ã
³
ã
ã
¡
ã
³
ã
ã
¼
ã
·
ã
§
ã
³
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ã
²
ã
ã
¬
ã
ã
§
é
«
ã
é
æ
å
º¦
ã
ã
¿
ã
ã
¿
ã
ã
ã
ç
¾
ç
½
ç
è
ã
®
ã
ã
ã
«
ä
»
ä
¸
ã
ã
å
ç
²§
ä
¸
å
°
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ã
ã
ã
¿
ã
»
ã
·
ã
ã
»
è
²
ã
ã
ã
ã
«
ã
ã
¼
ã
ã
¦
ã
æ
ã
ã
è
è
²
ã
«
æ
ã
ã
å
ç
²§
ä
¸
å
°
å
ç
²§
ä
¸
å
°
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ã
­
ã
¡
ã
æ
¯
ç
©´
ã
è
²
ã
ã
©
ã
ç
¬
æ
ã
«
è
æ
­£
ã
ç
¾
è
ã
ã
­
ã
¼
ã
ã
ã
å
ç
²§
ä
¸
å
°
ã
ã
ã
ã
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
ã
ã
ã
¿
ã
å
¹
å
¸
ã
æ
¶
ã
ã
ã
¤
ã
ã
é
æ
æ
ã
æ
¼
å
º
ã
ã
ã
«
ã
¼
ã
¹
ã
ã
¦
ã
ã
¼
ã
ã
ã
ã
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ã
·
ã
¥
ã
ã
ª
ã
ã
«
å
ç
²§
ç
ã
ã
«
ã
ã
ã
ã
§
ã
µ
ã
ã
ã
ä
¸
è
³ª
ã
ª
è
ã
ã
¤
ã
ã
ã
ã
¬
ã
¹
ã
ã
ã
¦
ã
ã
¼
â
»
ç
¾
ç
½
ã
ã
¯
ã
ã
¡
ã
©
ã
ã
³
ã
®
ç
æ
ã
æ
ã
ã
ã
·
ã
ã
»
ã
½
ã
ã
«
ã
¹
ã
é
²
ã
ã
ã
ã
§
ã
ã
å
å
æ
å
±
ï
½
ã
ã
ª
ã
¯
ã
·
ã
¼
ã
«
ï
¼
ELIXIRï
¼
ï
½
è
³
ç
å**************************************人工
知能
活躍
今
LISP
成り立ち
LISP
生い立ち
２つ
主流
Common
LISP
Schema
LISP
スタイル
LISP
人工
知能
LISP
関連
記事
人気
記事
リスト
関数
呼び出し
関数
定義
AI
衝撃
人工
知能
人類
敵
(
講談社
現代新書
)　
Code
部
厳選
ブック
リスト
自分
仕事
AI
仕事
人工
知能
(
AI
)
登場
名作
アニメ
10
選
人工
知能
社会
イメージ
映画
7
選
人工
知能
コグニティブ・コンピューティング
シンギュラリティ
2045
年
問題
AI
人間
の
LISP
言語
ご存知
カッコ
カッコ
独自
路線
カッコ
印象
一般
的
メジャー
言語
の
正直
位置づけ
エントリ
近年
人工
知能
発達
LISP
こと
LISP
これ
歴史
今後
動向
こと
LISP
1958
年
開発
現在
プログラミング
言語
中
もの
１つ
開発
者
ジョン・マッカシー
人工
知能
Artificial
Intelligence
言葉
提唱
者
よう
出自
LISP
人工
知能
プログラム
多く
人工
知能
ブーム
こと
急速
普及
こと
言語
常
多く
方言
方言
の
面
状況
多数
言語
仕様
処理
系
ため
汎用
性
中長期
的
効率
の
よう
状況
中
LISP
標準
化
必要
標準
化
効果
Java
成功
Java
言語
仕様
処理
系
ライブラリ
標準
化
こと
プログラム
どこ
動作
究極
汎用
化
実現
これ
実現
現在
世界
プログラム
言語
１つ
LISP
標準
1984
年
1994
年
ANSI
制定
これ
Common
LISP
Common
LISP
機能
こと
特徴
提案
機能
原則
すべて
導入
の
Common
LISP
姿勢
ため
Common
LISP
言語
仕様
もの
これ
LISP
本来
シンプル
さ
重要
視
進化
の
Scheme
1975
年
開発
最新
仕様
2013
年
7
月
成立
Scheme
仕様
IEEE
制定
Scheme
当初
Scheme
r
名前
そう
当時
OS
ファイル
名
6
文字
制限
ため
末尾
r
Scheme
今
話
Common
LISP
Scheme
現在
LISP
主流
仕様
実装
多く
種類
手軽
の
Scheme
方
Gauche
実装
日本人
開発
利用
簡単
興味
方
いかが
ここ
LISP
プログラム
LISP
名前
LIStProcessor
略
よう
LISP
プログラム
全て
リスト
LISP
リスト
こと
S
式
よう
辺り
厳密
話
今回
省略
ここ
Scheme
Gauche
実装
動作
確認
コード
掲載
リスト
リスト
()
複数
値
データ
構造
LISP
リスト
list
関数
シングルクオート
こと
リスト
こと
関数
呼び出し
１
番目
要素
関数
リスト
こと
実現
上記
足し算
（+
関数
LISP
関数
定義
define
関数
上記
足し算
sum
関数
define
関数
値
変数
格納
の
変数
x
10
格納
次
よう
関数
変数
格納
処理
ラムダ
lambda
LISP
よう
関数
型
プログラミング
言語
関数
値
の
LISP
文法
Scheme
特徴
ところ
これら
特徴
LISP
実行
定義
区別
関数
データ
区別
性質
こと
実行
時
処理
関数
それ
記録
こと
人工
知能
よう
自身
拡張
プログラム
の
ここ
LISP
文法
特徴
把握
こと
LISP
強み
関数
型
プログラミング
考え方
ご存知
これ
大雑把
関数
値
プログラミング
言語
堅牢
プログラム
スタイル
こと
数
年
前
重要
視
よう
今
関数
型
エッセンス
プログラミング
言語
時代
過言
よう
状況
関数
データ
区別
関数
定義
実行
データ
同様
LISP
性質
意味
最先端
2007
年
登場
Clojure
よう
LISP
ベース
新た
プログラミング
言語
誕生
50
年
以上
経過
最前線
活躍
驚異
言語
LISP
いかが
最新
情報
こちら
プログラミング
効率
的
方法
人工
知能
活躍
今
LISP
成り立ち
|
Tech
2
GO**************************************人工
知能
活躍
今
LISP
成り立ち
LISP
生い立ち
２つ
主流
Common
LISP
Schema
LISP
スタイル
LISP
人工
知能
LISP
関連
記事
人気
記事
リスト
関数
呼び出し
関数
定義
AI
衝撃
人工
知能
人類
敵
(
講談社
現代新書
)　
Code
部
厳選
ブック
リスト
自分
仕事
AI
仕事
人工
知能
(
AI
)
登場
名作
アニメ
10
選
人工
知能
社会
イメージ
映画
7
選
人工
知能
コグニティブ・コンピューティング
シンギュラリティ
2045
年
問題
AI
人間
の
LISP
言語
ご存知
カッコ
カッコ
独自
路線
カッコ
印象
一般
的
メジャー
言語
の
正直
位置づけ
エントリ
近年
人工
知能
発達
LISP
こと
LISP
これ
歴史
今後
動向
こと
LISP
1958
年
開発
現在
プログラミング
言語
中
もの
１つ
開発
者
ジョン・マッカシー
人工
知能
Artificial
Intelligence
言葉
提唱
者
よう
出自
LISP
人工
知能
プログラム
多く
人工
知能
ブーム
こと
急速
普及
こと
言語
常
多く
方言
方言
の
面
状況
多数
言語
仕様
処理
系
ため
汎用
性
中長期
的
効率
の
よう
状況
中
LISP
標準
化
必要
標準
化
効果
Java
成功
Java
言語
仕様
処理
系
ライブラリ
標準
化
こと
プログラム
どこ
動作
究極
汎用
化
実現
これ
実現
現在
世界
プログラム
言語
１つ
LISP
標準
1984
年
1994
年
ANSI
制定
これ
Common
LISP
Common
LISP
機能
こと
特徴
提案
機能
原則
すべて
導入
の
Common
LISP
姿勢
ため
Common
LISP
言語
仕様
もの
これ
LISP
本来
シンプル
さ
重要
視
進化
の
Scheme
1975
年
開発
最新
仕様
2013
年
7
月
成立
Scheme
仕様
IEEE
制定
Scheme
当初
Scheme
r
名前
そう
当時
OS
ファイル
名
6
文字
制限
ため
末尾
r
Scheme
今
話
Common
LISP
Scheme
現在
LISP
主流
仕様
実装
多く
種類
手軽
の
Scheme
方
Gauche
実装
日本人
開発
利用
簡単
興味
方
いかが
ここ
LISP
プログラム
LISP
名前
LIStProcessor
略
よう
LISP
プログラム
全て
リスト
LISP
リスト
こと
S
式
よう
辺り
厳密
話
今回
省略
ここ
Scheme
Gauche
実装
動作
確認
コード
掲載
リスト
リスト
()
複数
値
データ
構造
LISP
リスト
list
関数
シングルクオート
こと
リスト
こと
関数
呼び出し
１
番目
要素
関数
リスト
こと
実現
上記
足し算
（+
関数
LISP
関数
定義
define
関数
上記
足し算
sum
関数
define
関数
値
変数
格納
の
変数
x
10
格納
次
よう
関数
変数
格納
処理
ラムダ
lambda
LISP
よう
関数
型
プログラミング
言語
関数
値
の
LISP
文法
Scheme
特徴
ところ
これら
特徴
LISP
実行
定義
区別
関数
データ
区別
性質
こと
実行
時
処理
関数
それ
記録
こと
人工
知能
よう
自身
拡張
プログラム
の
ここ
LISP
文法
特徴
把握
こと
LISP
強み
関数
型
プログラミング
考え方
ご存知
これ
大雑把
関数
値
プログラミング
言語
堅牢
プログラム
スタイル
こと
数
年
前
重要
視
よう
今
関数
型
エッセンス
プログラミング
言語
時代
過言
よう
状況
関数
データ
区別
関数
定義
実行
データ
同様
LISP
性質
意味
最先端
2007
年
登場
Clojure
よう
LISP
ベース
新た
プログラミング
言語
誕生
50
年
以上
経過
最前線
活躍
驚異
言語
LISP
いかが
最新
情報
こちら
プログラミング
効率
的
方法
人工
知能
活躍
今
LISP
成り立ち
|
Tech
2
GO**************************************単語
記事
:
LISP
(
概
)
(
LIS
(
P
'(
e
r
))
(
方
'(
言
))
(
処
(
理
系
))
(
関
(
連
'(
動
)
画
))
(((
)
(
()
))
(
'('(
ょ
)
'(
)
'(
)
'())
'(
)))
(
関
(
連
(
項
'(
目
))))
記事
掲示板
最近
絵
カキコ
記事
掲示板
最近
投稿
ピコカキコ
LISP
スレ
'(
文
法
)
Lisp
-
1
Lisp
-
2
Emacs
Lisp
Scheme
Common
Lisp
Clojure
Arc
(
)
未来
検索
ブラジル
運営
言葉
記事
閲覧
編集
コメント
サイト
06
/
21
:
今週
百科
HOT
ワード
2017
/
06
/
14
-
2017
/
06
/
20
テロ
等
準備
罪
ファック
ひぐらし
頃
06
/
20
:
今週
扉絵
オススメピコ
オススメ
記事
更新
2017
/
06
/
20
06
/
14
:
今週
百科
HOT
ワード
2017
/
06
/
07
-
2017
/
06
/
13
フレンズ
ん
...」「
Undertale
06
/
13
:
今週
扉絵
オススメピコ
オススメ
記事
更新
2017
/
06
/
13
06
/
07
:
今週
百科
HOT
ワード
2017
/
05
/
31
-
2017
/
06
/
06
堀江
晶
太
kemu
フレンズ
項
目
プログラミング
言語
記述
声優
ユニット
LISP
声優
ユニット
参照
項
目
検閲
一部
文章
検閲
場合
LISP
括弧
山
プログラミング
言語
神
パソコン
父
天地
創造
道
具
建材
一般人
名前
L
o
ts
of
I
nsa
ne
S
tup
id
P
ar
ent
he
ses
L
IS
t
P
r
oc
ess
i
ng
省略
歴史
1958
年
当時
MI
T
ジョン
マッ
カー
シー
発明
プログラミング
言語
2
番
目
(
最古
FORTRAN
1957
年
)
初
関数
型
プログラミング
言
語
ガベージコレクション
ファースト
クラス
関数
レ
キシ
カル
クロージャ
いち
導入
言
語
ため
現存
プログラミング
言語
影
響
非常
単純
ため
粋
LISP
実装
すべて
プログラミング
言語
実装
可
能
リスト
書き方
先頭
要素
動画
二
要素
コミュニティ
三
要素
百科
(
動画
コミュニティ
百科
)
これ
S
式
(
sym
b
ol
ic
exp
r
ess
ion
)
ポーランド
記法
評価
(
eva
l
:
eva
l
ua
tion
)
動画
関数
コミュニティ
百科
2
引数
もの
計算
命令
記述
引数
場合
先頭
命令
こと
ため
シングル
クオーテーション
必要
空
リスト
()
nil
(
non
e
英語
表現
)
偽
値
偽
値
nil
値
真
他
LISP
必須
命令
以下
これら
チューリング
完全
実現
現実
これ
実用
一般
様々
命令
追加
方言
方言
下記
項
参照
こと
LISP
者
こと
LISP
er
Lisp
er
スーパー
ス
リム
日
安心
LISP
必要
要素
実用
的
ため
拡
張
分野
ごと
特殊
化
様々
方言
別
LISP
er
同士
仲
わけ
Lisp
-
1
Lisp
-
2
論争
Com
mon
Lisp
er
Scheme
r
dis
Scheme
r
fu
nc
all
#
'
ゴミ箱
R
6
RS
Scheme
策定
Scheme
界
仲
わけ
Lisp
方言
分類
とき
Lisp
-
1
Lisp
-
2
区別
こと
関数
変数
名前
空間
共通
の
Lisp
-
1
別々
の
Lisp
-
2
名前
空間
1
の
Lisp
-
1
(
Scheme
Clojure
)
2
の
Lisp
-
2
(
Com
mon
Lisp
)
簡単
?
文句
世界
LISP
LISP
世界
人気
テキスト
エディタ
ひとつ
Emacs
方言
方言
処
理系
搭載
こと
Emacs
非常
拡
張
性
1975
年
考案
言
語
機
能
コンパクト
さ
重視
黒板
動作
定評
多く
後続
言
語
影
響
現行
規格
R
6
RS
策定
際
Sus
sm
an
キレ
処
理系
開発
者
軒並み
反対
対抗
規格
ER
R
5
RS
わや
暗黒
時代
到来
黒
歴史
演出
1980
年代
策定
1994
年
正式
規格
制定
実用
性
重視
仕様
人間
C
++
仕様
巨大
さ
複雑
さ
戦士
ひとり
Scheme
対照
的
それ
以前
LISP
影
響
関数
名前
多く
従来
もの
産業
界
影
響
コンパイラ
最適
化
制御
ステップ
実行
ブレーク
ポイント
実用
的
機
能
仕様
定義
2007
年
登場
コーヒー
国
新た
刺客
設計
者
金
ニート
R
ic
h
H
ick
ey
Java
仮想
マシン
上
動作
Java
連携
さ
ソフトウェア
トラ
ン
ザク
ショナル
メモリ
並行
コンピュー
ティ
ング
特徴
データ
構造
イミュータブル
副作用
関数
型
寄り
設計
パターン
マッチ
ング
要素
柔軟
2001
年
開発
2008
年
最初
リリース
こちら
本当
金持ち
構文
木
要素
最小限
コンセプト
大胆
変更
文法
導入
LISP
コミュニティ
中
前述
コンセプト
文法
柔軟
方針
LISP
表記
の
正式
オリジナル
LISP
全て
文字
表記
方言
Lisp
表記
話
ニコスクリプト
LISP
処
理系
注
非常
解説
作者
魔法
言
語
リリカ
ル
Lisp
開発
者
Shibuya
.
lisp
(
渋谷
中心
Lisp
コミュニティ
)
定期
的
開催
テクニカル
トーク
様子
動画
こと
スポンサー
リンク
LISP
(
リスプ
)
[
単語
記事
]
-
百科**************************************lisp
MODERATORS
get
the
best
of
reddit
delivered
once
a
week
use
the
following
search
parameters
to
narrow
your
results
:
e
.
g
.
subreddit
:
aww
site
:
imgur
.
com
dog
see
the
search
faq
for
details
.
advanced
search
:
by
author
subreddit
...
40
users
here
now
A
subreddit
for
the
Lisp
family
of
programming
languages
.
Other
Lisp
related
subreddits
:
Common
Lisp
Language
References
Tools
Tutorials
/
FAQs
Useful
Lisp
resources
:
Search
Engines
Free
Lisp
Books
/
Papers
Implementations
Events
Help
running
Interlisp
-
D
in
a
VM
(
self
.
lisp
)
submitted
2
hours
ago
*
by
undershirt
Hy
0
.
13
.
0
released
(
github
.
com
)
submitted
16
hours
ago
by
Kodiologist
Exploring
distributed
designs
with
Erlangen
:
Kademlia
(
mr
.
gy
)
submitted
1
day
ago
by
mrottenkolber
'(
ccl
)
Stumbled
across
this
comparison
of
Common
Lisp
to
Coq
which
feels
rather
apples
-
vs
-
oranges
to
me
(
unless
"
Common
Lisp
"
is
intended
to
mean
"
ACL
2
"
or
something
)
....
(
hammerprinciple
.
com
)
submitted
3
days
ago
by
flexibeast
What
is
the
concrete
difference
between
(:
key
value
)
presentation
styles
(
if
any
)?
(
self
.
lisp
)
submitted
3
days
ago
by
Friendeee
How
was
Lisp
edited
in
the
80
s
and
90
s
?
(
self
.
lisp
)
submitted
3
days
ago
by
undershirt
Pushing
Pixels
with
Lisp
-
Episode
5
-
Basic
Lighting
(
youtu
.
be
)
submitted
3
days
ago
by
Baggers
_
ELS
2017
April
3
-
4
Vrije
Universiteit
Brussel
Belgium
-
YouTube
(
youtube
.
com
)
submitted
4
days
ago
by
lispm
Never
worked
with
hardware
before
is
this
worthwhile
to
look
into
?
(
ulisp
.
com
)
submitted
3
days
ago
by
Kawakaze
_
What
is
your
favorite
feature
of
Arc
LISP
?
(
self
.
lisp
)
submitted
3
days
ago
by
ac
1235
Pushing
Pixels
with
Lisp
-
Episode
5
-
Basic
Lighting
-
Streaming
on
Twitch
Wednesday
6
pm
UTC
(
self
.
lisp
)
submitted
5
days
ago
by
Baggers
_
Arc
LISP
opinions
(
self
.
lisp
)
submitted
5
days
ago
by
ac
1235
Trial
Study
Session
No
.
1
-
Engine
Internals
&
amp
;
You
(
youtube
.
com
)
submitted
7
days
ago
by
Shinmera
Any
news
regarding
Quicklisp
development
after
the
fundraiser
?
(
self
.
lisp
)
submitted
8
days
ago
by
understanding
23
Pushing
Pixels
with
Lisp
-
Episode
4
-
Rendering
Basics
(
youtu
.
be
)
submitted
10
days
ago
by
Baggers
_
New
name
for
...))))))))
(
self
.
lisp
)
submitted
11
days
ago
by
kazkylheku
What
'
s
faster
?
This
regular
function
or
this
higher
-
order
function
?
(
self
.
lisp
)
submitted
11
days
ago
by
es
2
a
McCLIM
progress
report
#
8
.
(
common
-
lisp
.
net
)
submitted
12
days
ago
by
dk
_
jackdaniel
Can
we
have
a
unusually
nice
debate
?
"
JVM
Lisp
Duel
–
Clojure
vs
.
ABCL
"
(
self
.
lisp
)
submitted
12
days
ago
by
Friendeee
Armed
Bear
Common
Lisp
1
.
5
.
0
released
(
mailman
.
common
-
lisp
.
net
)
submitted
13
days
ago
by
pdp
10
Trial
Study
Session
Next
Saturday
17
th
of
June
(
reader
.
tymoon
.
eu
)
submitted
13
days
ago
by
lispm
Pushing
Pixels
with
Lisp
-
Episode
4
-
Rendering
Basics
-
Streaming
on
Twitch
Wednesday
6
pm
UTC
(
self
.
lisp
)
submitted
12
days
ago
by
Baggers
_
The
syntax
of
Lisp
programs
...
(
self
.
lisp
)
submitted
13
days
ago
by
dizzy
_
lizzy
RESTAS
:
passing
arguments
to
pages
with
REDIRECT
?
(
self
.
lisp
)
submitted
14
days
ago
by
Taikal
Stream
classes
for
Common
Lisp
(
github
.
com
)
submitted
14
days
ago
by
thoxdg
Use
of
this
site
constitutes
acceptance
of
our
User
Agreement
and
Privacy
Policy
.
©
2017
reddit
inc
.
All
rights
reserved
.
REDDIT
and
the
ALIEN
Logo
are
registered
trademarks
of
reddit
inc
.
Rendered
by
PID
25197
on
app
-
498
at
2017
-
06
-
25
10
:
39
:
15
.
715982
+
00
:
00
running
3522178
country
code
:
JP
.
Lisp**************************************無料
エディター
Brackets
恋
Brackets
インストール
方法
デフォルト
状態
ところ
まとめ
おすすめ
記事
無料
エディター
Brackets
恋
コメント
ん
無料
インストール
瞬間
日本語
表示
コード
開始
タグ
終了
タグ
ハイライト
表示
CSS
クイック
編集
色
クイック
編集
ホバービュー
ライブ
プレビュー
機能
拡張
豊富
取得
簡単
テーマ
豊富
設定
手軽
WordPress
開発
そう
Brackets
おすすめ
拡張
40
個
Brackets
WordPress
開発
登録
PHP
スニペット
まとめ
Brackets
エディタ
設定
複数
PC
環境
同期
方法
プログラミング
フォント
Source
Han
Code
JP
Windows
Sublime
Text
方法
Adobe
エディター
Brackets
テキスト
D
D
移動
よう
設定
方法
WEB
制作
向け
ブラウザ
Blisk
瞬間
恋
プログラマ
向け
メモアプリ
Boostnote
便利
Markdown
メモ
スニペット
管理
HTML
見出し
CSS
本
目次
よう
連
番
方法
WEB
開発
者
向け
ブラウザ
Blisk
Chrome
拡張
まとめ
クリック
一
発
既存
サイト
ワイヤー
フレーム
作成
ブックマークレット
Wirify
コメント
コメント
キャンセル
サイト
内
検索
新着
記事
無料
テーマ
Simplicity
Amazon
ブログパーツ
アーカイブ
カテゴリー
最近
コメント
カテゴリ
別
新着
記事
固定
ページ
カテゴリー
アーカイブ
ログ
コト
モノ
紹介
フォロー
2016
/
10
/
7
Brackets
5
シェア
先日
Adobe
提供
無料
開発
エディター
Brackets
僕
これ
Wordpress
テーマ
開発
恋
エディター
キャッチフレーズ
おなじみ
Sublime
Text
3
利用
Sublime
Text
キャッチフレーズ
通り
エディター
Brackets
インストール
瞬間
これ
Sublime
Text
時
衝撃
Brackets
Sublime
Text
同様
拡張
様々
機能
追加
よう
今回
デフォルト
機能
部分
紹介
目次
Brackets
HTML
CSS
JavaScript
開発
オープンソースコードエディター
Windows
Mac
利用
Adobe
Brackets
HTML
CSS
JavaScript
用
C
系
PHP
Ruby
Python
他
37
言語
シンタックス
ハイライト
用意
メジャー
言語
問題
利用
無料
うえ
導入
簡単
デフォルト
日本語
対応
WEB
制作
勉強
方
うってつけ
エディター
テーマ
見た目
変更
拡張
機能
補強
WEB
初学
者
上級
者
カバー
エディター
初期
設定
簡単
以下
Windows
方法
Brackets
ファイル
ダウンロード
ダウンロード
ファイル
以下
よう
インストーラー
英語
インストーラー
特別
設定
不要
場合
Next
インストール
Brackets
起動
以下
よう
日本語
環境
日本人
母国
語
利用
ため
余分
初期
設定
必要
の
手軽
Brackets
デフォルト
状態
Sublime
Text
便利
機能
以下
Brackets
何
これ
興奮
機能
紹介
何
無料
これ
エディター
の
Sublime
Text
無料
使用
購入
ダイアログ
表示
思い
の
僕
購入
利用
無料
機能
エディター
Atom
の
個人
的
Brackets
方
好み
Brackets
インストール
30
秒
簡単
もの
インストール
終了
後
デフォルト
状態
メニュー
全て
日本語
化
利用
よう
拡張
テーマ
インストール
よう
Sublime
Text
パッケージ
拡張
インストール
手順
必要
Brackets
インストール
状態
それ
日本語
化
Sublime
Text
結構
作業
必要
Brackets
日本語
化
作業
時間
0
デフォルト
日本語
IME
対応
Brackets
デフォルト
状態
コード
よう
CSS
コード
HTML
コード
PHP
function
if
文
展開
エディター
これ
もの
Sublime
Text
デフォルト
もの
これ
当分
利用
必要
部分
便利
Brackets
デフォルト
開始
タグ
終了
タグ
開始
カッコ
終了
カッコ
ハイライト
表示
タグ
場合
カッコ
場合
これ
範囲
確認
さ
段違い
作業
効率
HTML
要素
ID
クラス
右
クリック
クイック
編集
選択
Ctrl
+
E
OK
編集
箇所
直下
クイック
編集
ウィンドウ
スタイル
変更
こと
場所
必要
CSS
ファイル
必要
機能
心
CSS
色
変更
簡単
色
部分
マウス
カーソル
色
こと
カラー
コード
部分
右
クリック
クイック
編集
選択
Ctrl
+
E
OK
直下
カラーピックツール
表示
色
選択
マウス
カーソル
画像
ファイル
文字
列
上
画像
ポップアップ
表示
コード
これ
画像
便利
Brackets
編集
瞬間
変更
状態
ブラウザ
確認
ライブ
プレビュー
機能
デフォルト
搭載
CSS
編集
瞬間
ブラウザ
プレビュー
表示
右
サイド
バー
拡張
機能
マネージャー
ボタン
拡張
インストール
こと
かなり
数
便利
拡張
機能
数
の
600
種類
以上
よう
気
インストール
簡単
キーワード
検索
結果
インストール
ボタン
よう
めちゃくちゃ
管理
簡単
WordPress
向け
Brackets
拡張
以下
テーマ
数
豊富
感じ
記事
時点
180
以上
テーマ
エディター
上
インストール
よう
インストール
方法
拡張
メイン
メニュー
表示
テーマ
選択
テーマ
設定
ダイアログ
現在
テーマ
利用
テーマ
選択
僕
暗色
系
テーマ
ほう
Monokai
系
テーマ
Brackets
テーマ
以下
スクリーン
ショット
好み
もの
こと
よう
Brackets
デフォルト
状態
エディター
その他
ところ
紹介
これ
いろいろ
機能
追加
拡張
600
以上
テーマ
百
数
十
いくら
機能
補強
可能
1
難点
拡張
インストール
起動
動作
正直
感想
これ
無料
ん
感じ
エディター
先日
ん
Sublime
Text
Brackets
どちら
メイン
エディター
そう
拡張
勧め
以下
Pickup
!
無料
会計
ソフト
MF
クラ
ウド
確定
申告
零細
個人
事業
主
神
ツール
の
シェア
フォロー
@
MrYhira
さん
フォロー
!
function
(
d
s
id
){
var
js
fjs
=
d
.
getElementsByTagName
(
s
)[
0
p
=/^
http
:/.
test
(
d
.
location
)?'
http
':'
https
';
if
(!
d
.
getElementById
(
id
)){
js
=
d
.
createElement
(
s
);
js
.
id
=
id
;
js
.
src
=
p
+'://
platform
.
twitter
.
com
/
widgets
.
js
';
fjs
.
parentNode
.
insertBefore
(
js
fjs
);}}(
document
'
script
'
twitter
-
wjs
');
Adobe
製
エディター
Brackets
Wordpress
向け
お薦め
拡張
機能
Brackets
Sublime
Text
手軽
拡張
パッケージ
こと
よう
記事
Wordpress
テーマ
カスタマイズ
利用
スニペット
集
頻度
もの
Brackets
各種
拡張
組み合わせ
使用
作業
効率
記事
Adobe
提供
無料
エディター
Brackets
設定
Dropbox
複数
環境
間
同期
方法
紹介
1
Brackets
設定
変更
他
Brackets
同様
設定
反映
記事
アドビ
オープン
ソース
開発
Source
Han
Code
JP
源
角
ゴシック
Code
JP
Windows
使い方
Sublime
Text
Brackets
使い方
紹介
記事
アドビ
無料
エディター
Brackets
テキスト
マウス
ドラッグ
&
amp
;
ドロップ
移動
設定
方法
メニュー
デバッグ
環境
設定
ファイル
選択
JSON
形式
設定
必要
記事
WEB
制作
Wordpress
カスタマイズ
WEB
開発
者
専用
ブラウザ
Blisk
便利
おすすめ
紹介
ローカル
ファイル
編集
ブラウザ
オート
リフレッシュ
こと
記事
Markdown
記法
装飾
メモ
手軽
ソース
コード
スニペット
保存
プログラマ
用
ノートアプリ
紹介
記事
CSS
自動的
見出し
連
番
方法
紹介
本
見出し
よう
章
文章
とき
記事
WEB
制作
用
ブラウザ
Blisk
利用
便利
おすすめ
WEB
制作
拡張
紹介
記事
サイト
モックアップ
ワイヤ
フレーム
手軽
作成
こと
Wirify
紹介
有料
版
OmniGraffle
Balsamiq
Visio
SVG
形式
エクスポート
こと
記事
ブラウザ
手軽
チェック
正規
表現
テスト
ツール
まとめ
WordPress
開発
そう
Brackets
おすすめ
拡張
40
個
記事
brackets
ダウンロード
非常
紹介
気
ん
dropbox
オンライン
ストレージ
使用
他
PC
共有
こと
可能
の
僕
最近
の
無料
エディター
dropbox
オンライン
ストレージ
使用
他
PC
共有
こと
可能
の
拡張
みたい
もの
こと
Dropbox
extension
for
Brackets
イメージ
感じ
http
://
qiita
.
com
/
ma
_
me
/
items
/
f
3
fe
90
e
5185
bddf
68
f
12
シンボリックリンク
作成
拡張
機能
共有
こと
一つ
PC
必死
拡張
他
PC
笑
方法
ん
Brackets
設定
ところ
Windows
以下
位置
中身
幾つ
シンボリックリンク
共有
の
C
:\
Users
\
ユーザー
名
\
AppData
\
Roaming
\
Brackets
拡張
の
以下
パス
同期
の
C
:\
Users
\
ユーザー
名
\
AppData
\
Roaming
\
Brackets
\
extensions
メールアドレス
公開
こと
*
欄
必須
項目
名前
*
メールアドレス
*
ウェブサイト
シンプル
無料
Wordpress
テーマ
自作
簡素
好き
人
おすすめ
Simplicity
配布
無料
エディター
Brackets
恋**************************************Brackets
Blog
Announcing
Brackets
1
.
9
release
Brackets
2017
Survey
:
Results
Brackets
2017
Web
Tools
Survey
Brackets
1
.
8
is
now
available
Welcome
to
our
new
committers
!
Brackets
1
.
7
Now
Available
Including
64
Bit
Mac
!
Update
about
Extract
for
Brackets
(
Preview
)
New
Committer
–
Swagatam
Mitra
Go
Get
Brackets
1
.
5
Update
from
the
Adobe
Brackets
Team
Reverse
Inspect
in
Live
Preview
Replace
-
all
in
Find
&
amp
;
Replace
Sort
extensions
based
on
downloads
and
last
publish
date
Change
language
mode
in
an
unsaved
untitled
document
GitHub
Organization
support
for
Brackets
extensions
Geography
Age
Group
Organization
Role
Popular
JS
Frameworks
used
by
developers
Which
Build
system
do
they
use
?
Which
CSS
processing
tool
do
they
prefer
?
How
many
of
them
use
Design
Tools
?
What
are
they
using
the
design
tools
for
?
Which
Design
Tools
are
they
using
(
Top
10
)
?
What
are
the
services
they
pay
for
?
We
re
delighted
to
announce
Brackets
1
.
9
release
an
update
that
is
packed
with
features
!
As
we
d
mentioned
some
time
ago
we
re
focused
on
innovating
and
delivering
regular
updates
to
Brackets
.
Download
the
latest
version
here
.
In
this
update
you
can
take
advantage
of
:
Most
modern
-
day
web
developers
work
with
a
multi
-
monitor
set
-
up
where
they
re
writing
code
on
one
and
previewing
design
changes
real
-
time
on
a
browser
on
another
screen
.
Connecting
these
2
distinct
operations
is
essential
to
a
boost
productivity
of
a
developer
.
With
Reverse
Inspect
a
developer
can
now
quickly
inspect
his
code
by
clicking
on
elements
in
the
browser
and
have
corresponding
chunks
of
code
highlighted
inside
of
Brackets
.
Along
with
the
Batch
option
to
selectively
replace
you
can
now
use
the
Replace
-
all
function
to
replace
all
search
results
at
once
.
The
Brackets
Extension
Manager
now
displays
download
count
for
listed
extensions
.
And
also
the
Extensions
can
now
be
sorted
based
on
download
count
or
published
date
in
Available
and
Themes
tab
.
You
can
now
change
language
mode
for
Untitled
Documents
.
To
its
end
Brackets
provides
Code
Colors
and
Hints
based
on
the
language
mode
that
is
selected
for
an
untitled
document
.
GitHub
Organizations
can
now
publish
and
own
Brackets
extensions
.
All
public
owners
who
re
part
of
the
organization
can
update
extensions
.
See
the
complete
list
of
fixes
and
enhancements
in
this
version
.
No
Responses
We
recently
conducted
a
survey
among
Brackets
users
.
It
was
open
for
a
limited
time
and
we
had
2500
+
participants
.
As
promised
we
are
sharing
what
we
learned
.
We
had
participants
from
130
countries
.
64
%
of
the
participants
are
less
than
30
years
of
age
.
Most
Brackets
users
are
Freelancers
or
Self
-
Employed
.
Most
of
the
participants
identified
themselves
with
the
title
Full
Stack
Web
Developer
.
jQuery
continues
to
be
the
most
popular
framework
.
42
%
of
the
participants
use
build
tools
.
56
%
of
the
participants
use
a
CSS
processing
tool
.
60
%
of
the
participants
use
design
tool
.
We
thank
all
Brackets
users
who
participated
in
this
survey
.
No
Responses
As
web
technology
continues
to
rapidly
evolve
tools
and
web
developers
are
challenged
to
stay
ahead
of
the
curve
–
a
goal
seemingly
insurmountable
.
Understanding
the
evolution
becomes
a
key
factor
to
achieve
this
goal
and
we
are
constantly
trying
to
better
understand
you
.
To
that
end
we
re
launching
the
2017
Brackets
Web
Tools
survey
to
profile
and
understand
you
and
all
of
the
apps
&
amp
;
services
that
you
use
.
Please
take
part
in
this
survey
to
help
us
understand
you
and
your
world
of
web
development
better
!
The
results
of
the
survey
would
be
published
on
the
Brackets
blog
.
Start
the
Survey
!!
No
Responses
We
just
released
Brackets
1
.
8
.
Download
it
from
here
.
Brackets
has
gained
incredible
momentum
in
the
last
few
months
.
Almost
800
000
people
are
now
using
Brackets
every
month
.
Our
contributors
have
played
a
major
role
in
making
sure
it
evolves
as
the
leading
code
editor
for
web
developers
.
The
current
version
has
a
big
list
of
contributions
from
our
community
.
Special
thanks
to
Martin
Zagora
for
updating
the
Node
version
to
6
.
3
.
1
.
You
can
see
the
complete
list
of
fixes
and
enhancements
on
the
wiki
.
The
Brackets
team
at
Adobe
had
been
focussing
on
bringing
in
Brackets
as
the
code
engine
within
Dreamweaver
during
the
last
9
months
.
The
team
has
done
an
incredible
job
and
it
s
being
appreciated
by
the
Dreamweaver
users
.
Now
that
the
job
is
done
we
are
back
with
the
intent
to
innovate
on
features
that
the
Brackets
community
would
love
.
I
cannot
wait
to
announce
our
1
.
9
feature
set
.
No
Responses
We
are
excited
to
introduce
the
newest
committers
to
the
Brackets
community
.
I
will
let
them
introduce
themselves
.
Shubham
Yadav
Hey
guys
I
joined
the
Adobe
Dreamweaver
team
as
a
Software
Developer
this
summer
straight
out
of
college
.
But
my
relationship
with
Brackets
started
way
before
that
.
I
was
lucky
to
grab
an
internship
at
Adobe
during
the
first
half
of
this
year
.
During
my
time
as
an
intern
I
worked
a
lot
with
Brackets
both
as
an
application
and
as
an
open
source
project
.
I
just
loved
it
.
It
helped
me
a
lot
in
understanding
the
way
open
source
community
works
together
to
create
a
full
fledged
application
.
I
was
introduced
to
different
technologies
and
frameworks
like
nodejs
Grunt
CEF
etc
.
along
with
the
best
practices
and
standards
of
the
Brackets
open
source
community
.
Apart
from
that
I
have
prior
experience
with
C
JavaScript
HTML
CSS
etc
.
As
an
individual
I
am
passionate
about
developing
things
that
affect
the
users
directly
and
things
that
provide
a
creative
outlet
.
I
am
also
an
avid
reader
and
sometimes
dabble
with
writing
.
I
am
really
excited
to
start
this
new
journey
and
hope
to
learn
new
stuff
.
Naveen
Choudhary
I
am
really
passionate
about
learning
new
Technologies
.
I
am
currently
working
with
the
Dreamweaver
team
.
I
started
contributing
to
open
-
source
in
2016
@
Brackets
during
my
Internship
at
Adobe
.
Since
I
started
using
Brackets
I
loved
it
for
the
simplicity
and
ease
of
coding
with
powerful
features
.
I
have
worked
with
technologies
that
includes
frameworks
in
C
Javascript
Zend
(
php
-
src
Hadoop
etc
.
Apart
from
computers
I
love
Bikes
Road
-
trips
Saurabh
Kathpalia
I
am
really
passionate
about
solving
computational
and
analytical
problems
.
I
am
currently
working
with
the
Dreamweaver
team
.
I
started
contributing
to
open
-
source
in
2014
and
after
that
I
worked
as
Software
Developer
for
MoinMoin
Wiki
(
Python
Software
Foundation
)
in
Google
Summer
of
Code
2014
in
which
I
worked
simultaneously
on
2
projects
(
mainly
in
Python
and
JavaScript
)
and
also
worked
as
a
Mentor
for
2
projects
in
Google
Summer
of
Code
2015
.
I
have
also
worked
in
the
frontend
team
at
housing
.
com
where
I
made
a
360
degree
virtual
tour
of
a
house
in
which
I
was
introduced
to
technologies
like
WebGL
(
Three
.
js
CoffeeScript
and
Webpack
.
I
started
using
brackets
5
months
back
and
since
then
I
have
loved
it
for
its
simplicity
intuitive
UI
and
extensibility
.
Please
join
me
in
welcoming
all
the
newest
committers
.
Developers
love
Brackets
and
we
are
committed
to
making
Brackets
the
best
coding
editing
experience
.
4
Responses
The
team
just
released
Brackets
1
.
7
so
head
over
to
brackets
.
io
to
download
it
!
As
we
mentioned
last
year
the
team
has
been
busy
working
on
integrating
Brackets
as
the
core
code
experience
inside
Dreamweaver
and
that
s
resulted
in
some
nice
features
this
release
for
Brackets
users
:
If
you
re
interested
in
checking
out
the
new
revamped
Dreamweaver
with
Brackets
integration
the
team
is
going
to
be
rolling
out
a
public
beta
very
soon
.
So
keep
an
eye
out
for
that
!
Also
this
is
going
to
be
my
last
blog
post
as
the
Brackets
product
manager
.
I
m
turning
the
reins
over
to
the
fantastic
Brian
Thomas
who
is
leading
all
of
Adobe
s
web
tools
.
It
s
been
a
pleasure
to
be
part
of
the
Brackets
project
for
so
long
and
I
know
Brackets
is
in
the
great
hands
of
a
passionate
engineering
team
and
PM
.
No
Responses
Some
of
you
are
familiar
with
the
Extract
for
Brackets
extension
a
tool
used
to
work
with
PSDs
shared
via
Creative
Cloud
.
As
announced
in
this
post
on
the
Creative
Cloud
blog
today
we
are
discontinuing
the
extension
effective
on
June
28
due
to
low
usage
.
Please
note
that
any
PSD
files
you
ve
used
with
Extract
will
still
be
available
to
access
or
share
within
the
Creative
Cloud
Assets
service
.
To
continue
using
Extract
functionality
we
suggest
checking
out
the
Extract
panel
in
Dreamweaver
CC
.
Thank
you
for
your
feedback
and
support
during
this
process
.
No
Responses
This
is
WAY
long
overdue
as
he
has
already
been
quite
busy
making
Brackets
better
but
I
want
to
formally
introduce
our
newest
Brackets
committer
Swagatam
Mitra
.
Swagatam
was
responsible
for
the
split
view
(
same
document
)
feature
and
improving
JavaScript
hinting
in
Release
1
.
6
.
And
here
s
some
more
about
Swagatam
in
his
own
words
:
I
am
a
software
developer
by
profession
.
Started
carrier
as
a
Data
warehouse
and
Business
Intelligence
analyst
and
then
moved
on
to
server
side
programming
in
Java
.
After
a
few
years
I
started
embedded
programming
for
Set
top
boxes
and
followed
it
for
a
while
.
I
got
introduced
to
web
technologies
and
open
source
in
2014
and
eventually
it
was
Brackets
to
start
with
.
I
really
love
Brackets
for
its
simplicity
and
extendibility
.
Got
hooked
onto
web
technologies
ever
since
and
to
learn
DOM
manipulation
and
styling
developed
an
extension
html
-
designer
on
Brackets
for
designing
web
pages
/
applications
using
HTML
/
CSS
.
Apart
from
Computers
I
love
automobiles
and
photography
.
You
can
of
course
find
him
on
Github
and
also
on
Twitter
.
Please
join
me
in
giving
him
a
warm
welcome
.
No
Responses
As
of
today
Brackets
1
.
5
is
available
for
download
.
As
we
mentioned
last
week
the
Adobe
engineers
on
Brackets
are
working
on
bringing
Brackets
into
Dreamweaver
as
the
code
surface
and
we
expect
progress
on
the
open
source
project
to
be
slower
as
that
happens
.
But
we
still
hope
to
do
regular
releases
and
our
community
is
fantastic
so
a
lot
of
the
work
that
will
be
in
those
releases
will
be
community
driven
.
Brackets
1
.
5
is
a
great
example
of
that
.
This
version
of
Brackets
adds
the
ability
to
fold
selected
text
via
code
folding
and
includes
some
major
performance
enhancements
to
searching
.
Brackets
now
also
gives
you
CSS
code
hints
inside
of
style
tags
in
PHP
documents
and
we
ve
improved
the
code
hinting
performance
in
minified
files
.
We
also
fixed
a
couple
of
issues
with
El
Capitan
and
a
freezing
/
crashing
bug
.
You
can
see
the
full
list
of
fixes
and
enhancements
on
the
wiki
.
And
a
big
thank
you
goes
out
to
everyone
who
contributed
to
this
release
:
No
Responses
We
re
incredibly
proud
of
the
momentum
that
Brackets
continues
to
have
.
Over
350
000
people
are
using
Brackets
every
month
.
There
have
been
283
contributors
to
the
project
and
users
have
installed
890
different
extensions
.
The
community
has
also
become
even
more
active
in
the
project
over
the
past
couple
of
months
.
We
ll
soon
be
releasing
Brackets
1
.
5
which
has
a
number
of
fixes
and
enhancements
that
were
contributed
by
the
community
.
The
Brackets
team
at
Adobe
has
been
spending
the
past
couple
of
months
talking
a
lot
about
how
we
can
continue
to
move
the
project
forward
.
We
all
believe
that
Brackets
is
the
absolute
best
code
editor
out
there
for
the
web
and
the
success
of
Brackets
has
led
to
some
very
good
discussion
about
how
Adobe
can
make
our
commercial
tools
better
especially
our
flagship
web
tool
Dreamweaver
.
We
understand
that
any
good
web
tool
needs
to
have
a
powerful
code
editor
at
its
core
.
After
discussing
how
we
recreate
Brackets
features
in
Dreamweaver
we
realized
it
would
be
more
logical
to
use
Brackets
as
the
code
editor
for
Dreamweaver
and
are
going
to
start
working
on
that
plan
.
This
won
t
have
any
impact
on
how
Adobe
will
support
the
open
source
project
.
Brackets
itself
will
remain
100
%
free
and
open
source
.
Adobe
will
continue
to
maintain
a
strong
engineering
team
on
the
project
and
actively
engage
and
support
the
community
.
We
will
also
continue
to
add
features
to
Brackets
and
as
we
do
the
integration
work
we
ll
be
adding
a
number
of
core
features
to
the
open
source
project
.
But
it
will
also
mean
that
overall
progress
may
be
slow
in
the
short
term
as
the
team
works
on
both
the
integration
work
and
the
core
product
.
As
performance
issues
or
bugs
come
up
and
get
fixed
while
working
on
the
Dreamweaver
integration
we
plan
to
fix
those
in
Brackets
directly
and
contribute
them
back
to
the
open
source
project
.
Once
the
integration
work
is
done
which
should
be
in
the
next
6
-
9
months
the
development
team
will
once
again
be
focusing
on
Brackets
.
We
will
continue
to
add
features
and
improvements
to
Brackets
which
will
then
make
their
way
into
Dreamweaver
by
virtue
of
the
open
source
project
.
We
will
be
working
directly
in
the
core
Brackets
codebase
not
a
fork
so
that
features
and
enhancements
benefit
the
community
as
well
as
Dreamweaver
.
The
Adobe
team
continues
to
be
both
humbled
and
inspired
by
the
way
the
community
contributes
to
Brackets
and
moves
the
project
forward
.
Brackets
has
always
belonged
to
the
community
and
that
community
has
never
been
stronger
than
it
is
now
.
We
are
excited
about
this
new
phase
because
it
allows
the
Adobe
team
to
spend
time
on
Brackets
while
also
making
an
impact
on
Adobe
s
commercial
tools
.
Be
on
the
look
out
for
the
1
.
5
release
over
the
next
couple
of
weeks
.
It
s
a
great
release
with
a
number
of
enhancements
and
fixes
most
of
which
have
come
directly
from
community
contributors
.
No
Responses
Brackets
was
founded
by
Adobe
as
a
community
guided
open
source
project
to
push
web
development
editors
to
the
next
level
.
Brackets
is
released
under
the
MIT
License
.
Brackets
Blog
-
The
Free
Open
Source
Code
Editor
for
the
Web**************************************Brackets
Blog
Announcing
Brackets
1
.
9
release
Brackets
2017
Survey
:
Results
Brackets
2017
Web
Tools
Survey
Brackets
1
.
8
is
now
available
Welcome
to
our
new
committers
!
Brackets
1
.
7
Now
Available
Including
64
Bit
Mac
!
Update
about
Extract
for
Brackets
(
Preview
)
New
Committer
–
Swagatam
Mitra
Go
Get
Brackets
1
.
5
Update
from
the
Adobe
Brackets
Team
Reverse
Inspect
in
Live
Preview
Replace
-
all
in
Find
&
amp
;
Replace
Sort
extensions
based
on
downloads
and
last
publish
date
Change
language
mode
in
an
unsaved
untitled
document
GitHub
Organization
support
for
Brackets
extensions
Geography
Age
Group
Organization
Role
Popular
JS
Frameworks
used
by
developers
Which
Build
system
do
they
use
?
Which
CSS
processing
tool
do
they
prefer
?
How
many
of
them
use
Design
Tools
?
What
are
they
using
the
design
tools
for
?
Which
Design
Tools
are
they
using
(
Top
10
)
?
What
are
the
services
they
pay
for
?
We
re
delighted
to
announce
Brackets
1
.
9
release
an
update
that
is
packed
with
features
!
As
we
d
mentioned
some
time
ago
we
re
focused
on
innovating
and
delivering
regular
updates
to
Brackets
.
Download
the
latest
version
here
.
In
this
update
you
can
take
advantage
of
:
Most
modern
-
day
web
developers
work
with
a
multi
-
monitor
set
-
up
where
they
re
writing
code
on
one
and
previewing
design
changes
real
-
time
on
a
browser
on
another
screen
.
Connecting
these
2
distinct
operations
is
essential
to
a
boost
productivity
of
a
developer
.
With
Reverse
Inspect
a
developer
can
now
quickly
inspect
his
code
by
clicking
on
elements
in
the
browser
and
have
corresponding
chunks
of
code
highlighted
inside
of
Brackets
.
Along
with
the
Batch
option
to
selectively
replace
you
can
now
use
the
Replace
-
all
function
to
replace
all
search
results
at
once
.
The
Brackets
Extension
Manager
now
displays
download
count
for
listed
extensions
.
And
also
the
Extensions
can
now
be
sorted
based
on
download
count
or
published
date
in
Available
and
Themes
tab
.
You
can
now
change
language
mode
for
Untitled
Documents
.
To
its
end
Brackets
provides
Code
Colors
and
Hints
based
on
the
language
mode
that
is
selected
for
an
untitled
document
.
GitHub
Organizations
can
now
publish
and
own
Brackets
extensions
.
All
public
owners
who
re
part
of
the
organization
can
update
extensions
.
See
the
complete
list
of
fixes
and
enhancements
in
this
version
.
No
Responses
We
recently
conducted
a
survey
among
Brackets
users
.
It
was
open
for
a
limited
time
and
we
had
2500
+
participants
.
As
promised
we
are
sharing
what
we
learned
.
We
had
participants
from
130
countries
.
64
%
of
the
participants
are
less
than
30
years
of
age
.
Most
Brackets
users
are
Freelancers
or
Self
-
Employed
.
Most
of
the
participants
identified
themselves
with
the
title
Full
Stack
Web
Developer
.
jQuery
continues
to
be
the
most
popular
framework
.
42
%
of
the
participants
use
build
tools
.
56
%
of
the
participants
use
a
CSS
processing
tool
.
60
%
of
the
participants
use
design
tool
.
We
thank
all
Brackets
users
who
participated
in
this
survey
.
No
Responses
As
web
technology
continues
to
rapidly
evolve
tools
and
web
developers
are
challenged
to
stay
ahead
of
the
curve
–
a
goal
seemingly
insurmountable
.
Understanding
the
evolution
becomes
a
key
factor
to
achieve
this
goal
and
we
are
constantly
trying
to
better
understand
you
.
To
that
end
we
re
launching
the
2017
Brackets
Web
Tools
survey
to
profile
and
understand
you
and
all
of
the
apps
&
amp
;
services
that
you
use
.
Please
take
part
in
this
survey
to
help
us
understand
you
and
your
world
of
web
development
better
!
The
results
of
the
survey
would
be
published
on
the
Brackets
blog
.
Start
the
Survey
!!
No
Responses
We
just
released
Brackets
1
.
8
.
Download
it
from
here
.
Brackets
has
gained
incredible
momentum
in
the
last
few
months
.
Almost
800
000
people
are
now
using
Brackets
every
month
.
Our
contributors
have
played
a
major
role
in
making
sure
it
evolves
as
the
leading
code
editor
for
web
developers
.
The
current
version
has
a
big
list
of
contributions
from
our
community
.
Special
thanks
to
Martin
Zagora
for
updating
the
Node
version
to
6
.
3
.
1
.
You
can
see
the
complete
list
of
fixes
and
enhancements
on
the
wiki
.
The
Brackets
team
at
Adobe
had
been
focussing
on
bringing
in
Brackets
as
the
code
engine
within
Dreamweaver
during
the
last
9
months
.
The
team
has
done
an
incredible
job
and
it
s
being
appreciated
by
the
Dreamweaver
users
.
Now
that
the
job
is
done
we
are
back
with
the
intent
to
innovate
on
features
that
the
Brackets
community
would
love
.
I
cannot
wait
to
announce
our
1
.
9
feature
set
.
No
Responses
We
are
excited
to
introduce
the
newest
committers
to
the
Brackets
community
.
I
will
let
them
introduce
themselves
.
Shubham
Yadav
Hey
guys
I
joined
the
Adobe
Dreamweaver
team
as
a
Software
Developer
this
summer
straight
out
of
college
.
But
my
relationship
with
Brackets
started
way
before
that
.
I
was
lucky
to
grab
an
internship
at
Adobe
during
the
first
half
of
this
year
.
During
my
time
as
an
intern
I
worked
a
lot
with
Brackets
both
as
an
application
and
as
an
open
source
project
.
I
just
loved
it
.
It
helped
me
a
lot
in
understanding
the
way
open
source
community
works
together
to
create
a
full
fledged
application
.
I
was
introduced
to
different
technologies
and
frameworks
like
nodejs
Grunt
CEF
etc
.
along
with
the
best
practices
and
standards
of
the
Brackets
open
source
community
.
Apart
from
that
I
have
prior
experience
with
C
JavaScript
HTML
CSS
etc
.
As
an
individual
I
am
passionate
about
developing
things
that
affect
the
users
directly
and
things
that
provide
a
creative
outlet
.
I
am
also
an
avid
reader
and
sometimes
dabble
with
writing
.
I
am
really
excited
to
start
this
new
journey
and
hope
to
learn
new
stuff
.
Naveen
Choudhary
I
am
really
passionate
about
learning
new
Technologies
.
I
am
currently
working
with
the
Dreamweaver
team
.
I
started
contributing
to
open
-
source
in
2016
@
Brackets
during
my
Internship
at
Adobe
.
Since
I
started
using
Brackets
I
loved
it
for
the
simplicity
and
ease
of
coding
with
powerful
features
.
I
have
worked
with
technologies
that
includes
frameworks
in
C
Javascript
Zend
(
php
-
src
Hadoop
etc
.
Apart
from
computers
I
love
Bikes
Road
-
trips
Saurabh
Kathpalia
I
am
really
passionate
about
solving
computational
and
analytical
problems
.
I
am
currently
working
with
the
Dreamweaver
team
.
I
started
contributing
to
open
-
source
in
2014
and
after
that
I
worked
as
Software
Developer
for
MoinMoin
Wiki
(
Python
Software
Foundation
)
in
Google
Summer
of
Code
2014
in
which
I
worked
simultaneously
on
2
projects
(
mainly
in
Python
and
JavaScript
)
and
also
worked
as
a
Mentor
for
2
projects
in
Google
Summer
of
Code
2015
.
I
have
also
worked
in
the
frontend
team
at
housing
.
com
where
I
made
a
360
degree
virtual
tour
of
a
house
in
which
I
was
introduced
to
technologies
like
WebGL
(
Three
.
js
CoffeeScript
and
Webpack
.
I
started
using
brackets
5
months
back
and
since
then
I
have
loved
it
for
its
simplicity
intuitive
UI
and
extensibility
.
Please
join
me
in
welcoming
all
the
newest
committers
.
Developers
love
Brackets
and
we
are
committed
to
making
Brackets
the
best
coding
editing
experience
.
4
Responses
The
team
just
released
Brackets
1
.
7
so
head
over
to
brackets
.
io
to
download
it
!
As
we
mentioned
last
year
the
team
has
been
busy
working
on
integrating
Brackets
as
the
core
code
experience
inside
Dreamweaver
and
that
s
resulted
in
some
nice
features
this
release
for
Brackets
users
:
If
you
re
interested
in
checking
out
the
new
revamped
Dreamweaver
with
Brackets
integration
the
team
is
going
to
be
rolling
out
a
public
beta
very
soon
.
So
keep
an
eye
out
for
that
!
Also
this
is
going
to
be
my
last
blog
post
as
the
Brackets
product
manager
.
I
m
turning
the
reins
over
to
the
fantastic
Brian
Thomas
who
is
leading
all
of
Adobe
s
web
tools
.
It
s
been
a
pleasure
to
be
part
of
the
Brackets
project
for
so
long
and
I
know
Brackets
is
in
the
great
hands
of
a
passionate
engineering
team
and
PM
.
No
Responses
Some
of
you
are
familiar
with
the
Extract
for
Brackets
extension
a
tool
used
to
work
with
PSDs
shared
via
Creative
Cloud
.
As
announced
in
this
post
on
the
Creative
Cloud
blog
today
we
are
discontinuing
the
extension
effective
on
June
28
due
to
low
usage
.
Please
note
that
any
PSD
files
you
ve
used
with
Extract
will
still
be
available
to
access
or
share
within
the
Creative
Cloud
Assets
service
.
To
continue
using
Extract
functionality
we
suggest
checking
out
the
Extract
panel
in
Dreamweaver
CC
.
Thank
you
for
your
feedback
and
support
during
this
process
.
No
Responses
This
is
WAY
long
overdue
as
he
has
already
been
quite
busy
making
Brackets
better
but
I
want
to
formally
introduce
our
newest
Brackets
committer
Swagatam
Mitra
.
Swagatam
was
responsible
for
the
split
view
(
same
document
)
feature
and
improving
JavaScript
hinting
in
Release
1
.
6
.
And
here
s
some
more
about
Swagatam
in
his
own
words
:
I
am
a
software
developer
by
profession
.
Started
carrier
as
a
Data
warehouse
and
Business
Intelligence
analyst
and
then
moved
on
to
server
side
programming
in
Java
.
After
a
few
years
I
started
embedded
programming
for
Set
top
boxes
and
followed
it
for
a
while
.
I
got
introduced
to
web
technologies
and
open
source
in
2014
and
eventually
it
was
Brackets
to
start
with
.
I
really
love
Brackets
for
its
simplicity
and
extendibility
.
Got
hooked
onto
web
technologies
ever
since
and
to
learn
DOM
manipulation
and
styling
developed
an
extension
html
-
designer
on
Brackets
for
designing
web
pages
/
applications
using
HTML
/
CSS
.
Apart
from
Computers
I
love
automobiles
and
photography
.
You
can
of
course
find
him
on
Github
and
also
on
Twitter
.
Please
join
me
in
giving
him
a
warm
welcome
.
No
Responses
As
of
today
Brackets
1
.
5
is
available
for
download
.
As
we
mentioned
last
week
the
Adobe
engineers
on
Brackets
are
working
on
bringing
Brackets
into
Dreamweaver
as
the
code
surface
and
we
expect
progress
on
the
open
source
project
to
be
slower
as
that
happens
.
But
we
still
hope
to
do
regular
releases
and
our
community
is
fantastic
so
a
lot
of
the
work
that
will
be
in
those
releases
will
be
community
driven
.
Brackets
1
.
5
is
a
great
example
of
that
.
This
version
of
Brackets
adds
the
ability
to
fold
selected
text
via
code
folding
and
includes
some
major
performance
enhancements
to
searching
.
Brackets
now
also
gives
you
CSS
code
hints
inside
of
style
tags
in
PHP
documents
and
we
ve
improved
the
code
hinting
performance
in
minified
files
.
We
also
fixed
a
couple
of
issues
with
El
Capitan
and
a
freezing
/
crashing
bug
.
You
can
see
the
full
list
of
fixes
and
enhancements
on
the
wiki
.
And
a
big
thank
you
goes
out
to
everyone
who
contributed
to
this
release
:
No
Responses
We
re
incredibly
proud
of
the
momentum
that
Brackets
continues
to
have
.
Over
350
000
people
are
using
Brackets
every
month
.
There
have
been
283
contributors
to
the
project
and
users
have
installed
890
different
extensions
.
The
community
has
also
become
even
more
active
in
the
project
over
the
past
couple
of
months
.
We
ll
soon
be
releasing
Brackets
1
.
5
which
has
a
number
of
fixes
and
enhancements
that
were
contributed
by
the
community
.
The
Brackets
team
at
Adobe
has
been
spending
the
past
couple
of
months
talking
a
lot
about
how
we
can
continue
to
move
the
project
forward
.
We
all
believe
that
Brackets
is
the
absolute
best
code
editor
out
there
for
the
web
and
the
success
of
Brackets
has
led
to
some
very
good
discussion
about
how
Adobe
can
make
our
commercial
tools
better
especially
our
flagship
web
tool
Dreamweaver
.
We
understand
that
any
good
web
tool
needs
to
have
a
powerful
code
editor
at
its
core
.
After
discussing
how
we
recreate
Brackets
features
in
Dreamweaver
we
realized
it
would
be
more
logical
to
use
Brackets
as
the
code
editor
for
Dreamweaver
and
are
going
to
start
working
on
that
plan
.
This
won
t
have
any
impact
on
how
Adobe
will
support
the
open
source
project
.
Brackets
itself
will
remain
100
%
free
and
open
source
.
Adobe
will
continue
to
maintain
a
strong
engineering
team
on
the
project
and
actively
engage
and
support
the
community
.
We
will
also
continue
to
add
features
to
Brackets
and
as
we
do
the
integration
work
we
ll
be
adding
a
number
of
core
features
to
the
open
source
project
.
But
it
will
also
mean
that
overall
progress
may
be
slow
in
the
short
term
as
the
team
works
on
both
the
integration
work
and
the
core
product
.
As
performance
issues
or
bugs
come
up
and
get
fixed
while
working
on
the
Dreamweaver
integration
we
plan
to
fix
those
in
Brackets
directly
and
contribute
them
back
to
the
open
source
project
.
Once
the
integration
work
is
done
which
should
be
in
the
next
6
-
9
months
the
development
team
will
once
again
be
focusing
on
Brackets
.
We
will
continue
to
add
features
and
improvements
to
Brackets
which
will
then
make
their
way
into
Dreamweaver
by
virtue
of
the
open
source
project
.
We
will
be
working
directly
in
the
core
Brackets
codebase
not
a
fork
so
that
features
and
enhancements
benefit
the
community
as
well
as
Dreamweaver
.
The
Adobe
team
continues
to
be
both
humbled
and
inspired
by
the
way
the
community
contributes
to
Brackets
and
moves
the
project
forward
.
Brackets
has
always
belonged
to
the
community
and
that
community
has
never
been
stronger
than
it
is
now
.
We
are
excited
about
this
new
phase
because
it
allows
the
Adobe
team
to
spend
time
on
Brackets
while
also
making
an
impact
on
Adobe
s
commercial
tools
.
Be
on
the
look
out
for
the
1
.
5
release
over
the
next
couple
of
weeks
.
It
s
a
great
release
with
a
number
of
enhancements
and
fixes
most
of
which
have
come
directly
from
community
contributors
.
No
Responses
Brackets
was
founded
by
Adobe
as
a
community
guided
open
source
project
to
push
web
development
editors
to
the
next
level
.
Brackets
is
released
under
the
MIT
License
.
Brackets
Blog
-
The
Free
Open
Source
Code
Editor
for
the
Web**************************************Lisp
アイデア
ブートストラッピング
材料
非常
言語
それ
自体
インタプリタ
観点
定義
言語
内
式
意味
インタプリタ
定義
式
データ
構造
記述
マクロ
データ
駆動
型
プログラミング
プログラミング
言語
実験
REPL
再帰
関数
ガベージコレクション
条件
式
複数
文字
変数
名
リテラル
データ
構造
恐竜
Lisp
:
Chrome
インターネット
接続
画面
Lisp
プレイ
Lisp
の
データ
コード
Emacs
Guile
Emacs
Lisp
未来
JPL
ジェット
推進
研究所
Lisp
顛末
Next
Post
Previous
Post
最近
投稿
タグ
アーカイブ
フォロー
Facebook
POSTD
プログラミング
エンジニア
トレンド
メディア
POSTD
最新
エントリ
The
Idea
of
Lisp
by
Eric
Normand
Lisp
冷蔵庫
よう
サイズ
コンピュータ
大文字
アルファベット
文字
列
括弧
並び
よう
過去
時代
こと
頭
非常
多く
括弧
オブジェクト
指向
プログラミング
作成
者
たち
Lisp
アイデア
魅了
の
アイデア
プログラミング
言語
もの
説明
こと
コンピュータ
科学
教育
Lisp
John
McCarthy
Recursive
Functions
of
Symbolic
Expressions
and
Their
Interpretation
by
Machines
Part
I
論文
世界
登場
中
McCarthy
プログラミング
多く
アイデア
導入
条件
式
if
/
then
/
else
変数
複数
文字
単語
フレーズ
場合
こと
数学
1
文字
皆さん
プログラミング
言語
2
特徴
John
McCarthy
それ
Lisp
自体
定義
アイデア
の
彼
条件
式
5
種類
基本
演算
atom
eq
cons
car
cdr
定義
これ
関数
定義
方法
想定
上
それら
それ
自身
定義
プログラミング
言語
全体
定義
別
言葉
説明
John
McCarthy
6
簡単
事柄
機械
語
それら
プログラミング
言語
の
それ
以前
登場
唯一
高級
プログラミング
言語
開発
18
人
年
歳月
Fortran
Fortran
成果
Lisp
アイデア
大変
アイデア
これら
6
もの
インタープリタ
解釈
可能
シンボル
リスト
提供
他
システム
簡単
移植
非常
カーネル
定義
これ
合意
定点
もの
他
全て
意味
それら
観点
定義
これ
言語
万能
こと
構成
的
証明
チューリング
完全
アイデア
2
部分
1
目
計算
可能
もの
計算
こと
これ
プログラミング
言語
クリア
再帰
関数
Lisp
該当
2
目
特殊
チューリングマシン
万能
他
チューリングマシン
解釈
Lisp
万能
チューリングマシン
同様
当初
それ
自身
インタプリタ
定義
それ
自身
コード
解釈
万能
言語
JavaScript
Javascript
インタプリタ
こと
それ
自身
ため
わけ
式
意味
独自
インタプリタ
こと
これ
Alan
Kay
遅延
バインディング
概念
プログラミング
知識
中
多く
前提
言語
基盤
の
意味
間違い
習熟
中
全て
こと
前提
スワップ
システム
の
式
再帰
的
リンクトリスト
記述
5
種類
基本
これら
データ
構造
解釈
こと
可能
Lisp
システム
毎回
式
解釈
代わり
機械
語
コンパイル
よう
現実
的
妥協
Lisper
非常
柔軟
カーネル
快適
作業
以下
の
Lisp
アイデア
直接
Lisp
いくつ
機能
マクロ
コード
引数
コード
関数
コード
変換
器
言語
表現
力
拡張
コンパイル
時
計算
実行
よう
Lisper
自分
作成
言語
インタプリタ
Lisp
こと
言語
ため
Lisp
ブートストラッピング
制定
の
これら
意味
DSL
(
ドメイン
特
化
言語
)
こと
Lisp
それ
自身
インタプリタ
よう
言語
代替
セマンティクス
の
最適
私
たち
プログラミング
道
がち
現在
偉大
言語
絶え間
変化
今日
言語
15
年
後
Lisp
アイデア
現時点
有望
生まれ変わり
JVM
JavaScript
動作
Clojure
以下
よう
Lisp
アイデア
あなた
好み
言語
REPL
Read
-
Eval
-
Print
-
Loop
対話
型
評価
環境
略
それ
定義
4
Lisp
構造
体
名前
あなた
お気に入り
言語
コード
入力
実行
こと
インタラクティブ
プロンプト
それ
Lisp
由来
の
1960
年
コンピュータ
科学
者
たち
再帰
関数
可能
こと
非常
コスト
当時
1
主要
言語
Fortran
頃
再帰
関数
再帰
関数
話
Lisp
ガベージコレクション
(
GC
)
最初
言語
言語
テンポラリ
オブジェクト
作成
それら
間
生存
こと
Lisp
GC
必要
主
要因
条件
式
発明
の
John
McCarthy
の
彼
Algol
条件
式
追加
よう
Algol
開発
プロジェクト
今日
言語
そこ
条件
式
前述
ここ
McCarthy
登場
以前
プログラマ
数学
1
文字
変数
名
使用
自分
お気に入り
言語
構文
配列
マップ
直接
記述
こと
括弧
それ
最初
の
Lisp
の
Alan
Kay
言葉
コンピュータ
科学
学位
取得
学生
Lisp
意義
さ
理解
Lisp
コンピュータ
科学
重要
アイデア
私
自身
卒業
時
意義
さ
理解
卒業
たくさん
読書
探求
コンピュータ
科学
適切
教養
こと
実感
ニュースレター
ご覧
私
内容
確認
こと
可能
40
年
以上
前
発表
奥行き
さ
魅了
コンピュータ
科学
プログラミング
歴史
Lisp
アイデア
数々
興味
PurelyFunctional
.
tv
Newsletter
チェック
Lisp
関数
型
プログラミング
歴史
現在
未来
考察
週刊
ニュースレター
関連
投稿
Lisp
アイデア
|
コンピュータ
サイエンス
|
POSTD**************************************Lisp
アイデア
ブートストラッピング
材料
非常
言語
それ
自体
インタプリタ
観点
定義
言語
内
式
意味
インタプリタ
定義
式
データ
構造
記述
マクロ
データ
駆動
型
プログラミング
プログラミング
言語
実験
REPL
再帰
関数
ガベージコレクション
条件
式
複数
文字
変数
名
リテラル
データ
構造
恐竜
Lisp
:
Chrome
インターネット
接続
画面
Lisp
プレイ
Lisp
の
データ
コード
Emacs
Guile
Emacs
Lisp
未来
JPL
ジェット
推進
研究所
Lisp
顛末
Next
Post
Previous
Post
最近
投稿
タグ
アーカイブ
フォロー
Facebook
POSTD
プログラミング
エンジニア
トレンド
メディア
POSTD
最新
エントリ
The
Idea
of
Lisp
by
Eric
Normand
Lisp
冷蔵庫
よう
サイズ
コンピュータ
大文字
アルファベット
文字
列
括弧
並び
よう
過去
時代
こと
頭
非常
多く
括弧
オブジェクト
指向
プログラミング
作成
者
たち
Lisp
アイデア
魅了
の
アイデア
プログラミング
言語
もの
説明
こと
コンピュータ
科学
教育
Lisp
John
McCarthy
Recursive
Functions
of
Symbolic
Expressions
and
Their
Interpretation
by
Machines
Part
I
論文
世界
登場
中
McCarthy
プログラミング
多く
アイデア
導入
条件
式
if
/
then
/
else
変数
複数
文字
単語
フレーズ
場合
こと
数学
1
文字
皆さん
プログラミング
言語
2
特徴
John
McCarthy
それ
Lisp
自体
定義
アイデア
の
彼
条件
式
5
種類
基本
演算
atom
eq
cons
car
cdr
定義
これ
関数
定義
方法
想定
上
それら
それ
自身
定義
プログラミング
言語
全体
定義
別
言葉
説明
John
McCarthy
6
簡単
事柄
機械
語
それら
プログラミング
言語
の
それ
以前
登場
唯一
高級
プログラミング
言語
開発
18
人
年
歳月
Fortran
Fortran
成果
Lisp
アイデア
大変
アイデア
これら
6
もの
インタープリタ
解釈
可能
シンボル
リスト
提供
他
システム
簡単
移植
非常
カーネル
定義
これ
合意
定点
もの
他
全て
意味
それら
観点
定義
これ
言語
万能
こと
構成
的
証明
チューリング
完全
アイデア
2
部分
1
目
計算
可能
もの
計算
こと
これ
プログラミング
言語
クリア
再帰
関数
Lisp
該当
2
目
特殊
チューリングマシン
万能
他
チューリングマシン
解釈
Lisp
万能
チューリングマシン
同様
当初
それ
自身
インタプリタ
定義
それ
自身
コード
解釈
万能
言語
JavaScript
Javascript
インタプリタ
こと
それ
自身
ため
わけ
式
意味
独自
インタプリタ
こと
これ
Alan
Kay
遅延
バインディング
概念
プログラミング
知識
中
多く
前提
言語
基盤
の
意味
間違い
習熟
中
全て
こと
前提
スワップ
システム
の
式
再帰
的
リンクトリスト
記述
5
種類
基本
これら
データ
構造
解釈
こと
可能
Lisp
システム
毎回
式
解釈
代わり
機械
語
コンパイル
よう
現実
的
妥協
Lisper
非常
柔軟
カーネル
快適
作業
以下
の
Lisp
アイデア
直接
Lisp
いくつ
機能
マクロ
コード
引数
コード
関数
コード
変換
器
言語
表現
力
拡張
コンパイル
時
計算
実行
よう
Lisper
自分
作成
言語
インタプリタ
Lisp
こと
言語
ため
Lisp
ブートストラッピング
制定
の
これら
意味
DSL
(
ドメイン
特
化
言語
)
こと
Lisp
それ
自身
インタプリタ
よう
言語
代替
セマンティクス
の
最適
私
たち
プログラミング
道
がち
現在
偉大
言語
絶え間
変化
今日
言語
15
年
後
Lisp
アイデア
現時点
有望
生まれ変わり
JVM
JavaScript
動作
Clojure
以下
よう
Lisp
アイデア
あなた
好み
言語
REPL
Read
-
Eval
-
Print
-
Loop
対話
型
評価
環境
略
それ
定義
4
Lisp
構造
体
名前
あなた
お気に入り
言語
コード
入力
実行
こと
インタラクティブ
プロンプト
それ
Lisp
由来
の
1960
年
コンピュータ
科学
者
たち
再帰
関数
可能
こと
非常
コスト
当時
1
主要
言語
Fortran
頃
再帰
関数
再帰
関数
話
Lisp
ガベージコレクション
(
GC
)
最初
言語
言語
テンポラリ
オブジェクト
作成
それら
間
生存
こと
Lisp
GC
必要
主
要因
条件
式
発明
の
John
McCarthy
の
彼
Algol
条件
式
追加
よう
Algol
開発
プロジェクト
今日
言語
そこ
条件
式
前述
ここ
McCarthy
登場
以前
プログラマ
数学
1
文字
変数
名
使用
自分
お気に入り
言語
構文
配列
マップ
直接
記述
こと
括弧
それ
最初
の
Lisp
の
Alan
Kay
言葉
コンピュータ
科学
学位
取得
学生
Lisp
意義
さ
理解
Lisp
コンピュータ
科学
重要
アイデア
私
自身
卒業
時
意義
さ
理解
卒業
たくさん
読書
探求
コンピュータ
科学
適切
教養
こと
実感
ニュースレター
ご覧
私
内容
確認
こと
可能
40
年
以上
前
発表
奥行き
さ
魅了
コンピュータ
科学
プログラミング
歴史
Lisp
アイデア
数々
興味
PurelyFunctional
.
tv
Newsletter
チェック
Lisp
関数
型
プログラミング
歴史
現在
未来
考察
週刊
ニュースレター
関連
投稿
Lisp
アイデア
|
コンピュータ
サイエンス
|
POSTD**************************************Lisp
の
データ
コード
残り
私
たち
R
最高
プログラミング
言語
理由
Lisp
アイデア
CSS
言語
たち
WebSocket
合戦
Clojure
C
++、
Elixir
Go
NodeJS
Ruby
恐竜
Lisp
:
Chrome
インターネット
接続
画面
Lisp
プレイ
Next
Post
Previous
Post
最近
投稿
タグ
アーカイブ
フォロー
Facebook
POSTD
プログラミング
エンジニア
トレンド
メディア
POSTD
最新
エントリ
Why
Lisp
?
(
2015
-
05
-
07
)
by
Ron
Garret
たくさん
人
私
昨日
Hacker
News
コメント
説明
メッセージ
以下
よう
質問
Lisp
表記
法
1
私
Lisp
コード
データ
構造
マッチ
の
重要
こと
の
理解
マッチ
行為
Lisp
の
答え
の
私
マクロ
大事
何
何
私
こと
質問
そう
ブログ
投稿
こと
以下
私
答え
手短
Lisp
表記
法
1
プログラミング
何
考え方
根本
的
もの
の
プログラミング
主流
考え方
プログラミング
データ
人工
物
それ
処理
スタンドアローン
人工
物
プログラム
こと
もの
プログラム
データ
こと
誰
事実
上記
主流
考え方
2
コンセプト
人為
的
区別
主張
もの
プログラム
データ
コンパイラ
名
特殊
プログラム
ため
存在
データ
こと
コンパイラ
の
勉強
必要
自分
自身
コンパイラ
人
アカデミック
演習
以外
大抵
人
おもちゃ
よう
コンパイラ
熟練
技術
専門
家
コンパイラ
使用
Lisp
プログラミング
マシン
一般
的
インタラクション
マシン
何
記述
行為
あなた
記述
こと
マシン
実行
結果
観察
観察
元
あなた
マシン
こと
記述
変更
交互
どこ
プログラム
完成
どこ
それ
スタンドアローン
人工
物
明確
ライン
Lisp
よう
明確
ライン
こと
スタンドアローン
実行
ファイル
生成
こと
これ
C
言語
インタラクティブ
プログラム
こと
の
よう
もの
Lisp
AI
リサーチ
目的
開発
意図
的
インタラクティブ
C
言語
プログラム
オペレーション
目的
開発
インタラクティブ
Lisp
C
言語
スタンドアローン
実行
ファイル
作成
こと
ネイティブ
よう
C
言語
Lisp
インタラクティブ
性
ネイティブ
反復
以外
選択肢
場合
完成
デザイン
生成
の
必要
知識
十分
実験
スピード
命
時
よう
場合
プログラム
プログラム
よう
一般
的
仕組み
便利
C
言語
世界
よう
仕組み
存在
それ
pipe
C
言語
階層
的
データ
シリアライズ
/
デシリアライズ
標準
的
方法
代わり
C
言語
様々
種類
シリアライゼーションフォーマット
Fixed
-
Width
delimiter
-
separated
MIME
JSON
ICAL
SGML
そこ
派生
もの
HTML
XML
これ
一部
これら
データ
シリアライゼーションフォーマット
コード
記述
プログラミング
言語
それぞれ
独自
シンタックス
特異
性
保持
言語
生態
系
シンタックス
重要
奇妙
考え方
シンタックス
デザイン
たくさん
エネルギー
LEX
YACC
ツール
言語
世界
パーサ
こと
プログラマ
仕事
大半
今
昔
言語
人
コード
表現
シリライズフォーマット
データ
1
考え
一
度
努力
XML
JSON
表現
コード
コード
表現
ため
デザイン
シンタックス
表現
コード
絶対
的
もの
結局
データ
コード
表現
の
得策
パーサ
こと
の
それ
間違い
XML
JSON
表現
コード
もの
の
データ
コード
表現
の
得策
こと
XML
JSON
シリアライズフォーマット
デザイン
句読点
の
XML
場合
余計
もの
Lisp
他
シンタックス
コード
表現
の
の
S
式
シンタックス
シリアライズフォーマット
デザイン
S
式
最小限
コード
こと
3
以下
よう
XML
シンプル
例
明らか
JSON
式
よう
以下
よう
場合
式
本領
発揮
もの
JSON
以下
よう
これ
XML
みなさん
宿題
ただ
式
の
タイプ
違い
明確
小規模
データ
構造
害
さ
そう
引用
符
カンマ
非常
複雑
データ
構造
即座
負担
の
XML
よう
SGML
派生
言語
完全
お手上げ
Lisp
非常
効果
的
理由
Lisp
人
コード
データ
表現
直感
Lisp
非常
有効
手段
Lisp
インタプリタ
コンパイラ
の
簡単
C
言語
世界
パーサ
の
通常
仕事
の
Lisp
プログラミング
言語
ため
インタプリタ
コンパイラ
こと
当たり前
簡単
インタプリタ
コンパイラ
ため
コード
データ
表現
構文
必要
コード
データ
表現
最小
構文
の
それ
以外
もの
大量
カンマ
引用
符
山
括弧
訳
S
式
必要
S
式
階層
データ
表現
最小
構文
階層
データ
表現
ため
必要
の
トークンセパレータ
ブロックデリミタ
2
構文
要素
S
式
スペース
トークンセパレータ
丸
括弧
ブロックデリミタ
他
やり方
ここ
構文
要素
こと
Lisp
丸
括弧
目
Lisp
他
プログラミング
言語
丸
括弧
多用
わけ
こと
特筆
Lisp
１つ
ブロックデリミタ
丸
括弧
ため
丸
括弧
目
の
その他
言語
ブロック
種類
さまざま
ブロックデリミタ
C
言語
ファミリ
引数
リスト
部分
式
丸
括弧
配列
角
括弧
コード
ブロック
辞書
波
括弧
カンマ
セミコロン
ブロックデリミタ
使用
両者
比較
Lisp
方
C
よう
言語
ブロックデリミタ
コール
バック
ところ
JavaScript
デリミタ
頻繁
深み
文脈
デリミタ
把握
の
プログラマ
頭
問題
Lisp
プログラマ
心配
必要
ブロック
場合
括弧
タイプ
頭
必要
Lisp
プログラマ
思考
力
余裕
自分
たち
解決
問題
集中
こと
こと
コーディング
方
さ
そう
何
度
関連
投稿
Lisp
の
データ
コード
|
プログラミング
|
POSTD**************************************Linux
Linux
履歴
運営
者
デスク
トップ
向け
Linux
紹介
サイト
下
メニュー
上部
メニュー
内
サブ
メニュー
左
部
表示
画像
リンク
縦
場合
画像
クリック
リンク
先
参照
Linux
一覧
デスク
トップ
環境
使用
Linux
紹介
デスク
トップ
環境
Linux
デスク
トップ
環境
ウインドウ
マネージャ
紹介
その他
メモ
その他
Linux
関連
アプリ
メモ
書き
使用
手順
Linux
使用
手順
簡単
紹介
ページ
追加
変更
数
下
掲載
その他
修正
追加
場合
2017
/
05
/
14
使用
手順
追加
2017
/
05
/
08
Linux
メモ
Linux
一覧
統合
派生
系統
サブ
ページ
2016
/
09
/
26
その他
メモ
追加
(
Linux
メモ
アプリ
内容
分離
)
2016
/
08
/
26
デザイン
背景
見出し
変更
2016
/
08
/
25
Linux
誕生
25
周年
当時
告知
gihyo
.
jp
ITmedia
TechCrunch
2016
/
02
/
08
Linux
移行
追加
(
現在
その他
メモ
内
移動
)
2015
/
11
/
04
デザイン
リニューアル
2015
/
11
/
04
Linux
メモ
追加
(
Linux
一覧
Linux
情報
)
2014
/
12
/
17
デザイン
メニュー
構成
リニューアル
2014
/
02
/
22
サイト
開設
ふうせん
Fu
-
sen
.
(
志賀
慶一
)
運営
者
Tumblr
ブログ
Twitter
@
balloon
_
vendor
Facebook
ページ
Google
+
Linux
Counter
592655
Launchpad
balloon
あなた
Jimdo
無料
ホームページ
無料
新規
登録
https
://
jp
.
jimdo
.
com
デスク
トップ
向け
Linux
紹介
サイト
-
Linux**************************************あなた
アクセス
ページ
削除
URL
変更
１
検索
２
人気
記事
３
カテゴリー
４
無効
リンク
報告
サイト
ご覧
大変
申し訳
の
あなた
アクセス
ページ
削除
URL
変更
お手数
おかけ
以下
方法
目的
ページ
検索
ボックス
コンテンツ
該当
キーワード
入力
それ
ページ
リスト
表示
それぞれ
カテゴリー
トップページ
目的
ページ
サイト
内
無効
リンク
発見
場合
ページ
リンク
無効
報告
幸い
今後
サイト
よう
精進
お願い
©
Copyright
2017
エンジニア
入り口
.
All
rights
reserved
.
ページ**************************************あなた
アクセス
ページ
削除
URL
変更
１
検索
２
人気
記事
３
カテゴリー
４
無効
リンク
報告
サイト
ご覧
大変
申し訳
の
あなた
アクセス
ページ
削除
URL
変更
お手数
おかけ
以下
方法
目的
ページ
検索
ボックス
コンテンツ
該当
キーワード
入力
それ
ページ
リスト
表示
それぞれ
カテゴリー
トップページ
目的
ページ
サイト
内
無効
リンク
発見
場合
ページ
リンク
無効
報告
幸い
今後
サイト
よう
精進
お願い
©
Copyright
2017
エンジニア
入り口
.
All
rights
reserved
.
ページ